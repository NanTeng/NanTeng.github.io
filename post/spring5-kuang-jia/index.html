<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Spring5框架 | 南藤北玄参</title>
<meta name="description" content="唯沉默为最高的轻蔑" />
<link rel="shortcut icon" href="https://nanteng.github.io/favicon.ico">
<link rel="stylesheet" href="https://nanteng.github.io/styles/main.css">

<script src="https://nanteng.github.io/media/js/jquery.min.js"></script>
<script src="https://nanteng.github.io/media/js/masonry.pkgd.min.js"></script>
<script src="https://nanteng.github.io/media/js/aos.js"></script>
<script src="https://nanteng.github.io/media/js/pace.min.js"></script>
<script src="https://nanteng.github.io/media/js/view-image.min.js"></script>
<script src="https://nanteng.github.io/media/js/jquery.magnific-popup.min.js"></script>
<script src="https://nanteng.github.io/media/js/functions.js"></script>
    <meta name="referrer" content="never">
    <meta name="description" content="Spring5框架概述

Spring是轻量级的开源的JavaEE框架
Spring可以解决企业应用开发的复杂性
Spring有两个核心部分：IOC和AOP

IOC：控制反转，把创建对象过程交给 Spring 进行管理
Aop：面向切面，..." />
    <meta name="keywords" content="Java" />
    <script src="https://nanteng.github.io/media/js/waterfall.min.js"></script>
    <script src="https://nanteng.github.io/media/js/prism.min.js"></script>
  </head>
  <body>
            <header id="header" class="grid-container">
        <!-- start: .menu-wrapper -->
        <div class="menu-mobile"> 
          <i class="fa fa-reorder"></i>
        </div>
        <div class="menu-wrapper">
          <div class="">
            <div class="logo">
              <a href="https://nanteng.github.io"><img src="\media\images\custom-headerLogo.gif" alt=""></a>
            </div>
            <!-- start: .main-nav -->

            <nav class="main-nav grid-container grid-parent">
              <ul id="menu-header" class="menu gradient-effect">
                <li class=""><a href="https://nanteng.github.io" class="menu">首页</a></li>
                
                  <li class="" >
                    <a href="/archives" class="menu">
                      归档
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="/tags" class="menu">
                      标签
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="https://cloud.dearkai.cn" class="menu">
                      云盘
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="/post/about" class="menu">
                      关于
                    </a>
                  </li>
                
                <li class="search-menu-item hide-on-mobile hide-on-tablet"><a href="#search-lightbox" class="lightbox mfp-inline"><i class="fa fa-search-line"></i></a></li>
              </ul>
            </nav>
            <a href="#search-lightbox" class="lightbox epcl-search-button mfp-inline hide-on-tablet hide-on-desktop"><i class="fa fa-search-line"></i></a>
            <!-- end: .main-nav -->
            <div class="clear"></div>
            <div class="border hide-on-tablet hide-on-mobile"></div>
          </div>    
          <div class="clear"></div>
        </div>
        <!-- end: .menu-wrapper -->
        <div class="clear"></div>
      </header>
      <div class="hide-on-mobile hide-on-tablet hide-on-desktop">
        <div id="search-lightbox" class="grid-container grid-small grid-parent mfp-hide">
          <div class="search-wrapper section">
            <form id="gridea-search-form" data-update="1668567925322" action="/search/index.html" class="search-form" _lpchecked="1">
              <input type="text" name="q" id="s" value="" class="search-field" placeholder="搜点啥..." aria-label="搜点啥..." required="">
              <button type="submit" class="submit" aria-label="Submit">
                <i class="fa fa-search-line"></i>
              </button>
            </form>
          </div>
        </div>
      </div>

      <main id="single" class="main grid-container fullcover no-sidebar aos-init aos-animate" data-aos="fade">

        <div class="center content">
          <div class="featured-image cover" style="background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/tumblr_4367c0920e509941859ff81f3285b894_bd1cb190_2048.jpg');">
            <div class="meta top"> 
              <time class="meta-info" style="float:left;" datetime="2022-11-07"><i class="fa fa-calendar"></i><span class="lately">9 天前</span></time>
              
              <a href="https://nanteng.github.io/post/spring5-kuang-jia/#comments" class="comments meta-info" title="">
                <i class="fa fa-comment remixicon"></i><span class="comment-count valine-comment-count" data-xid="/spring5-kuang-jia/"> </span>
              </a>
              <span id="/spring5-kuang-jia/" class="leancloud_visitors views-counter meta-info" title=""><i class="fa fa-leancloud remixicon"></i><span class="leancloud-visitors-count"></span></span>
              
            </div>
            <div class="info">
              <div class="tags ">
                
                      <a href="https://nanteng.github.io/tag/TtKdK6ur-/" class="ctag ctag-0 ctag-TtKdK6ur-" aria-label="">Java</a>
                    
              </div>
              <h1 class="title ularge white bold">Spring5框架</h1>
            </div>
          </div>
        </div>  

        <div class="epcl-page-wrapper">
          <div class="left-content grid-70 np-mobile">
            <article class="main-article post">
              <section class="post-content">
                <div class="text">
                  <h2 id="spring5框架概述">Spring5框架概述</h2>
<ol>
<li>Spring是轻量级的开源的JavaEE框架</li>
<li>Spring可以解决企业应用开发的复杂性</li>
<li>Spring有两个核心部分：IOC和AOP
<ol>
<li>IOC：控制反转，把创建对象过程交给 Spring 进行管理</li>
<li>Aop：面向切面，不修改源代码进行功能增强</li>
</ol>
</li>
<li>Spring 特点
<ol>
<li>方便解耦，简化开发</li>
<li>Aop 编程支持</li>
<li>方便程序测试</li>
<li>方便和其他框架进行整合</li>
<li>方便进行事务操作</li>
<li>降低 API 开发难度</li>
</ol>
</li>
</ol>
<h2 id="ioc概念和原理">IOC(概念和原理)</h2>
<ol>
<li>
<p>什么是 IOC</p>
<ol>
<li>控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理</li>
<li>使用 IOC 目的：为了耦合度降低</li>
</ol>
</li>
<li>
<p>IOC 底层原理</p>
<ol>
<li>xml 解析、工厂模式、反射</li>
</ol>
</li>
<li>
<p>画图讲解 IOC 底层原理</p>
<figure data-type="image" tabindex="1"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221030185112304.png" alt="image-20221030185112304" loading="lazy"></figure>
</li>
</ol>
<h3 id="iocbeanfactory-接口">IOC（BeanFactory 接口）</h3>
<ol>
<li>
<p>IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂</p>
</li>
<li>
<p>Spring 提供 IOC 容器实现两种方式：（两个接口）</p>
<ol>
<li>
<p>BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用</p>
<blockquote>
<p>加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象</p>
</blockquote>
</li>
<li>
<p>ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</p>
<blockquote>
<p>加载配置文件时候就会把在配置文件对象进行创建</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>ApplicationContext 接口有实现类</p>
<figure data-type="image" tabindex="2"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221030185351004.png" alt="image-20221030185351004" loading="lazy"></figure>
</li>
</ol>
<h3 id="ioc-操作bean管理概念">IOC 操作Bean管理（概念）</h3>
<ol>
<li>什么是 Bean 管理
<ol>
<li>Bean 管理指的是两个操作
<ol>
<li>Spring 创建对象</li>
<li>Spirng 注入属性</li>
</ol>
</li>
</ol>
</li>
<li>Bean 管理操作有两种方式
<ol>
<li>基于 xml 配置文件方式实现</li>
<li>基于注解方式实现</li>
</ol>
</li>
</ol>
<h3 id="ioc-操作bean管理基于-xml-方式">IOC 操作Bean管理（基于 xml 方式）</h3>
<ol>
<li>
<p>基于 xml 方式创建对象</p>
<pre><code class="language-xml">&lt; !--配置User对象创建-- &gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.nanteng.spring5.User&quot;&gt;&lt;/bean&gt;
</code></pre>
<ol>
<li>
<p>在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建</p>
</li>
<li>
<p>在 bean 标签有很多属性，介绍常用的属性</p>
<p>id 属性：唯一标识</p>
<p>class 属性：类全路径（包类路径）</p>
</li>
</ol>
</li>
<li>
<p>基于 xml 方式注入属性</p>
<ol>
<li>DI：依赖注入，就是注入属性</li>
</ol>
</li>
<li>
<p>第一种注入方式：使用 set 方法进行注入'</p>
<ol>
<li>创建类，定义属性和对应的 set 方法</li>
</ol>
<pre><code class="language-java">/**
* 演示使用 set 方法进行注入属性
*/
public class Book {
 //创建属性
 private String bname;
 private String bauthor;
 //创建属性对应的 set 方法
 public void setBname(String bname) {
 this.bname = bname;
 }
 public void setBauthor(String bauthor) {
 this.bauthor = bauthor;
 }
}
</code></pre>
<ol start="2">
<li>在 spring 配置文件配置对象创建，配置属性注入</li>
</ol>
<pre><code class="language-xml">&lt; !--2 set 方法注入属性-- &gt;
&lt;bean id=&quot;book&quot; class=&quot;com.nanteng.spring5.Book&quot;&gt;
 &lt; !--使用 property 完成属性注入
 name：类里面属性名称
 value：向属性注入的值
 -- &gt;
 &lt;property name=&quot;bname&quot; value=&quot;易筋经&quot;&gt;&lt;/property&gt;
 &lt;property name=&quot;bauthor&quot; value=&quot;达摩老祖&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>第二种注入方式：使用有参数构造进行注入</p>
<ol>
<li>创建类，定义属性，创建属性对应有参数构造方法</li>
</ol>
<pre><code class="language-java">/**
* 使用有参数构造注入
*/
public class Orders {
 //属性
 private String oname;
 private String address;
 //有参数构造
 public Orders(String oname,String address) {
 this.oname = oname;
 this.address = address;
 }
}
</code></pre>
<ol start="2">
<li>在 spring 配置文件中进行配置</li>
</ol>
<pre><code class="language-xml">&lt; !--3 有参数构造注入属性-- &gt;
&lt;bean id=&quot;orders&quot; class=&quot;com.nanteng.spring5.Orders&quot;&gt;
 &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt;
 &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>p名称空间注入</p>
<ol>
<li>使用 p 名称空间注入，可以简化基于 xml 配置方式 第一步 添加 p 名称空间在配置文件中</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221030190606712.png" alt="image-20221030190606712" loading="lazy"></figure>
<ol start="2">
<li>进行属性注入，在 bean 标签里面进行操作</li>
</ol>
<pre><code class="language-xml">&lt;!--2 set 方法注入属性--&gt;
&lt;bean id=&quot;book&quot; class=&quot;com.nanteng.spring5.Book&quot; p:bname=&quot;九阳神功&quot; 
p:bauthor=&quot;无名氏&quot;&gt;&lt;/bean&gt;
</code></pre>
</li>
</ol>
<h3 id="ioc操作bean管理xml-注入其他类型属性">IOC操作Bean管理（xml 注入其他类型属性）</h3>
<ol>
<li>
<p><strong>字面量</strong></p>
<p>null 值</p>
<pre><code class="language-xml">&lt;!--null 值--&gt;
&lt;property name=&quot;address&quot;&gt;
 &lt;null/&gt;
&lt;/property&gt;
</code></pre>
<p>属性值包含特殊符号</p>
<pre><code class="language-xml">&lt;!--属性值包含特殊符号
 1 把&lt;&gt;进行转义 &amp;lt; &amp;gt;
 2 把带特殊符号内容写到 CDATA
--&gt;
&lt;property name=&quot;address&quot;&gt;
 &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt;
&lt;/property&gt;
</code></pre>
</li>
<li>
<p><strong>注入属性-外部 bean</strong></p>
<ol>
<li>创建两个类 service 类和 dao 类</li>
<li>在 service 调用 dao 里面的方法</li>
<li>在 spring 配置文件中进行配置</li>
</ol>
<pre><code class="language-java">public class UserService {
 //创建 UserDao 类型属性，生成 set 方法
 private UserDao userDao;
 public void setUserDao(UserDao userDao) {
 this.userDao = userDao;
 }
 public void add() {
 System.out.println(&quot;service add...............&quot;);
 userDao.update();
 }
}
</code></pre>
<pre><code class="language-xml">&lt;!--1 service 和 dao 对象创建--&gt;
&lt;bean id=&quot;userService&quot; class=&quot;com.nanteng.spring5.service.UserService&quot;&gt;
 &lt;!--注入 userDao 对象
 name 属性：类里面属性名称
 ref 属性：创建 userDao 对象 bean 标签 id 值
 --&gt;
 &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.nanteng.spring5.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt;
</code></pre>
</li>
<li>
<p><strong>注入属性-内部 bean</strong></p>
<ol>
<li>一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门 部门是一，员工是多</li>
<li>在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示</li>
</ol>
<pre><code class="language-java">//部门类
public class Dept {
 private String dname;
 public void setDname(String dname) {
 this.dname = dname;
 }
}
//员工类
public class Emp {
 private String ename;
 private String gender;
 //员工属于某一个部门，使用对象形式表示
 private Dept dept;
 public void setDept(Dept dept) {
 this.dept = dept;
 }
 public void setEname(String ename) {
 this.ename = ename;
 }
 public void setGender(String gender) {
 this.gender = gender;
 }
}
</code></pre>
<ol start="3">
<li>在 spring 配置文件中进行配置</li>
</ol>
<pre><code class="language-xml">&lt;!--内部 bean--&gt;
&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;
 &lt;!--设置两个普通属性--&gt;
 &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt;
 &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
 &lt;!--设置对象类型属性--&gt;
 &lt;property name=&quot;dept&quot;&gt;
     &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt;
     	&lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt;
     &lt;/bean&gt;
 &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p><strong>注入属性-级联赋值</strong></p>
<ol>
<li>第一种写法</li>
</ol>
<pre><code class="language-xml">&lt;!--级联赋值--&gt;
&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;
     &lt;!--设置两个普通属性--&gt;
     &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
     &lt;!--级联赋值--&gt;
     &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt;
 	&lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;

</code></pre>
<p>2.第二种写法</p>
<pre><code class="language-java">//员工属于某一部门，使用对象形式表示
	private Dept dept;
	//生成dept的get方法
	public Dept getDept(){
        return dept;
    }

	public void setDept(Dept dept){
        this.dept = dept;
    }
</code></pre>
<pre><code class="language-xml">&lt;!--级联赋值--&gt;
&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt;
     &lt;!--设置两个普通属性--&gt;
    &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt;
     &lt;!--级联赋值--&gt;
     &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt;
 	&lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;    
</code></pre>
</li>
</ol>
<h3 id="ioc操作bean管理xml-注入集合属性">IOC操作Bean管理（xml 注入集合属性）</h3>
<ol>
<li>
<p>注入数组类型属性</p>
</li>
<li>
<p>注入 List 集合类型属性</p>
</li>
<li>
<p>注入 Map 集合类型属性</p>
<ol>
<li>创建类，定义数组、list、map、set 类型属性，生成对应 set 方法</li>
</ol>
<pre><code class="language-java">public class Stu {
     //1 数组类型属性
     private String[] courses;
     //2 list 集合类型属性
     private List&lt;String&gt; list;
     //3 map 集合类型属性
     private Map&lt;String,String&gt; maps;
     //4 set 集合类型属性
     private Set&lt;String&gt; sets;
     public void setSets(Set&lt;String&gt; sets) {
     this.sets = sets;
     }
     public void setCourses(String[] courses) {
     this.courses = courses;
     }
     public void setList(List&lt;String&gt; list) {
     this.list = list;
     }
     public void setMaps(Map&lt;String, String&gt; maps) {
     this.maps = maps;
     }
}
</code></pre>
<ol start="2">
<li>在 spring 配置文件进行配置</li>
</ol>
<pre><code class="language-xml">&lt;!--1 集合类型属性注入--&gt;
&lt;bean id=&quot;stu&quot; class=&quot;com.atguigu.spring5.collectiontype.Stu&quot;&gt;
     &lt;!--数组类型属性注入--&gt;
     &lt;property name=&quot;courses&quot;&gt;
         &lt;array&gt;
             &lt;value&gt;java 课程&lt;/value&gt;
             &lt;value&gt;数据库课程&lt;/value&gt;
         &lt;/array&gt;
     &lt;/property&gt;
 	&lt;!--list 类型属性注入--&gt;
     &lt;property name=&quot;list&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;张三&lt;/value&gt;
            &lt;value&gt;小三&lt;/value&gt;
        &lt;/list&gt;
     &lt;/property&gt;
    &lt;!--map 类型属性注入--&gt;
     &lt;property name=&quot;maps&quot;&gt;
         &lt;map&gt;
             &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt;
             &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt;
         &lt;/map&gt;
     &lt;/property&gt;
     &lt;!--set 类型属性注入--&gt;
     &lt;property name=&quot;sets&quot;&gt;
         &lt;set&gt;
             &lt;value&gt;MySQL&lt;/value&gt;
             &lt;value&gt;Redis&lt;/value&gt;
         &lt;/set&gt;
     &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>在集合里面设置对象类型值</p>
<pre><code class="language-xml">&lt;!--创建多个 course 对象--&gt;
&lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt;
 	&lt;property name=&quot;cname&quot; value=&quot;Spring5 框架&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt;
 	&lt;property name=&quot;cname&quot; value=&quot;MyBatis 框架&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
&lt;!--注入 list 集合类型，值是对象--&gt;
&lt;property name=&quot;courseList&quot;&gt;
     &lt;list&gt;
         &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt;
         &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt;
     &lt;/list&gt;
&lt;/property&gt;
</code></pre>
</li>
<li>
<p>把集合注入部分提取出来</p>
<ol>
<li>在 spring 配置文件中引入名称空间 util</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
     xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd
 http://www.springframework.org/schema/util 
http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;
</code></pre>
<p>2.使用 util 标签完成 list 集合注入提取</p>
<pre><code class="language-xml">&lt;!--1 提取 list 集合类型属性注入--&gt;
&lt;util:list id=&quot;bookList&quot;&gt;
     &lt;value&gt;易筋经&lt;/value&gt;
     &lt;value&gt;九阴真经&lt;/value&gt;
     &lt;value&gt;九阳神功&lt;/value&gt;
&lt;/util:list&gt;
&lt;!--2 提取 list 集合类型属性注入使用--&gt;
&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.collectiontype.Book&quot;&gt;
 	&lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ol>
<h3 id="ioc-操作-bean-管理factorybean">IOC 操作 Bean 管理（FactoryBean）</h3>
<ol>
<li>
<p>Spring 有两种类型 bean，一种<code>普通 bean</code>，另外一种<code>工厂 bean（FactoryBean）</code></p>
<p>普通 bean：在配置文件中定义 bean 类型就是返回类型</p>
<p>工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样</p>
<p>​	第一步：创建类，让这个类作为工厂 bean，实现接口 FactoryBean</p>
<p>​	第二布： 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p>
<pre><code class="language-java">public class MyBean implements FactoryBean&lt;Course&gt; {
     //定义返回 bean
     @Override
     public Course getObject() throws Exception {
         Course course = new Course();
         course.setCname(&quot;abc&quot;);
     return course;
 }
     @Override
     public Class&lt;?&gt; getObjectType() {
     return null;
     }
     @Override
     public boolean isSingleton() {
     return false;
     }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;myBean&quot; class=&quot;com.atguigu.spring5.factorybean.MyBean&quot;&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">@Test
public void test3() {
 ApplicationContext context =
 new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;);
 Course course = context.getBean(&quot;myBean&quot;, Course.class);
 System.out.println(course);
}
</code></pre>
</li>
</ol>
<h3 id="ioc-操作-bean-管理bean-作用域">IOC 操作 Bean 管理（bean 作用域）</h3>
<ol>
<li>
<p>在 Spring 里面，设置创建 bean 实例是单实例还是多实例</p>
</li>
<li>
<p>在 Spring 里面，默认情况下，bean 是单实例对象</p>
<figure data-type="image" tabindex="4"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221030193857707.png" alt="image-20221030193857707" loading="lazy"></figure>
</li>
<li>
<p>如何设置单实例还是多实例</p>
<ol>
<li>
<p>在 spring 配置文件 bean 标签里面有属性（<code>scope</code>）用于设置单实例还是多实例</p>
</li>
<li>
<p>scope 属性值</p>
<ol>
<li>默认值，<code>singleton</code>，表示是单实例对象</li>
<li>prototype，表示是多实例对象</li>
</ol>
<figure data-type="image" tabindex="5"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221030194110572.png" alt="image-20221030194110572" loading="lazy"></figure>
<ol start="3">
<li>singleton 和 prototype 区别
<ol>
<li>singleton 单实例，prototype 多实例</li>
<li><strong>设置 scope 值是 singleton 时候</strong>，加载 spring 配置文件时候就会创建单实例对象 <strong>设置 scope 值是 prototype 时候</strong>，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="ioc-操作-bean-管理bean-生命周期">IOC 操作 Bean 管理（bean 生命周期）</h3>
<ol>
<li>
<p>生命周期</p>
<ol>
<li>从对象创建到对象销毁的过程</li>
</ol>
</li>
<li>
<p>bean 生命周期</p>
<ol>
<li>通过构造器创建 bean 实例（无参数构造）</li>
<li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li>
<li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li>
<li>bean 可以使用了（对象获取到了）</li>
<li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li>
</ol>
</li>
<li>
<p>演示 bean 生命周期</p>
<pre><code class="language-java">public class Orders {
     //无参数构造
     public Orders() {
     	System.out.println(&quot;第一步 执行无参数构造创建 bean 实例&quot;);
     }
    
     private String oname;
     public void setOname(String oname) {
     	this.oname = oname;
     	System.out.println(&quot;第二步 调用 set 方法设置属性值&quot;);
     }
     //创建执行的初始化的方法
     public void initMethod() {
     	System.out.println(&quot;第三步 执行初始化的方法&quot;);
     }
     //创建执行的销毁的方法
     public void destroyMethod() {
     	System.out.println(&quot;第五步 执行销毁的方法&quot;);
     }
}
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;orders&quot; class=&quot;com.atguigu.spring5.bean.Orders&quot; initmethod=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;
 	&lt;property name=&quot;oname&quot; value=&quot;手机&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-java">@Test
     public void testBean3() {
    // ApplicationContext context =
    // new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);
     ClassPathXmlApplicationContext context =
     new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;);
     Orders orders = context.getBean(&quot;orders&quot;, Orders.class);
     System.out.println(&quot;第四步 获取创建 bean 实例对象&quot;);
     System.out.println(orders);
     //手动让 bean 实例销毁
     context.close();
 }

</code></pre>
<figure data-type="image" tabindex="6"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221030195631407.png" alt="image-20221030195631407" loading="lazy"></figure>
</li>
<li>
<p>bean 的后置处理器，bean 生命周期有七步</p>
<ol>
<li>通过构造器创建 bean 实例（无参数构造）</li>
<li>为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）</li>
<li>把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization</li>
<li>调用 bean 的初始化的方法（需要进行配置初始化的方法）</li>
<li>把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization</li>
<li>bean 可以使用了（对象获取到了）</li>
<li>当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）</li>
</ol>
</li>
<li>
<p>演示添加后置处理器效果</p>
<ol>
<li>创建类，实现接口 BeanPostProcessor，创建后置处理器</li>
</ol>
<pre><code class="language-java">public class MyBeanPost implements BeanPostProcessor {
     @Override
     public Object postProcessBeforeInitialization(Object bean, String beanName) 
    throws BeansException {
        System.out.println(&quot;在初始化之前执行的方法&quot;);
        return bean;
     }
     @Override
     public Object postProcessAfterInitialization(Object bean, String beanName) 
    throws BeansException {
     	System.out.println(&quot;在初始化之后执行的方法&quot;);
     	return bean;
     }
}
</code></pre>
<pre><code class="language-xml">&lt;!--配置后置处理器--&gt;
&lt;bean id=&quot;myBeanPost&quot; class=&quot;com.atguigu.spring5.bean.MyBeanPost&quot;&gt;&lt;/bean&gt;
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221030195926792.png" alt="image-20221030195926792" loading="lazy"></figure>
</li>
</ol>
<h3 id="ioc-操作-bean-管理xml-自动装配">IOC 操作 Bean 管理（xml 自动装配）</h3>
<ol>
<li>
<p>什么是自动装配</p>
<ol>
<li>根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入</li>
</ol>
</li>
<li>
<p>演示自动装配过程</p>
<ol>
<li>根据属性名称自动注入</li>
</ol>
<pre><code class="language-xml">&lt;!--实现自动装配
 bean 标签属性 autowire，配置自动装配
 autowire 属性常用两个值：
 byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样
 byType 根据属性类型注入
--&gt;
&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byName&quot;&gt;
 &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;
&lt;/bean&gt;
&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean&gt;
</code></pre>
<ol start="2">
<li>根据属性类型自动注入</li>
</ol>
<pre><code class="language-xml">&lt;!--实现自动装配
 bean 标签属性 autowire，配置自动装配
 autowire 属性常用两个值：
 byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样
 byType 根据属性类型注入
--&gt;
&lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byType&quot;&gt;
 &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;
&lt;/bean&gt;
&lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean
</code></pre>
</li>
</ol>
<h3 id="ioc-操作-bean-管理外部属性文件">IOC 操作 Bean 管理(外部属性文件)</h3>
<ol>
<li>
<p>直接配置数据库信息</p>
<ol>
<li>配置德鲁伊连接池</li>
<li>引入德鲁伊连接池依赖 jar 包</li>
</ol>
<pre><code class="language-xml">&lt;!--直接配置连接池--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
 &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;
 &lt;property name=&quot;url&quot; 
value=&quot;jdbc:mysql://localhost:3306/userDb&quot;&gt;&lt;/property&gt;
 &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
 &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>引入外部属性文件配置数据库连接池</p>
<ol>
<li>创建外部属性文件，properties 格式文件，写数据库信息</li>
</ol>
<figure data-type="image" tabindex="8"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221030200438132.png" alt="image-20221030200438132" loading="lazy"></figure>
<ol start="2">
<li>
<p>把外部 properties 属性文件引入到 spring 配置文件中</p>
<blockquote>
<p>引入 context 名称空间</p>
</blockquote>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       	 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
         xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 
         xmlns:util=&quot;http://www.springframework.org/schema/util&quot; 
         xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 
         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
 							http://www.springframework.org/schema/util 
http://www.springframework.org/schema/util/spring-util.xsd 
 							http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
</code></pre>
<ul>
<li>在 spring 配置文件使用标签引入外部属性文件</li>
</ul>
<pre><code class="language-xml">&lt;!--引入外部属性文件--&gt;
&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;
&lt;!--配置连接池--&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
     &lt;property name=&quot;driverClassName&quot; value=&quot;${prop.driverClass}&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;url&quot; value=&quot;${prop.url}&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;username&quot; value=&quot;${prop.userName}&quot;&gt;&lt;/property&gt;
     &lt;property name=&quot;password&quot; value=&quot;${prop.password}&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="ioc操作bean管理基于注解方式">IOC操作Bean管理（基于注解方式）</h3>
<ol>
<li>
<p>什么是注解</p>
<ol>
<li>注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)</li>
<li>使用注解，注解作用在类上面，方法上面，属性上面</li>
<li>使用注解目的：简化 xml 配置</li>
</ol>
</li>
<li>
<p>Spring 针对 Bean 管理中创建对象提供注解</p>
<ol>
<li><code>@Component</code></li>
<li><code>@Service</code></li>
<li><code>@Controller</code></li>
<li><code>@Repository</code></li>
</ol>
<blockquote>
<p>上面四个注解功能是一样的，都可以用来创建 bean 实例</p>
</blockquote>
</li>
<li>
<p>基于注解方式实现对象创建</p>
<ol>
<li>引入依赖</li>
<li>开启组件扫描</li>
</ol>
<pre><code class="language-xml">&lt;!--开启组件扫描
 1 如果扫描多个包，多个包使用逗号隔开
 2 扫描包上层目录
--&gt;
&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
<ol start="3">
<li>创建类，在类上面添加创建对象注解</li>
</ol>
<pre><code class="language-java">//在注解里面 value 属性值可以省略不写，
//默认值是类名称，首字母小写
//UserService -- userService
@Component(value = &quot;userService&quot;) //&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;
public class UserService {
     public void add() {
     	System.out.println(&quot;service add.......&quot;);
     }
}
</code></pre>
</li>
<li>
<p>开启组件扫描细节配置</p>
</li>
</ol>
<pre><code class="language-xml">&lt;!--示例 1
 use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter
 context:include-filter ，设置扫描哪些内容
--&gt;
&lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt;
 &lt;context:include-filter type=&quot;annotation&quot; 
 
expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/context:component-scan&gt;
&lt;!--示例 2
 下面配置扫描包所有内容
 context:exclude-filter： 设置哪些内容不进行扫描
--&gt;
&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;
 &lt;context:exclude-filter type=&quot;annotation&quot; 
 
expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
&lt;/context:component-scan&gt;
</code></pre>
<ol start="5">
<li>
<p>基于注解方式实现属性注入</p>
<ol>
<li>
<p>@Autowired：根据属性类型进行自动装配</p>
<ol>
<li>把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解</li>
<li>在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解</li>
</ol>
<pre><code class="language-java">@Service
public class UserService {
 //定义 dao 类型属性
 //不需要添加 set 方法
 //添加注入属性注解
 @Autowired 
 private UserDao userDao;
     public void add() {
         System.out.println(&quot;service add.......&quot;);
         userDao.add();
     }
}
</code></pre>
</li>
<li>
<p>@Qualifier：根据名称进行注入（这个@Qualifier 注解的使用，和上面@Autowired 一起使用）</p>
</li>
</ol>
<pre><code class="language-java">//定义 dao 类型属性
//不需要添加 set 方法
//添加注入属性注解
@Autowired //根据类型进行注入
@Qualifier(value = &quot;userDaoImpl1&quot;) //根据名称进行注入
private UserDao userDao;

</code></pre>
<ol start="3">
<li>@Resource：可以根据类型注入，可以根据名称注入</li>
</ol>
<pre><code class="language-java">//@Resource //根据类型进行注入
@Resource(name = &quot;userDaoImpl1&quot;) //根据名称进行注入
private UserDao userDao;

</code></pre>
<ol start="4">
<li>@Value：注入普通类型属性</li>
</ol>
<pre><code class="language-java">@Value(value = &quot;abc&quot;)
private String name;
</code></pre>
</li>
<li>
<p>完全注解开发</p>
<ol>
<li>创建配置类，替代 xml 配置文件</li>
</ol>
<pre><code class="language-java">@Configuration //作为配置类，替代 xml 配置文件
@ComponentScan(basePackages = {&quot;com.atguigu&quot;})
public class SpringConfig {
}
</code></pre>
<p>2.编写测试类</p>
<pre><code class="language-java">@Test
public void testService2() {
 //加载配置类
 ApplicationContext context
 = new AnnotationConfigApplicationContext(SpringConfig.class);
 UserService userService = context.getBean(&quot;userService&quot;, 
UserService.class);
 System.out.println(userService);
 userService.add();
}
</code></pre>
</li>
</ol>
<h2 id="aop概念">AOP(概念)</h2>
<ol>
<li>
<p>什么是AOP</p>
<ol>
<li>面向切面编程（方面），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</li>
<li>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能</li>
<li>使用登录例子说明 AOP</li>
</ol>
<figure data-type="image" tabindex="9"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221103215459645.png" alt="image-20221103215459645" loading="lazy"></figure>
</li>
</ol>
<h3 id="aop底层原理">AOP(底层原理)</h3>
<ol>
<li>AOP底层使用动态代理
<ul>
<li>
<p>有两种情况动态代理</p>
</li>
<li>
<p>有接口情况，使用JDK动态代理</p>
<ol>
<li>创建接口实现类代理对象，增强类的方法</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221103215744799.png" alt="image-20221103215744799" loading="lazy"></figure>
</li>
<li>
<p>没有接口情况，使用CGKIB动态代理</p>
<ol>
<li>创建子类的代理对象，增强类的方法</li>
</ol>
<figure data-type="image" tabindex="11"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221103215801002.png" alt="image-20221103215801002" loading="lazy"></figure>
</li>
</ul>
</li>
</ol>
<h3 id="aopjdk动态代理">AOP(JDK动态代理)</h3>
<ol>
<li>
<p>使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象</p>
<figure data-type="image" tabindex="12"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221103220250840.png" alt="image-20221103220250840" loading="lazy"></figure>
<ol>
<li>调用 <code>newProxyInstance</code> 方法</li>
</ol>
<figure data-type="image" tabindex="13"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221103220432432.png" alt="image-20221103220432432" loading="lazy"></figure>
<p>方法有三个参数：</p>
<p>第一参数，类加载器</p>
<p>第二参数，增强方法所在的类，这个类实现的接口，支持多个接口</p>
<p>第三参数，实现这个接口 <code>InvocationHandler</code>，创建代理对象，写增强的部分</p>
</li>
<li>
<p>编写 JDK 动态代理代码</p>
<ol>
<li>
<p>创建接口，定义方法</p>
<pre><code class="language-java">public interface UserDao {
	public int add(int a,int b);
	public String update(String id);
}
</code></pre>
</li>
<li>
<p>创建接口实现类，实现方法</p>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
     @Override
     public int add(int a, int b) {
     	return a+b;
     }
     @Override
     public String update(String id) {
     	return id;
     }
}
</code></pre>
</li>
<li>
<p>使用 Proxy 类创建接口代理对象</p>
<pre><code class="language-java">public class JDKProxy {
    public static void main(String[] args) {
	//创建接口实现类代理对象
 	Class[] interfaces = {UserDao.class};
	// Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() {
	// @Override
	// public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		// return null;
	// }
// });
 	UserDaoImpl userDao = new UserDaoImpl();
 UserDao dao = 
(UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,new UserDaoProxy(userDao));
 int result = dao.add(1, 2);
 System.out.println(&quot;result:&quot;+result);
 }
}
//创建代理对象代码
class UserDaoProxy implements InvocationHandler {
 	//1 把创建的是谁的代理对象，把谁传递过来
 	//有参数构造传递
 	private Object obj;
 	public UserDaoProxy(Object obj) {
 		this.obj = obj;
 }
 	//增强的逻辑
 	@Override
 	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 	//方法之前
 	System.out.println(&quot;方法之前执行....&quot;+method.getName()+&quot; :传递的参
数...&quot;+ Arrays.toString(args));
 	//被增强的方法执行
 	Object res = method.invoke(obj, args);
 	//方法之后
 	System.out.println(&quot;方法之后执行....&quot;+obj);
 		return res;
 	}
}
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="aop术语">AOP术语</h3>
<ol>
<li>连接点：类里面可以被增强的方法</li>
<li>切入点：实际被增强的方法，称为切入点</li>
<li>通知（增强）
<ol>
<li>实际增强的逻辑部分称为通知（增强）</li>
<li>通知有多种类型
<ol>
<li>前置通知</li>
<li>后置通知</li>
<li>环绕通知</li>
<li>异常通知</li>
<li>最终通知</li>
</ol>
</li>
</ol>
</li>
<li>切面
<ol>
<li>把通知应用到切入点的过程</li>
</ol>
</li>
</ol>
<h3 id="aop操作准备工作">AOP操作（准备工作）</h3>
<ol>
<li>Spring 框架一般都是基于 AspectJ 实现 AOP 操作
<ol>
<li>AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作</li>
</ol>
</li>
<li>基于 AspectJ 实现 AOP 操作
<ol>
<li>基于 xml 配置文件实现</li>
<li>基于注解方式实现（使用）</li>
</ol>
</li>
<li>在项目工程里面引入 AOP 相关依赖</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221105173923674.png" alt="image-20221105173923674" loading="lazy"></figure>
<ol start="4">
<li>
<p>切入点表达式</p>
<ol>
<li>
<p>切入点表达式作用：知道对哪个类里面的哪个方法进行增强</p>
</li>
<li>
<p>语法结构： <code>execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) )</code></p>
<blockquote>
<p>例1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强</p>
<p>​			<code>execution(* com.atguigu.dao.BookDao.add(..))</code></p>
<p>例2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强</p>
<p>​			<code>execution(* com.atguigu.dao.BookDao.* (..))</code></p>
<p>例3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强			  <code>execution(* com.atguigu.dao.*.* (..))</code></p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h3 id="aop操作aspectj-注解">AOP操作（AspectJ 注解）</h3>
<ol>
<li>创建类，在类里面定义方法</li>
</ol>
<pre><code class="language-java">public class User {
 	public void add() {
 		System.out.println(&quot;add.......&quot;);
 	}
}
</code></pre>
<ol start="2">
<li>
<p>创建增强类（编写增强逻辑）</p>
<p>在增强类里面，创建方法，让不同方法代表不同通知类型</p>
</li>
</ol>
<pre><code class="language-java">//增强的类
public class UserProxy {
 	public void before() {//前置通知
 		System.out.println(&quot;before......&quot;);
 	}
}
</code></pre>
<ol start="3">
<li>
<p>进行通知的配置</p>
<p>在 spring 配置文件中，开启注解扫描</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
         xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 
         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
 http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context.xsd 
 http://www.springframework.org/schema/aop 
http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
 &lt;!-- 开启注解扫描 --&gt;
 &lt;context:component-scan basepackage=&quot;com.atguigu.spring5.aopanno&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
<p>使用注解创建 User 和 UserProxy 对象</p>
<pre><code class="language-java">//被增强的类
@Component
public class User {}

//增强的类
@Component
public class UserProxy {}
</code></pre>
<p>在增强类上面添加注解 <code>@Aspect</code></p>
<pre><code class="language-java">//增强的类
@Component
@Aspent //生成代理对象
public class UserProxy {}
</code></pre>
<p>在 spring 配置文件中开启生成代理对象</p>
<pre><code class="language-xml">&lt;!-- 开启 Aspect 生成代理对象--&gt;
</code></pre>
</li>
<li>
<p>配置不同类型的通知</p>
<p>在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置</p>
<pre><code class="language-java">//增强的类
@Component
@Aspect //生成代理对象
public class UserProxy {
 		//前置通知
 		//@Before 注解表示作为前置通知
 		@Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)
 		public void before() {
 			System.out.println(&quot;before.........&quot;);
 		}
 		//后置通知（返回通知）
 		@AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)
 		public void afterReturning() {
     		System.out.println(&quot;afterReturning.........&quot;);
     }
         //最终通知
         @After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)
         public void after() {
         	System.out.println(&quot;after.........&quot;);
         }
 		//异常通知
     @AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)
     public void afterThrowing() {
     	System.out.println(&quot;afterThrowing.........&quot;);
     }
 		//环绕通知
 		@Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)
 		public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
 		System.out.println(&quot;环绕之前.........&quot;);
 		//被增强的方法执行
 		proceedingJoinPoint.proceed();
 		System.out.println(&quot;环绕之后.........&quot;);
 	}
}
</code></pre>
</li>
<li>
<p>相同的切入点抽取</p>
<pre><code class="language-java">//相同切入点抽取
@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)
public void pointdemo() {
}
//前置通知
//@Before 注解表示作为前置通知
@Before(value = &quot;pointdemo()&quot;)
public void before() {
 	System.out.println(&quot;before.........&quot;);
}
</code></pre>
</li>
<li>
<p>有多个增强类多同一个方法进行增强，设置增强类优先级</p>
<p>在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高</p>
<pre><code class="language-java">@Component
@Aspect
@Order(1)
public class PersonProxy
</code></pre>
</li>
<li>
<p>完全使用注解开发</p>
<p>创建配置类，不需要创建 xml 配置文件</p>
<pre><code class="language-java">@Configuration
@ComponentScan(basePackages = {&quot;com.atguigu&quot;})
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class ConfigAop {
}
</code></pre>
</li>
</ol>
<h3 id="aop操作aspectj-配置文件">AOP操作（AspectJ 配置文件）</h3>
<ol>
<li>
<p>创建两个类，增强类和被增强类，创建方法</p>
</li>
<li>
<p>在 spring 配置文件中创建两个类对象</p>
<pre><code class="language-xml">&lt;!--创建对象--&gt;
&lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.aopxml.Book&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;bookProxy&quot; class=&quot;com.atguigu.spring5.aopxml.BookProxy&quot;&gt;&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>在 spring 配置文件中配置切入点</p>
<pre><code class="language-xml">&lt;!--配置 aop 增强--&gt;
&lt;aop:config&gt;
 	&lt;!--切入点--&gt;
 	&lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.atguigu.spring5.aopxml.Book.buy(..))&quot;/&gt;
 	&lt;!--配置切面--&gt;
 		&lt;aop:aspect ref=&quot;bookProxy&quot;&gt;
 			&lt;!--增强作用在具体的方法上--&gt;
 			&lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;/&gt;
 		&lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h2 id="jdbctemplate概念和准备">JdbcTemplate(概念和准备)</h2>
<ol>
<li>
<p>什么是 JdbcTemplate</p>
<p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作</p>
</li>
<li>
<p>准备工作</p>
<p>引入相关 jar 包</p>
<figure data-type="image" tabindex="15"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221105182009933.png" alt="image-20221105182009933" loading="lazy"></figure>
<p>在 spring 配置文件配置数据库连接池</p>
<pre><code class="language-xml">&lt;!-- 数据库连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; 
 		destroy-method=&quot;close&quot;&gt;
         &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot; /&gt;
         &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
         &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt;
         &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
&lt;/bean&gt;

</code></pre>
<p>配置 JdbcTemplate 对象，注入 DataSource</p>
<pre><code class="language-xml">&lt;!-- JdbcTemplate 对象 --&gt;
&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
 	&lt;!--注入 dataSource--&gt;
 	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<p>创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象</p>
<p>配置文件</p>
<pre><code class="language-xml">&lt;!-- 组件扫描 --&gt;
&lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt;
</code></pre>
<p>Service</p>
<pre><code class="language-java">@Service
public class BookService {
     //注入 dao
     @Autowired
     private BookDao bookDao;
}

</code></pre>
<p>Dao</p>
<pre><code class="language-java">@Repository
public class BookDaoImpl implements BookDao {
     //注入 JdbcTemplate
     @Autowired
     private JdbcTemplate jdbcTemplate;
}
</code></pre>
</li>
</ol>
<h3 id="jdbctemplate-操作数据库添加">JdbcTemplate 操作数据库（添加）</h3>
<ol>
<li>
<p>对应数据库创建实体类</p>
<pre><code class="language-java">public class User {
    private String userId;
    private String username;
    private String ustatus;
    
    public void setUserId(String userId) {
        this.userId = userId;
    }
    
    public void setUsername(String username) {
        
    }
    
    public void setUstatus(String usatus) {
        
    }
}
</code></pre>
</li>
<li>
<p>编写 service 和 dao</p>
<p>在 dao 进行数据库添加操作</p>
<p>调用 JdbcTemplate 对象里面 update 方法实现添加操作</p>
<p><code>update(String sql,Object...args)</code></p>
<ol>
<li>第一个参数：sql语句</li>
<li>第二个参数：可变参数，设置sql语句值</li>
</ol>
<pre><code class="language-java">@Repository
public class BookDaoImpl implements BookDao {
    //注入 JdbcTemplate
     @Autowired
     private JdbcTemplate jdbcTemplate;
     //添加的方法
     @Override
     public void add(Book book) {
     //1 创建 sql 语句
     String sql = &quot;insert into t_book values(?,?,?)&quot;;
 	//2 调用方法实现
 	Object[] args = {book.getUserId(), book.getUsername(), book.getUstatus()};
 	int update = jdbcTemplate.update(sql,args);
	System.out.println(update);
 }
}
</code></pre>
</li>
<li>
<p>测试类</p>
<pre><code class="language-java">@Test
public void testJdbcTemplate() {
 	ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);
 	BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class);
     Book book = new Book();
     book.setUserId(&quot;1&quot;);
     book.setUsername(&quot;java&quot;);
     book.setUstatus(&quot;a&quot;);
     bookService.addBook(book);
}
</code></pre>
<p>对应表中字段</p>
<table>
<thead>
<tr>
<th style="text-align:center">user_id</th>
<th style="text-align:center">username</th>
<th style="text-align:center">ustaus</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">java</td>
<td style="text-align:center">a</td>
</tr>
</tbody>
</table>
</li>
</ol>
<h3 id="jdbctemplate-操作数据库修改和删除">JdbcTemplate 操作数据库（修改和删除）</h3>
<ol>
<li>
<p>修改</p>
<pre><code class="language-java">@Override
public void updateBook(Book book) {
 	String sql = &quot;update t_book set username=?,ustatus=? where user_id=?&quot;;
 	Object[] args = {book.getUsername(), book.getUstatus(),book.getUserId()};
 	int update = jdbcTemplate.update(sql, args);
 	System.out.println(update);
}
</code></pre>
</li>
<li>
<p>删除</p>
<pre><code class="language-java">@Override
public void delete(String id) {
     String sql = &quot;delete from t_book where user_id=?&quot;;
     int update = jdbcTemplate.update(sql, id);
     System.out.println(update);
}
</code></pre>
</li>
</ol>
<h3 id="jdbctemplate-操作数据库查询返回某个值">JdbcTemplate 操作数据库（查询返回某个值）</h3>
<ol>
<li>查询表里面有多少条记录，返回是某个值</li>
<li>使用 JdbcTemplate 实现查询返回某个值代码</li>
</ol>
<ul>
<li>
<p><code>queryForObject(String sql,Class&lt;T&gt; requiredType)</code></p>
<p>第一个参数：sql 语句</p>
<p>第二个参数：返回类型 Class</p>
</li>
</ul>
<pre><code class="language-java">//查询表记录数
@Override
public int selectCount() {
     String sql = &quot;select count(*) from t_book&quot;;
     Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
     return count;
}
</code></pre>
<h3 id="jdbctemplate-操作数据库查询返回对象">JdbcTemplate 操作数据库（查询返回对象）</h3>
<ol>
<li>场景：查询图书详情</li>
<li>JdbcTemplate 实现查询返回对象</li>
</ol>
<ul>
<li>
<p><code>queryForObject(String sql,RowMapper&lt;T&gt; rowMapper,Object... args)</code></p>
<p>第一个参数：sql 语句</p>
<p>第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装</p>
<p>第三个参数：sql 语句值</p>
</li>
</ul>
<pre><code class="language-java">//查询返回集合
@Override
public List&lt;Book&gt; findAllBook() {
 	String sql = &quot;select * from t_book&quot;;
	//调用方法
 	List&lt;Book&gt; bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class));
 	return bookList;
}
</code></pre>
<h3 id="jdbctemplate-操作数据库批量操作">JdbcTemplate 操作数据库（批量操作）</h3>
<ol>
<li>批量操作：操作表里面多条记录</li>
<li>JdbcTemplate 实现批量添加操作</li>
</ol>
<ul>
<li>
<p><code>batchUpdate(String sql,List&lt;Object[]&gt; batchArgs)</code></p>
<p>第一个参数：sql 语句</p>
<p>第二个参数：List 集合，添加多条记录数据</p>
</li>
</ul>
<pre><code class="language-java">//批量添加
@Override
public void batchAddBook(List&lt;Object[]&gt; batchArgs) {
     String sql = &quot;insert into t_book values(?,?,?)&quot;;
     int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);
     System.out.println(Arrays.toString(ints));
}

//批量添加测试
List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();
        Object[] o1 = {&quot;3&quot;,&quot;java&quot;,&quot;a&quot;};
        Object[] o2 = {&quot;4&quot;,&quot;c++&quot;,&quot;b&quot;};
        Object[] o3 = {&quot;5&quot;,&quot;MySQL&quot;,&quot;c&quot;};
        batchArgs.add(o1);
        batchArgs.add(o2);
        batchArgs.add(o3);
        //调用批量添加
        bookService.batchAdd(batchArgs);
</code></pre>
<ol start="3">
<li>JdbcTemplate 实现批量修改操作</li>
</ol>
<pre><code class="language-java">//批量修改
@Override
public void batchUpdateBook(List&lt;Object[]&gt; batchArgs) {
 	String sql = &quot;update t_book set username=?,ustatus=? where user_id=?&quot;;
 	int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);
 	System.out.println(Arrays.toString(ints));
}
//批量修改
List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();
        Object[] o1 = {&quot;java0909&quot;,&quot;a3&quot;,&quot;3&quot;};
        Object[] o2 = {&quot;c++1010&quot;,&quot;b4&quot;,&quot;4&quot;};
        Object[] o3 = {&quot;MySQL1111&quot;,&quot;c5&quot;,&quot;5&quot;};
        batchArgs.add(o1);
        batchArgs.add(o2);
        batchArgs.add(o3);
        //调用方法实现批量修改
        bookService.batchUpdate(batchArgs);
</code></pre>
<ol start="4">
<li>
<p>JdbcTemplate 实现批量删除操作</p>
<pre><code class="language-java">//批量删除
@Override
public void batchDeleteBook(List&lt;Object[]&gt; batchArgs) {
     String sql = &quot;delete from t_book where user_id=?&quot;;
     int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);
     System.out.println(Arrays.toString(ints));
}
//批量删除
	List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();
	Object[] o1 = {&quot;3&quot;};
    Object[] o2 = {&quot;4&quot;};
    batchArgs.add(o1);
    batchArgs.add(o2);
    //调用方法实现批量删除
    bookService.batchDelete(batchArgs);

</code></pre>
</li>
</ol>
<h2 id="事务操作事务概念">事务操作（事务概念）</h2>
<ol>
<li>什么是事务
<ol>
<li>事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操 作都失败</li>
<li>典型场景：银行转账
<ol>
<li>lucy 转账 100 元 给 mary</li>
<li>lucy 少 100，mary 多 100</li>
</ol>
</li>
</ol>
</li>
<li>事务四个特性（ACID）
<ol>
<li><strong>原子性</strong></li>
<li><strong>一致性</strong></li>
<li><strong>隔离性</strong></li>
<li><strong>持久性</strong></li>
</ol>
</li>
</ol>
<h3 id="事务操作搭建事务操作环境">事务操作（搭建事务操作环境）</h3>
<figure data-type="image" tabindex="16"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221105185135845.png" alt="image-20221105185135845" loading="lazy"></figure>
<ol>
<li>
<p>创建数据库表，添加记录</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">username</th>
<th style="text-align:center">money</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">lucy</td>
<td style="text-align:center">1000</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">mary</td>
<td style="text-align:center">1000</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>创建 service，搭建 dao，完成对象创建和注入关系</p>
<p>service 注入 dao，在 dao 注入 JdbcTemplate，在 JdbcTemplate 注入 DataSource</p>
<pre><code class="language-java">@Service
public class UserService {
     //注入 dao
     @Autowired
     private UserDao userDao;
}
@Repository
public class UserDaoImpl implements UserDao {
     @Autowired
     private JdbcTemplate jdbcTemplate;
}
</code></pre>
</li>
<li>
<p>在 dao 创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法）</p>
<pre><code class="language-java">@Repository
public class UserDaoImpl implements UserDao {
     @Autowired
     private JdbcTemplate jdbcTemplate;
    
     //lucy 转账 100 给 mary
    //少钱
 	@Override
 	public void reduceMoney() {
         String sql = &quot;update t_account set money=money-? where username=?&quot;;
         jdbcTemplate.update(sql,100,&quot;lucy&quot;);
 }
     //多钱
     @Override
     public void addMoney() {
         String sql = &quot;update t_account set money=money+? where username=?&quot;;
         jdbcTemplate.update(sql,100,&quot;mary&quot;);
     }
}
</code></pre>
<pre><code class="language-java">@Service
public class UserService {
     //注入 dao
     @Autowired
     private UserDao userDao;
     //转账的方法
     public void accountMoney() {
     //lucy 少 100
     userDao.reduceMoney();
     //mary 多 100
     userDao.addMoney();
	 }
}
</code></pre>
</li>
<li>
<p>上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常，有问题</p>
<pre><code class="language-java">//转账的方法
public void accountMoney() {
    //lucy少100
    userDao.reduceMoney();
    
    //模拟异常
    int i = 10/0;
    
    //mary多100
    userDao.addMoney();
}
</code></pre>
</li>
<li>
<p>使用事务解决上述问题</p>
</li>
<li>
<p>事务的操作过程</p>
<pre><code class="language-java">public void addcountMoney(){
    try{
        
        //第一步 开启事务
        
        //第二部 进行业务操作
        //lucy 少100
        userDao.reduceMoney();
        
        //模拟异常
        int i = 10/0;
        
        //mary多100
        userDao.addMoney();
        
        //第三步 没有发生异常，提高事务
        
    }catch(Exception e){
        //第四步 出现异常，事务回滚
    }
}
</code></pre>
</li>
</ol>
<h3 id="事务操作spring-事务管理介绍">事务操作（Spring 事务管理介绍）</h3>
<ol>
<li>
<p>事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层）</p>
</li>
<li>
<p>在Spring进行事务管理操作</p>
<ol>
<li>编程式事务管理</li>
<li>声明式事务管理（使用）</li>
</ol>
</li>
<li>
<p>声明事务管理</p>
<ol>
<li>基于注解方式（使用）</li>
<li>基于XML配置文件方式</li>
</ol>
</li>
<li>
<p>在Spring进行声明式事务管理，底层使用AOP原理</p>
</li>
<li>
<p>在Spring事务管理API</p>
<p>提供了一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类</p>
<figure data-type="image" tabindex="17"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106224349985.png" alt="image-20221106224349985" loading="lazy"></figure>
</li>
</ol>
<h3 id="事务操作注解声明式事务管理">事务操作（注解声明式事务管理）</h3>
<ol>
<li>在 spring 配置文件配置事务管理器</li>
</ol>
<pre><code class="language-xml">&lt;!-- 创建事务管理器 --&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
	&lt;!--注入数据源--&gt;
 	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<ol start="2">
<li>
<p>在 spring 配置文件，开启事务注解</p>
<p>在 spring 配置文件引入名称空间 tx</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; 
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
     xmlns:context=&quot;http://www.springframework.org/schema/context&quot; 
     xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
     xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; 
     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
    http://www.springframework.org/schema/beans/spring-beans.xsd 
     http://www.springframework.org/schema/context 
    http://www.springframework.org/schema/context/spring-context.xsd 
     http://www.springframework.org/schema/aop 
    http://www.springframework.org/schema/aop/spring-aop.xsd
    http://www.springframework.org/schema/tx 
	http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;
</code></pre>
<p>开启事务注解</p>
<pre><code class="language-xml">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;
</code></pre>
</li>
<li>
<p>在 service 类上面（或者 service 类里面方法上面）添加事务注解</p>
<p><code>@Transactional</code>，这个注解添加到类上面，也可以添加方法上面</p>
<p>如果把这个注解添加类上面，这个类里面所有的方法都添加事务</p>
<p>如果把这个注解添加方法上面，为这个方法添加事务</p>
<pre><code class="language-java">@Service
@Transactional
public class UserSerivice{ }
</code></pre>
</li>
</ol>
<h3 id="事务操作声明式事务管理参数配置">事务操作（声明式事务管理参数配置）</h3>
<ol>
<li>
<p>在 service 类上面添加注解<code>@Transactional</code>，在这个注解里面可以配置事务相关参数</p>
<figure data-type="image" tabindex="18"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106225311374.png" alt="image-20221106225311374" loading="lazy"></figure>
</li>
<li>
<p><code>propagation</code>：事务传播行为</p>
<p>当一个事务方法被另外一个事务方法调用时候，这个事务方法如何进行</p>
<table>
<thead>
<tr>
<th>REQUIRED</th>
<th>如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行</th>
</tr>
</thead>
</table>
<figure data-type="image" tabindex="19"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106225536101.png" alt="image-20221106225536101" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>REQUIRED_NEW</th>
<th>当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，必须将它挂起。</th>
</tr>
</thead>
</table>
<figure data-type="image" tabindex="20"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106225712944.png" alt="image-20221106225712944" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>SUPPORTS</th>
<th>如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中。</th>
</tr>
</thead>
</table>
<figure data-type="image" tabindex="21"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106225831662.png" alt="image-20221106225831662" loading="lazy"></figure>
<blockquote>
<p>事务的传播行为可以有传播属性指定，Spring定义了7种类传播行为。</p>
<figure data-type="image" tabindex="22"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106230122633.png" alt="image-20221106230122633" loading="lazy"></figure>
</blockquote>
</li>
<li>
<p><code>ioslation</code>:事务的隔离级别</p>
<ul>
<li>
<p>事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题</p>
<ul>
<li>
<p>有三个读问题：脏读、不可重复读、虚（幻）读</p>
<p>脏读：一个未提交事务读取到另一个未提交事务的数据（致命缺陷）</p>
<figure data-type="image" tabindex="23"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106230439739.png" alt="image-20221106230439739" loading="lazy"></figure>
<p>不可重复读：一个未提交事务读取到另一提交事务修改数据</p>
<figure data-type="image" tabindex="24"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106230510935.png" alt="image-20221106230510935" loading="lazy"></figure>
<p>虚读：一个未提交事务读取到另一提交事务添加数据</p>
<blockquote>
<p>解决：通过设置事务隔离级别，解决读问题</p>
<figure data-type="image" tabindex="25"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106231022440.png" alt="image-20221106231022440" loading="lazy"></figure>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>timeout</code>：超时时间</p>
<p>事务需要在一定时间内进行提交，如果不提交进行回滚</p>
<p>默认值是 -1 ，设置时间以秒单位进行计算</p>
</li>
<li>
<p><code>readOnly</code>：是否只读</p>
<p>读：查询操作，写：添加修改删除操作</p>
<p>readOnly 默认值 false，表示可以查询，可以添加修改删除操作</p>
<p>设置 readOnly 值是 true，设置成 true 之后，只能查询</p>
</li>
<li>
<p><code>rollbackFor</code>：回滚</p>
<p>设置出现哪些异常进行事务回滚</p>
</li>
<li>
<p><code>noRollbackFor</code>：不回滚</p>
<p>设置出现哪些异常不进行事务回滚</p>
</li>
</ol>
<h3 id="事务操作xml-声明式事务管理">事务操作（XML 声明式事务管理）</h3>
<ol>
<li>
<p>在 spring 配置文件中进行配置</p>
<ol>
<li>
<p>配置事务管理器</p>
</li>
<li>
<p>配置通知</p>
</li>
<li>
<p>配置切入点和切面</p>
</li>
</ol>
<pre><code class="language-java">&lt;!--1 创建事务管理器--&gt;
&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
 	&lt;!--注入数据源--&gt;
 	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
    
&lt;!--2 配置通知--&gt;
&lt;tx:advice id=&quot;txadvice&quot;&gt;   
 	&lt;!--配置事务参数--&gt;
 	&lt;tx:attributes&gt;    
 		&lt;!--指定哪种规则的方法上面添加事务--&gt;
 		&lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt;
 		&lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt;
 	&lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
    
&lt;!--3 配置切入点和切面--&gt;
&lt;aop:config&gt;
 	&lt;!--配置切入点--&gt;
 	&lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.atguigu.spring5.service.UserService.*(..))&quot;/&gt;
 	&lt;!--配置切面--&gt;
 	&lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
</li>
</ol>
<h3 id="事务操作完全注解声明式事务管理">事务操作（完全注解声明式事务管理）</h3>
<ol>
<li>
<p>创建配置类，使用配置类替代 xml 配置文件</p>
<pre><code class="language-java">@Configuration //配置类
@ComponentScan(basePackages = &quot;com.atguigu&quot;) //组件扫描
@EnableTransactionManagement //开启事务
public class TxConfig {
 	//创建数据库连接池
 	@Bean
    public DruidDataSource getDruidDataSource() {
         DruidDataSource dataSource = new DruidDataSource();
         dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);
         dataSource.setUrl(&quot;jdbc:mysql:///user_db&quot;);
         dataSource.setUsername(&quot;root&quot;);
         dataSource.setPassword(&quot;root&quot;);
         return dataSource;
 }
     //创建 JdbcTemplate 对象
     @Bean
     public JdbcTemplate getJdbcTemplate(DataSource dataSource) {
         //到 ioc 容器中根据类型找到 dataSource
         JdbcTemplate jdbcTemplate = new JdbcTemplate();
         //注入 dataSource
         jdbcTemplate.setDataSource(dataSource);
         return jdbcTemplate;
     }
     //创建事务管理器
     @Bean
     public DataSourceTransactionManager 
        getDataSourceTransactionManager(DataSource dataSource) {
        DataSourceTransactionManager transactionManager = new 
        DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource);
        return transactionManager;
     }
}
</code></pre>
</li>
</ol>
<h2 id="spring5-框架新功能">Spring5 框架新功能</h2>
<ol>
<li>
<p>整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方 法在代码库中删除</p>
</li>
<li>
<p>Spring 5.0 框架自带了通用的日志封装</p>
<ol>
<li>
<p>Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2</p>
</li>
<li>
<p>Spring5 框架整合 Log4j2</p>
<p>第一步 引入 jar 包</p>
<figure data-type="image" tabindex="26"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106231944987.png" alt="image-20221106231944987" loading="lazy"></figure>
<p>第二步 创建 log4j2.xml 配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; 
ALL --&gt;
&lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，
当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt;
&lt;configuration status=&quot;INFO&quot;&gt;
 	&lt;!--先定义所有的 appender--&gt;
 	&lt;appenders&gt;
 		&lt;!--输出日志信息到控制台--&gt;
 		&lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;
 			&lt;!--控制日志输出的格式--&gt;
 			&lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;
 		&lt;/console&gt;
 	&lt;/appenders&gt;
 	&lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt;
 	&lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为
默认的日志输出--&gt;
 	&lt;loggers&gt;
         &lt;root level=&quot;info&quot;&gt;
            &lt;appender-ref ref=&quot;Console&quot;/&gt;
         &lt;/root&gt;
     &lt;/loggers&gt;
&lt;/configuration&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>Spring5 框架核心容器支持@Nullable 注解</p>
<p><code>@Nullable</code> 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以 为空，参数值可以为空</p>
<p>注解用在方法上面，方法返回值可以为空</p>
<pre><code class="language-java">@Nullable
String getId();
</code></pre>
<p>注解使用在方法参数里面，方法参数可以为空</p>
<pre><code class="language-java">public &lt;T&gt; void registerBean(@Nullable String beanName,...
</code></pre>
<p>注解使用在属性上面，属性值可以为空</p>
<pre><code class="language-java">@Nullable
private String bookName;
</code></pre>
</li>
<li>
<p>Spring5 核心容器支持函数式风格 GenericApplicationContext</p>
<pre><code class="language-java">//函数式风格创建对象，交给 spring 进行管理
@Test
public void testGenericApplicationContext() {
 	//1 创建 GenericApplicationContext 对象
 	GenericApplicationContext context = new 	GenericApplicationContext();
 	//2 调用 context 的方法对象注册
 	context.refresh();
 	context.registerBean(&quot;user1&quot;,User.class,() -&gt; new User());
 	//3 获取在 spring 注册的对象
 	// User user =(User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;);
    User user = (User)context.getBean(&quot;user1&quot;);
 	System.out.println(user);
}
</code></pre>
</li>
<li>
<p>Spring5 支持整合 JUnit5</p>
<ol>
<li>
<p>整合 JUnit4</p>
<p>第一步 引入 Spring 相关针对测试依赖</p>
<figure data-type="image" tabindex="27"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106232759489.png" alt="image-20221106232759489" loading="lazy"></figure>
<p>第二步 创建测试类，使用注解方式完成</p>
<pre><code class="language-java">@RunWith(SpringJUnit4ClassRunner.class) //单元测试框架
@ContextConfiguration(&quot;classpath:bean1.xml&quot;) //加载配置文件
public class JTest4 {
 	@Autowired
 	private UserService userService;
 	@Test
 	public void test1() {
 		userService.accountMoney();
 	}
}
</code></pre>
</li>
<li>
<p>Spring5 整合 JUnit5</p>
<p>第一步 引入 JUnit5 的 jar 包</p>
<figure data-type="image" tabindex="28"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221106232927365.png" alt="image-20221106232927365" loading="lazy"></figure>
<p>第二步 创建测试类，使用注解完成</p>
<pre><code class="language-java">@ExtendWith(SpringExtension.class)
@ContextConfiguration(&quot;classpath:bean1.xml&quot;)
public class JTest5 {
     @Autowired
     private UserService userService;
     @Test
     public void test1() {
     	userService.accountMoney();
 }
}
</code></pre>
<p>使用一个复合注解替代上面两个注解完成整合</p>
<pre><code class="language-java">@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)
public class JTest5 {
     @Autowired
     private UserService userService;
     @Test
     public void test1() {
     	userService.accountMoney();
     }
}
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="spring5-框架新功能webflux">Spring5 框架新功能（Webflux）</h3>
<ol>
<li>
<p>SpringWebflux 介绍</p>
<p>是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的，Webflux 使用 当前一种比较流程响应式编程出现的框架。</p>
<figure data-type="image" tabindex="29"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221107130418453.png" alt="image-20221107130418453" loading="lazy"></figure>
<p>使用传统 web 框架，比如 SpringMVC，这些基于 Servlet 容器，Webflux 是一种<strong>异步非阻 塞</strong>的框架，异步非阻塞的框架在 Servlet3.1 以后才支持，核心是基于 Reactor 的相关 API 实现 的。</p>
<blockquote>
<p>什么是异步非阻塞?</p>
<p>异步和同步</p>
<ul>
<li>异步和同步针对调用者，调用者发送请求，如果等着对方回应之后才去做其他事情就是同 步，如果发送请求之后不等着对方回应就去做其他事情就是异步</li>
</ul>
<p>非阻塞和阻塞</p>
<ul>
<li>阻塞和非阻塞针对被调用者，被调用者受到请求之后，做完请求任务之后才给出反馈就是阻 塞，受到请求之后马上给出反馈然后再去做事情就是非阻塞</li>
</ul>
<p>针对对象不一样</p>
</blockquote>
<blockquote>
<p>Webflux 特点：</p>
<ol>
<li>非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程</li>
<li>函数式编程：Spring5 框架基于 java8，Webflux 使用 Java8 函数式编程方式实现路由请求</li>
</ol>
</blockquote>
<p>比较 SpringMVC</p>
<figure data-type="image" tabindex="30"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221107130755679.png" alt="image-20221107130755679" loading="lazy"></figure>
<ul>
<li>两个框架都可以使用注解方式，都运行在 Tomet 等容器中</li>
<li>SpringMVC 采用命令式编程，Webflux 采用异步响应式编程</li>
</ul>
</li>
<li>
<p>响应式编程（Java 实现）</p>
<ol>
<li>
<p>什么是响应式编程</p>
<p>响应式编程是一种面向<strong>数据流</strong>和<strong>变化传播</strong>的编程范式。这意味着可以在编程语言中很方便 地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。 电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似&quot;=B1+C1&quot;的公 式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。</p>
</li>
<li>
<p>Java8 及其之前版本</p>
<p>提供的<strong>观察者模式</strong>两个类 <strong>Observer</strong> 和 <strong>Observable</strong></p>
<pre><code class="language-java">public class ObserverDemo extends Observable {
     public static void main(String[] args) {
     ObserverDemo observer = new ObserverDemo();
     //添加观察者
     observer.addObserver((o,arg)-&gt;{
     	System.out.println(&quot;发生变化&quot;);
     });
     observer.addObserver((o,arg)-&gt;{
     	System.out.println(&quot;手动被观察者通知，准备改变&quot;);
     });
     observer.setChanged(); //数据变化
     	observer.notifyObservers(); //通知
     }
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>响应式编程（Reactor 实现）</p>
<ol>
<li>
<p>响应式编程操作中，Reactor 是满足 Reactive 规范框架</p>
</li>
<li>
<p>Reactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作 符。Flux 对象实现发布者，返回 N 个元素；Mono 实现发布者，返回 0 或者 1 个元素</p>
</li>
<li>
<p>Flux 和 Mono 都是数据流的发布者，使用 Flux 和 Mono 都可以发出三种数据信号：元素值，错误信号，完成信号，错误信号和完成信号都代表终止信号，终止信号用于告诉 订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者</p>
<figure data-type="image" tabindex="31"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221107142142481.png" alt="image-20221107142142481" loading="lazy"></figure>
</li>
<li>
<p>代码演示 Flux 和 Mono</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
 &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
 	&lt;artifactId&gt;reactor-core&lt;/artifactId&gt;
 &lt;version&gt;3.1.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>编程代码</p>
<pre><code class="language-java">public static void main(String[] args) {
 //just 方法直接声明
 Flux.just(1,2,3,4);
 Mono.just(1);
 //其他的方法
 Integer[] array = {1,2,3,4};
 Flux.fromArray(array);

 List&lt;Integer&gt; list = Arrays.asList(array);
 Flux.fromIterable(list);
 Stream&lt;Integer&gt; stream = list.stream();
 Flux.fromStream(stream);
}
</code></pre>
<blockquote>
<p>三种信号特点</p>
<ol>
<li>错误信号和完成信号都是终止信号，不能共存的</li>
<li>如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流</li>
<li>如果没有错误信号，没有完成信号，表示是无限数据流</li>
</ol>
</blockquote>
<blockquote>
<p>调用 just 或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触 发数据流，不订阅什么都不会发生的</p>
<pre><code class="language-java">//just方法直接声明
Flux.just(1,2,3,4).subscribe(System.out::print);
Mono.jusr(1).subscribe(System.out::print);
</code></pre>
</blockquote>
</li>
</ol>
</li>
<li>
<p>操作符</p>
<p>对数据流进行一道道操作，成为操作符，比如工厂流水线</p>
<p>第一  map 元素映射为新元素</p>
<figure data-type="image" tabindex="32"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221107143026332.png" alt="image-20221107143026332" loading="lazy"></figure>
<p>第二  flatMap 元素映射为流</p>
<p>把每个元素转换流，把转换之后多个流合并大的流</p>
<figure data-type="image" tabindex="33"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221107143219277.png" alt="image-20221107143219277" loading="lazy"></figure>
</li>
</ol>
</li>
<li>
<p>SpringWebflux 执行流程和核心 API</p>
<p>SpringWebflux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO 框架，异步非阻 塞的框架</p>
<ol>
<li>
<p>Netty</p>
<p>BIO</p>
<figure data-type="image" tabindex="34"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221107143603422.png" alt="image-20221107143603422" loading="lazy"></figure>
<p>NIO</p>
<figure data-type="image" tabindex="35"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221107143619709.png" alt="image-20221107143619709" loading="lazy"></figure>
</li>
<li>
<p>SpringWebflux 执行过程和 SpringMVC 相似的</p>
<p>SpringWebflux 核心控制器 <code>DispatchHandler</code>，实现接口 <code>WebHandler</code></p>
<p>接口 WebHandler 有一个方法</p>
<pre><code class="language-java">public interface WebHandler {
    Mono&lt;Void&gt; handle(ServerWebExchange var1);
}
</code></pre>
<figure data-type="image" tabindex="36"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221107144304854.png" alt="image-20221107144304854" loading="lazy"></figure>
</li>
<li>
<p>SpringWebflux 里面 DispatcherHandler，负责请求的处理</p>
<p>HandlerMapping：请求查询到处理的方法</p>
<p>HandlerAdapter：真正负责请求处理</p>
<p>HandlerResultHandler：响应结果处理</p>
</li>
<li>
<p>SpringWebflux 实现函数式编程，两个接口：RouterFunction（路由处理）和 HandlerFunction（处理函数）</p>
</li>
</ol>
</li>
<li>
<p>SpringWebflux（基于注解编程模型）</p>
<p>SpringWebflux 实现方式有两种：注解编程模型和函数式编程模型</p>
<p>使用注解编程模型方式，和之前 SpringMVC 使用相似的，只需要把相关依赖配置到项目中， SpringBoot 自动配置相关运行容器，默认情况下使用 Netty 服务器</p>
<p>第一步 创建 SpringBoot 工程，引入 Webflux 依赖</p>
<figure data-type="image" tabindex="37"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image-20221107154412741.png" alt="image-20221107154412741" loading="lazy"></figure>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>第二步 配置启动端口号</p>
<pre><code class="language-properties">server.port=8080
</code></pre>
<p>第三步 创建包和相关类</p>
<ul>
<li>
<p>实体类</p>
<pre><code class="language-java">//实体类
public class User {
    private String name;
    private String gender;
    private Integer age;

    public User(){

    }

    public User(String name,String gender,Integer age){
        this.name=name;
        this.gender=gender;
        this.age=age;
    }

    public void setName(String name){...
}
</code></pre>
</li>
<li>
<p>创建接口定义操作的方法</p>
<pre><code class="language-java">//用户操作接口
public interface UserService {
     //根据 id 查询用户
     Mono&lt;User&gt; getUserById(int id);
     //查询所有用户
     Flux&lt;User&gt; getAllUser();
     //添加用户
     Mono&lt;Void&gt; saveUserInfo(Mono&lt;User&gt; user);
}

</code></pre>
<ul>
<li>接口实现类</li>
</ul>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
     //创建 map 集合存储数据
     private final Map&lt;Integer,User&gt; users = new HashMap&lt;&gt;();
     public UserServiceImpl() {
         this.users.put(1,new User(&quot;lucy&quot;,&quot;nan&quot;,20));
         this.users.put(2,new User(&quot;mary&quot;,&quot;nv&quot;,30));
         this.users.put(3,new User(&quot;jack&quot;,&quot;nv&quot;,50));
 	}
    
     //根据 id 查询
     @Override
     public Mono&lt;User&gt; getUserById(int id) {
     	return Mono.justOrEmpty(this.users.get(id));
     }
    
     //查询多个用户
     @Override
     public Flux&lt;User&gt; getAllUser() {
     	return Flux.fromIterable(this.users.values());
     }
    
     //添加用户
     @Override
     public Mono&lt;Void&gt; saveUserInfo(Mono&lt;User&gt; userMono) {
     	return userMono.doOnNext(person -&gt; {
     		//向 map 集合里面放值
             int id = users.size()+1;
             users.put(id,person);
             }).thenEmpty(Mono.empty());
     	}
}
</code></pre>
<ul>
<li>创建 controller</li>
</ul>
<pre><code class="language-java">    @RestController
    public class UserController {
         //注入 service
         @Autowired
         private UserService userService;
        
         //id 查询
         @GetMapping(&quot;/user/{id}&quot;)
         public Mono&lt;User&gt; geetUserId(@PathVariable int id) {
         	return userService.getUserById(id);
         }
        
         //查询所有
         @GetMapping(&quot;/user&quot;)
         public Flux&lt;User&gt; getUsers() {
         	return userService.getAllUser();
         }
        
         //添加
         @PostMapping(&quot;/saveuser&quot;)
         public Mono&lt;Void&gt; saveUser(@RequestBody User user) {
         	Mono&lt;User&gt; userMono = Mono.just(user);
         	return userService.saveUserInfo(userMono);
         }
    }
</code></pre>
<blockquote>
<p>说明</p>
<p>SpringMVC 方式实现，同步阻塞的方式，基于 SpringMVC+Servlet+Tomcat</p>
<p>SpringWebflux 方式实现，异步非阻塞 方式，基于 SpringWebflux+Reactor+Netty</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>、SpringWebflux（基于函数式编程模型）</p>
<ol>
<li>
<p>在使用函数式编程模型操作时候，需要自己初始化服务器</p>
</li>
<li>
<p>基于函数式编程模型时候，有两个核心接口：RouterFunction（实现路由功能，请求转发 给对应的 handler）和 HandlerFunction（处理请求生成响应的函数）。核心任务定义两个函数 式接口的实现并且启动需要的服务器。</p>
</li>
<li>
<p>SpringWebflux 请 求 和 响 应 不 再 是 ServletRequest 和 ServletResponse ，而是 ServerRequest 和 ServerResponse</p>
<p>第一步 把注解编程模型工程复制一份 ，保留 entity 和 service 内容</p>
<p>第二步 创建 Handler（具体实现方法）</p>
<pre><code class="language-java">public class UserHandler {
    private final UserService userService;
    public UserHandler(UserService userService) {
 	this.userService = userService;
	}
    
     //根据 id 查询
     public Mono&lt;ServerResponse&gt; getUserById(ServerRequest request) {
         //获取 id 值
         int userId = Integer.valueOf(request.pathVariable(&quot;id&quot;));
         
         //空值处理
         Mono&lt;ServerResponse&gt; notFound = ServerResponse.notFound().build();
         
         //调用 service 方法得到数据
         Mono&lt;User&gt; userMono = this.userService.getUserById(userId);
         //把 userMono 进行转换返回
         //使用 Reactor 操作符 flatMap
     	return userMono.flatMap(person -&gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(fromObject(person))).switchIfEmpty(notFound);
 	}
    
     //查询所有
     public Mono&lt;ServerResponse&gt; getAllUsers() {
     	//调用 service 得到结果
     	Flux&lt;User&gt; users = this.userService.getAllUser();
 		return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(users,User.cl
ass);
 }
     //添加
     public Mono&lt;ServerResponse&gt; saveUser(ServerRequest request) {
     //得到 user 对象
     Mono&lt;User&gt; userMono = request.bodyToMono(User.class);
     return ServerResponse.ok().build(this.userService.saveUserInfo(userMono));
     }
}
</code></pre>
<p>第三步 初始化服务器，编写 Router</p>
<ul>
<li>
<p>创建路由的方法</p>
<pre><code class="language-java">//1 创建 Router 路由
public RouterFunction&lt;ServerResponse&gt; routingFunction() {
     //创建 hanler 对象
     UserService userService = new UserServiceImpl();
     UserHandler handler = new UserHandler(userService);
     //设置路由
 	return RouterFunctions.route(GET(&quot;/users/{id}&quot;).and(accept(APPLICATION_JSON)),handler::getUserById).andRoute(GET(&quot;/users&quot;).and(accept(APPLICATION_JSON)),handler::get
AllUsers);
}
</code></pre>
</li>
<li>
<p>创建服务器完成适配</p>
</li>
</ul>
<pre><code>```java
//2 创建服务器完成适配
public void createReactorServer() {
     //路由和 handler 适配
     RouterFunction&lt;ServerResponse&gt; route = routingFunction();
     HttpHandler httpHandler = toHttpHandler(route);
     ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(httpHandler);
     //创建服务器
     HttpServer httpServer = HttpServer.create();
     httpServer.handle(adapter).bindNow();
}
```
</code></pre>
<ul>
<li>
<p>最终调用</p>
<pre><code class="language-java">public static void main(String[] args) throws Exception{
     Server server = new Server();
     server.createReactorServer();
     System.out.println(&quot;enter to exit&quot;);
     System.in.read();
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>使用 WebClient 调用</p>
<pre><code class="language-java">public class Client {
 	public static void main(String[] args) {
     //调用服务器地址
     WebClient webClient = WebClient.create(&quot;http://127.0.0.1:5794&quot;);
     //根据 id 查询
 	 String id = &quot;1&quot;;
 	 User userresult = webClient.get().uri(&quot;/users/{id}&quot;, id).accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(User.class).block();
 	System.out.println(userresult.getName());
        
 	//查询所有
 	Flux&lt;User&gt; results = webClient.get().uri(&quot;/users&quot;).accept(MediaType.APPLICATION_JSON).retrieve().bodyToFlux(User.class);
 	results.map(stu -&gt; stu.getName()).buffer().doOnNext(System.out::println).blockFirst();
 }
}
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="总结">总结</h2>
<ol>
<li>Spring框架概述
<ol>
<li>轻量级开源 JavaEE 框架，为了解决企业复杂性，两个核心组成：IOC 和 AOP</li>
<li>Spring5.2.6 版本</li>
</ol>
</li>
<li>、IOC 容器
<ol>
<li>IOC 底层原理（工厂、反射等）</li>
<li>IOC 接口（BeanFactory）</li>
<li>IOC 操作 Bean 管理（基于 xml）</li>
<li>IOC 操作 Bean 管理（基于注解）</li>
</ol>
</li>
<li>AOP
<ol>
<li>AOP 底层原理：动态代理，有接口（JDK 动态代理），没有接口（CGLIB 动态代理）</li>
<li>术语：切入点、增强（通知）、切面</li>
<li>基于 AspectJ 实现 AOP 操作</li>
</ol>
</li>
<li>JdbcTemplate
<ol>
<li>使用 JdbcTemplate 实现数据库 curd 操作</li>
<li>使用 JdbcTemplate 实现数据库批量操作</li>
</ol>
</li>
<li>事务管理
<ol>
<li>事务概念</li>
<li>重要概念（传播行为和隔离级别）</li>
<li>基于注解实现声明式事务管理</li>
<li>完全注解方式实现声明式事务管理</li>
</ol>
</li>
<li>Spring5 新功能
<ol>
<li>整合日志框架</li>
<li>@Nullable 注解</li>
<li>函数式注册对象</li>
<li>整合 JUnit5 单元测试框架</li>
<li>SpringWebflux 使用</li>
</ol>
</li>
</ol>

                </div>
                <div class="clear"></div>
              </section>
            </article>
            <div class="clear"></div>

            <section class="related section">
              
              <article class="prev grid-50 tablet-grid-50 grid-parent">
                <div class="thumb cover lazy loaded" style="background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/20221108_231914.jpg');"></div>
                 <a href="https://nanteng.github.io/post/thymeleaf/" class="full-link"></a>
                 <div class="info">
                  <time datetime="2022-11-10">2022-11-10</time>
                  <h4 class="title white no-margin">Thymeleaf</h4>
                </div>
                 <span class="epcl-button red">
                  <img src="https://nanteng.github.io/media/images/left-arrow.svg" width="15" alt="Left Arrow">
                </span>
                <div class="overlay"></div>
              </article>
              
              
              <article class="next grid-50 tablet-grid-50 grid-parent">
                <div class="thumb cover lazy loaded" style="background-image: url('https://oss.dearkai.cn/wapper/tumblr_c5d7ab53762fdb8bee37724229775658_b9b69268_2048.jpg');"></div>
                 <a href="https://nanteng.github.io/post/JDBCBasic-jdbcbasic/" class="full-link"></a>
                 <div class="info">
                  <time datetime="2022-10-30">2022-10-30</time>
                  <h4 class="title white no-margin">JDBCBasic</h4>
                </div>
                 <span class="epcl-button red">
                  <img src="https://nanteng.github.io/media/images/right-arrow.svg" width="15" alt="Left Arrow">
                </span>
                <div class="overlay"></div>
              </article>
              

                <div class="clear"></div>
            </section>

              <div class="clear"></div>
              
            
              <div id="comments" class="bg-white hosted ">
                <div class="clear"></div>
<script>
jQuery(document).ready(function($){
    $('.vemoji-btn').text('😀');
    $("#comments").on('click', 'span.vat',function(){
        $(this).parent('div.vmeta').next("div.vcontent").after($("div.vwrap"));
        $('textarea#veditor').focus();
    })
    if(window.location.hash){
        var checkExist = setInterval(function() {
            if ($(window.location.hash).length) {
                $('html, body').animate({scrollTop: $(window.location.hash).offset().top-200}, 600);
                clearInterval(checkExist);
            }
        }, 100);
    }
})
</script>

              </div>
            

            </div>
          </div>
      </main>

          <footer id="footer" class="grid-container">
        <div class="widgets row gradient-effect">
            <div class="default-sidebar border-effect">
              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="tag_cloud-2" class="widget widget_epcl_posts_thumbs underline-effect">
                  <h4 class="widget-title title white bordered">最新文章</h4>
                  
                  
                  <article class="item post-0 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://nanteng.github.io/post/mavenbasics/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/tumblr_b38009612775acb3f606c15e4ca4cfb0_9b8bb164_1280.png');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2022-11-16">2022-11-16</time>
                      <h4 class="title usmall">
                        <a href="https://nanteng.github.io/post/mavenbasics/">MavenBasics</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  <article class="item post-1 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://nanteng.github.io/post/ssm-zheng-he/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/お豆腐_99167071.jpg');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2022-11-15">2022-11-15</time>
                      <h4 class="title usmall">
                        <a href="https://nanteng.github.io/post/ssm-zheng-he/">SSM整合</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  <article class="item post-2 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://nanteng.github.io/post/springmvc/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/20221112_004658.jpg');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2022-11-15">2022-11-15</time>
                      <h4 class="title usmall">
                        <a href="https://nanteng.github.io/post/springmvc/">SpringMVC</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  <div class="clear"></div>
                </section>
              </div>

              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="tag_cloud-2" class="widget widget_tag_cloud underline-effect">
                  <h4 class="widget-title title white bordered">标签云</h4>
                  <div class="tagcloud">
                    
                      <a href="https://nanteng.github.io/tag/TtKdK6ur-/" class="ctag ctag-0 ctag-TtKdK6ur-" aria-label="">Java</a>
                    
                      <a href="https://nanteng.github.io/tag/Pb31zuZQs/" class="ctag ctag-1 ctag-Pb31zuZQs" aria-label="">诗歌</a>
                    
                      <a href="https://nanteng.github.io/tag/wFMTkH_sNe/" class="ctag ctag-2 ctag-wFMTkH_sNe" aria-label="">日记</a>
                    
                      <a href="https://nanteng.github.io/tag/q1drPjJv3/" class="ctag ctag-3 ctag-q1drPjJv3" aria-label="">随笔</a>
                    
                      <a href="https://nanteng.github.io/tag/eSKuLZlYEN/" class="ctag ctag-4 ctag-eSKuLZlYEN" aria-label="">Linux</a>
                    
                      <a href="https://nanteng.github.io/tag/i9Zqgezw0Q/" class="ctag ctag-5 ctag-i9Zqgezw0Q" aria-label="">体验</a>
                    
                      <a href="https://nanteng.github.io/tag/VxnVWpClHS/" class="ctag ctag-6 ctag-VxnVWpClHS" aria-label="">软件</a>
                    
                      <a href="https://nanteng.github.io/tag/1DZ-nCoLTA/" class="ctag ctag-7 ctag-1DZ-nCoLTA" aria-label="">信件</a>
                    
                      <a href="https://nanteng.github.io/tag/Fcf3eo9iSf/" class="ctag ctag-8 ctag-Fcf3eo9iSf" aria-label="">CentOS</a>
                    
                  </div>
                  <div class="clear"></div>
                </section>
              </div>

              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="epcl_about-2" class="widget widget_epcl_about underline-effect">
                  <h4 class="widget-title title white bordered">关于我</h4>
                  <div class="avatar">
                    <a href="" class="translate-effect thumb"><span class="fullimage cover" style="background-image: url(https://nanteng.github.io/images/avatar.png);"></span></a>
                  </div>
                  <div class="info">
                    <h4 class="title small author-name gradient-effect no-margin"><a href="">南藤北玄参</a></h4>
                    <p class="founder">唯沉默为最高的轻蔑</p>
                    <div class="social">
                      
                          
                            <a href="https://github.com/NanTeng" class="translate-effect" target="_blank"><i class="fa fa-github"></i></a>
                        
                      
                          
                            <a href="https://twitter.com/NanTeng418" class="translate-effect" target="_blank"><i class="fa fa-twitter"></i></a>
                        
                      
                        
                      
                          
                            <a href="https://t.me/NanTeng" class="translate-effect" target="_blank"><i class="fa fa-telegram"></i></a>
                        
                      
                        
                      
                    </div> 
                  </div>
                  <div class="clear"></div>
                  </section>
              </div>

            </div>
            <div class="clear"></div>
        </div>

        <div class="logo">
          <a href="https://nanteng.github.io"><img src="\media\images\custom-footerLogo.gif" alt=""></a>
        </div>
        <p class="published border-effect">
          ©2019 共 28 篇文章
          <br/>
          Theme <a href="https://gridea.dev/" target="_blank">「breek」</a> Powered by <a href="https://gridea.dev/" target="_blank">「Gridea」</a>
        </p>
        
        <a href="javascript:void(0)" id="back-to-top" class="epcl-button dark" style="display:none">
          <i class="fa fa-arrow"></i>
        </a>
    </footer>
    
    <div class="clear"></div>

        
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/valine/1.3.10/Valine.Pure.min.js"></script>
<script>
    new Valine({
        el: '#comments',
        appId: 'JCYzcWAfC7BkMZHJ3hrKx85t-gzGzoHsz' ,
        appKey: 'r89Wpg7b2oYFtiu1JGnthBzN',
        pageSize: 30,
        placeholder: '既然来了，那就留个痕迹吧~',
        visitor: true // 阅读量统计
    })
</script>
    

      
    <script src="https://nanteng.github.io/media/js/functions-post.js"></script>

    </div>
    <!-- end: #wrapper -->
  </body>
</html>
