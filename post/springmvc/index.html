<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SpringMVC | 南藤北玄参</title>
<meta name="description" content="唯沉默为最高的轻蔑" />
<link rel="shortcut icon" href="https://nanteng.github.io/favicon.ico">
<link rel="stylesheet" href="https://nanteng.github.io/styles/main.css">

<script src="https://nanteng.github.io/media/js/jquery.min.js"></script>
<script src="https://nanteng.github.io/media/js/masonry.pkgd.min.js"></script>
<script src="https://nanteng.github.io/media/js/aos.js"></script>
<script src="https://nanteng.github.io/media/js/pace.min.js"></script>
<script src="https://nanteng.github.io/media/js/view-image.min.js"></script>
<script src="https://nanteng.github.io/media/js/jquery.magnific-popup.min.js"></script>
<script src="https://nanteng.github.io/media/js/functions.js"></script>
    <meta name="referrer" content="never">
    <meta name="description" content="springMVC简介
什么是MVC
MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分
M：Model，模型层，指工程中的JavaBean，作用是处理数据
JavaBean分为两类：

实体类Bean：专门存储业务数据的，如 ..." />
    <meta name="keywords" content="Java" />
    <script src="https://nanteng.github.io/media/js/waterfall.min.js"></script>
    <script src="https://nanteng.github.io/media/js/prism.min.js"></script>
  </head>
  <body>
            <header id="header" class="grid-container">
        <!-- start: .menu-wrapper -->
        <div class="menu-mobile"> 
          <i class="fa fa-reorder"></i>
        </div>
        <div class="menu-wrapper">
          <div class="">
            <div class="logo">
              <a href="https://nanteng.github.io"><img src="\media\images\custom-headerLogo.gif" alt=""></a>
            </div>
            <!-- start: .main-nav -->

            <nav class="main-nav grid-container grid-parent">
              <ul id="menu-header" class="menu gradient-effect">
                <li class=""><a href="https://nanteng.github.io" class="menu">首页</a></li>
                
                  <li class="" >
                    <a href="/archives" class="menu">
                      归档
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="/tags" class="menu">
                      标签
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="https://cloud.dearkai.cn" class="menu">
                      云盘
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="/post/about" class="menu">
                      关于
                    </a>
                  </li>
                
                <li class="search-menu-item hide-on-mobile hide-on-tablet"><a href="#search-lightbox" class="lightbox mfp-inline"><i class="fa fa-search-line"></i></a></li>
              </ul>
            </nav>
            <a href="#search-lightbox" class="lightbox epcl-search-button mfp-inline hide-on-tablet hide-on-desktop"><i class="fa fa-search-line"></i></a>
            <!-- end: .main-nav -->
            <div class="clear"></div>
            <div class="border hide-on-tablet hide-on-mobile"></div>
          </div>    
          <div class="clear"></div>
        </div>
        <!-- end: .menu-wrapper -->
        <div class="clear"></div>
      </header>
      <div class="hide-on-mobile hide-on-tablet hide-on-desktop">
        <div id="search-lightbox" class="grid-container grid-small grid-parent mfp-hide">
          <div class="search-wrapper section">
            <form id="gridea-search-form" data-update="1668567925322" action="/search/index.html" class="search-form" _lpchecked="1">
              <input type="text" name="q" id="s" value="" class="search-field" placeholder="搜点啥..." aria-label="搜点啥..." required="">
              <button type="submit" class="submit" aria-label="Submit">
                <i class="fa fa-search-line"></i>
              </button>
            </form>
          </div>
        </div>
      </div>

      <main id="single" class="main grid-container fullcover no-sidebar aos-init aos-animate" data-aos="fade">

        <div class="center content">
          <div class="featured-image cover" style="background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/20221112_004658.jpg');">
            <div class="meta top"> 
              <time class="meta-info" style="float:left;" datetime="2022-11-15"><i class="fa fa-calendar"></i><span class="lately">12 小时前</span></time>
              
              <a href="https://nanteng.github.io/post/springmvc/#comments" class="comments meta-info" title="">
                <i class="fa fa-comment remixicon"></i><span class="comment-count valine-comment-count" data-xid="/springmvc/"> </span>
              </a>
              <span id="/springmvc/" class="leancloud_visitors views-counter meta-info" title=""><i class="fa fa-leancloud remixicon"></i><span class="leancloud-visitors-count"></span></span>
              
            </div>
            <div class="info">
              <div class="tags ">
                
                      <a href="https://nanteng.github.io/tag/TtKdK6ur-/" class="ctag ctag-0 ctag-TtKdK6ur-" aria-label="">Java</a>
                    
              </div>
              <h1 class="title ularge white bold">SpringMVC</h1>
            </div>
          </div>
        </div>  

        <div class="epcl-page-wrapper">
          <div class="left-content grid-70 np-mobile">
            <article class="main-article post">
              <section class="post-content">
                <div class="text">
                  <h2 id="springmvc简介">springMVC简介</h2>
<h3 id="什么是mvc">什么是MVC</h3>
<p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p>
<p><strong>M</strong>：Model，模型层，指工程中的JavaBean，作用是处理数据</p>
<p>JavaBean分为两类：</p>
<ul>
<li>实体类Bean：专门存储业务数据的，如 Student、User 等</li>
<li>为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</li>
</ul>
<p><strong>V</strong>：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</p>
<p><strong>C</strong>：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</p>
<p>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller 调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果 找到相应的View视图，渲染数据后最终响应给浏览器</p>
<h3 id="什么是springmvc">什么是SpringMVC</h3>
<p>SpringMVC是Spring的一个后续产品，是Spring的一个子项目</p>
<p>SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、 WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目 表述层开发的首选方案。</p>
<blockquote>
<p>注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台 servlet</p>
</blockquote>
<h3 id="springmvc的特点">SpringMVC的特点</h3>
<ul>
<li>Spring 家族原生产品，与 IOC 容器等基础设施无缝对接</li>
<li>基于原生的Servlet，通过了功能强大的前端控制器<code>DispatcherServlet</code>，对请求和响应进行统一处理</li>
<li>表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案</li>
<li>代码清新简洁，大幅度提升开发效率</li>
<li>内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可</li>
<li>性能卓著，尤其适合现代大型、超大型互联网项目要求</li>
</ul>
<h2 id="helloworld">HelloWorld</h2>
<h3 id="创建maven工程">创建maven工程</h3>
<p>1，添加web模块</p>
<p>2，打包方式：war</p>
<p>3，引入依赖</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;!-- SpringMVC --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.3.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- 日志 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
        &lt;/dependency&gt;
        
        &lt;!-- ServletAPI --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- Spring5和Thymeleaf整合包 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt;
            &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;
            &lt;version&gt;3.0.12.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。</p>
<figure data-type="image" tabindex="1"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img001.png" alt="img001" loading="lazy"></figure>
<h3 id="配置webxml">配置web.xml</h3>
<p>注册SpringMVC的前端控制器DispatcherServlet</p>
<h4 id="默认配置方式">默认配置方式</h4>
<p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt; servlet-name &gt; - servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVCservlet.xml</p>
<p><strong>默认配置方式</strong></p>
<pre><code class="language-xml">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servletclass&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
    &lt;!--
        设置springMVC的核心控制器所能处理的请求的请求路径
        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
        但是/不能匹配.jsp请求路径的请求
		/* 处理包括.jsp的请求路径
    --&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;


</code></pre>
<h4 id="扩展配置方式">扩展配置方式</h4>
<p>可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置 SpringMVC前端控制器DispatcherServlet的初始化时间</p>
<pre><code class="language-xml">    &lt;!-- 配置异常处理 --&gt;
    &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
            &lt;property name=&quot;exceptionMappings&quot;&gt;
                &lt;props&gt;
                    &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt;
                &lt;/props&gt;
            &lt;/property&gt;
            &amp;lt;!&amp;ndash; 将异常信息共享在请求域中的键 &amp;ndash;&amp;gt;
            &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;
            &lt;/property&gt;
        &lt;/bean&gt;--&gt;
    &lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servletclass&gt;
            &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;
    &lt;init-param&gt;
        &lt;!-- contextConfigLocation为固定值 --&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的
        src/main/resources --&gt;
        &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--
    作为框架的核心组件，在启动过程中有大量的初始化操作要做
    而这些操作放在第一次请求时才执行会严重影响访问速度
    因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时
    --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;springMVC&lt;/servlet-name&gt;
&lt;!--
设置springMVC的核心控制器所能处理的请求的请求路径
/所匹配的请求可以是/login或.html或.js或.css方式的请求路径
但是/不能匹配.jsp请求路径的请求
--&gt;
	&lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<blockquote>
<h4 id="注">注</h4>
<p>标签中使用<code>/</code>和<code>/*</code>的区别:</p>
<p><code>/</code>所匹配的请求可以是<code>/login</code>或<code>.html</code>或<code>.js</code>或<code>.css</code>方式的请求路径，但是<code>/</code>不能匹配<code>.jsp</code>请求路径的请 求</p>
<p>因此就可以避免在访问<code>jsp</code>页面时，该请求被<code>DispatcherServlet</code>处理，从而找不到相应的页面</p>
<p><code>/*</code>则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用<code>/*</code>的写 法</p>
</blockquote>
<h3 id="创建请求控制器">创建请求控制器</h3>
<p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要 创建处理具体请求的类，即请求控制器</p>
<p>请求控制器中每一个处理请求的方法成为控制器方法</p>
<p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识 为一个控制层组件，交给Spring的IOC容器管理，此时SpringMVC才能够识别控制器的存在</p>
<pre><code class="language-java">@Controller
public class HelloController {

}
</code></pre>
<h3 id="创建springmvc的配置文件">创建springMVC的配置文件</h3>
<pre><code class="language-xml">    &lt;!-- 自动扫描包 --&gt;
    &lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;/&gt;
    &lt;!-- 配置Thymeleaf视图解析器 --&gt;
    &lt;bean id=&quot;viewResolver&quot;
          class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt;
        &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;
        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt;
        &lt;property name=&quot;templateEngine&quot;&gt;
            &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt;
                &lt;property name=&quot;templateResolver&quot;&gt;
                    &lt;bean
                            class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt;
                        &lt;!-- 视图前缀 --&gt;
                        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt;
                        &lt;!-- 视图后缀 --&gt;
                        &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt;
                        &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt;
                        &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;!--
    处理静态资源，例如html、js、css、jpg
    若只设置该标签，则只能访问静态资源，其他请求则无法访问
    此时必须设置&lt;mvc:annotation-driven/&gt;解决问题
    --&gt;
    &lt;mvc:default-servlet-handler/&gt;
    &lt;!-- 开启mvc注解驱动 --&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;mvc:message-converters&gt;
            &lt;!-- 处理响应中文内容乱码 --&gt;
            &lt;bean
                    class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;value&gt;text/html&lt;/value&gt;
                        &lt;value&gt;application/json&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;
	
</code></pre>
<h3 id="测试helloworld">测试HelloWorld</h3>
<h4 id="实现对首页的访问">实现对首页的访问</h4>
<p>在请求控制器中创建处理请求的方法</p>
<pre><code class="language-java">    // @RequestMapping注解：处理请求和控制器方法之间的映射关系
    // @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径
    // localhost:8080/springMVC/
    @RequestMapping(&quot;/&quot;)
    public String index() {
    //设置视图名称
        return &quot;index&quot;;
    }
</code></pre>
<h4 id="通过超链接跳转到指定页面">通过超链接跳转到指定页面</h4>
<p>在主页index.html中设置超链接</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;首页&lt;/h1&gt;
    &lt;a th:href=&quot;@{/hello}&quot;&gt;HelloWorld&lt;/a&gt;&lt;br/&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在请求控制器中创建处理请求的方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String HelloWorld() {
	return &quot;target&quot;;
}
</code></pre>
<h3 id="总结">总结</h3>
<p>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器 DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器， 将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的 控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会 被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</p>
<h2 id="requestmapping注解">@RequestMapping注解</h2>
<h3 id="requestmapping注解的功能">@RequestMapping注解的功能</h3>
<p>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联 起来，建立映射关系。</p>
<p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</p>
<h3 id="requestmapping注解的位置">@RequestMapping注解的位置</h3>
<p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p>
<p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p>
<pre><code class="language-java">    @Controller
    @RequestMapping(&quot;/test&quot;)
    public class RequestMappingController {
        //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping
        @RequestMapping(&quot;/testRequestMapping&quot;)
        public String testRequestMapping(){
            return &quot;success&quot;;
        }
    }
</code></pre>
<h3 id="requestmapping注解的value属性">@RequestMapping注解的value属性</h3>
<p>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射</p>
<p>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求</p>
<p>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</p>
<pre><code class="language-html">&lt;a th:href=&quot;@{/testRequestMapping}&quot;&gt;测试@RequestMapping的value属性--
&gt;/testRequestMapping&lt;/a&gt;&lt;br&gt;
&lt;a th:href=&quot;@{/test}&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt;
</code></pre>
<pre><code class="language-java">    @RequestMapping(
            value = {&quot;/testRequestMapping&quot;, &quot;/test&quot;}
    )
    public String testRequestMapping(){
        return &quot;success&quot;;
    }
</code></pre>
<h3 id="requestmapping注解的method属性">@RequestMapping注解的method属性</h3>
<p>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射</p>
<p>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配 多种请求方式的请求</p>
<p>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错 405：Request method 'POST' not supported</p>
<pre><code class="language-html">&lt;a th:href=&quot;@{/test}&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt;
&lt;form th:action=&quot;@{/test}&quot; method=&quot;post&quot;&gt;
	&lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="language-java">@RequestMapping(
value = {&quot;/testRequestMapping&quot;, &quot;/test&quot;},
	method = {RequestMethod.GET, RequestMethod.POST}
)
public String testRequestMapping(){
	return &quot;success&quot;;
}
</code></pre>
<blockquote>
<h5 id="注-2">注</h5>
<p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p>
<p>处理get请求的映射--&gt;@GetMapping</p>
<p>处理post请求的映射--&gt;@PostMapping</p>
<p>处理put请求的映射--&gt;@PutMapping</p>
<p>处理delete请求的映射--&gt;@DeleteMapping</p>
<p>2、常用的请求方式有get，post，put，delete</p>
<p>但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符 串（put或delete），则按照默认的请求方式get处理</p>
<p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter</p>
</blockquote>
<h3 id="requestmapping注解的params属性">@RequestMapping注解的params属性</h3>
<p>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射</p>
<p>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系</p>
<p>&quot;param&quot;：要求请求映射所匹配的请求必须携带param请求参数</p>
<p>&quot;!param&quot;：要求请求映射所匹配的请求必须不能携带param请求参数</p>
<p>&quot;param=value&quot;：要求请求映射所匹配的请求必须携带param请求参数且param=value</p>
<p>&quot;param!=value&quot;：要求请求映射所匹配的请求必须携带param请求参数但是param!=value</p>
<pre><code class="language-html">&lt;a th:href=&quot;@{/test(username='admin',password=123456)&quot;&gt;测试@RequestMapping的params属性--&gt;/test&lt;/a&gt;&lt;br&gt;
</code></pre>
<pre><code class="language-java">    @RequestMapping(
            value = {&quot;/testRequestMapping&quot;, &quot;/test&quot;}
            ,method = {RequestMethod.GET, RequestMethod.POST}
            ,params = {&quot;username&quot;,&quot;password!=123456&quot;}
    )
    public String testRequestMapping(){
        return &quot;success&quot;;
    }
</code></pre>
<blockquote>
<h3 id="注-3">注：</h3>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面会报错400：Parameter conditions &quot;username, password!=123456&quot; not met for actual request parameters: username={admin}, password={123456}</p>
</blockquote>
<h3 id="requestmapping注解的headers属性">@RequestMapping注解的headers属性</h3>
<p>@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射</p>
<p>@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信 息和请求映射的匹配关系</p>
<p>&quot;header&quot;：要求请求映射所匹配的请求必须携带header请求头信息</p>
<p>&quot;!header&quot;：要求请求映射所匹配的请求必须不能携带header请求头信息</p>
<p>&quot;header=value&quot;：要求请求映射所匹配的请求必须携带header请求头信息且header=value</p>
<p>&quot;header!=value&quot;：要求请求映射所匹配的请求必须携带header请求头信息且header!=value</p>
<p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面 显示404错误，即资源未找到</p>
<h3 id="springmvc支持ant风格的路径">SpringMVC支持ant风格的路径</h3>
<p>？：表示任意的单个字符</p>
<p>*：表示任意的0个或多个字符</p>
<p>**：表示任意的一层或多层目录</p>
<p>注意：在使用<code>**</code>时，只能使用<code>/**/xxx</code>的方式</p>
<h3 id="springmvc支持路径中的占位符">SpringMVC支持路径中的占位符</h3>
<p>原始方式：<code>/deleteUser?id=1</code></p>
<p>rest方式：<code>/deleteUser/1</code></p>
<p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服 务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在 通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</p>
<pre><code class="language-html">&lt;a th:href=&quot;@{/testRest/1/admin}&quot;&gt;测试路径中的占位符--&gt;/testRest&lt;/a&gt;&lt;br&gt;
</code></pre>
<pre><code class="language-java">@RequestMapping(&quot;/testRest/{id}/{username}&quot;)
public String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;)
String username){
    System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username);
    return &quot;success&quot;;
}
//最终输出的内容为--&gt;id:1,username:admin
</code></pre>
<h2 id="springmvc获取请求参数">SpringMVC获取请求参数</h2>
<h3 id="通过servletapi获取">通过ServletAPI获取</h3>
<p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象</p>
<pre><code class="language-java">@RequestMapping(&quot;/testParam&quot;)
public String testParam(HttpServletRequest request){
    String username = request.getParameter(&quot;username&quot;);
    String password = request.getParameter(&quot;password&quot;);
    System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password);
    return &quot;success&quot;;
}
</code></pre>
<h3 id="通过控制器方法的形参获取请求参数">通过控制器方法的形参获取请求参数</h3>
<p>在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在 DispatcherServlet中就会将请求参数赋值给相应的形参</p>
<pre><code class="language-html">&lt;a th:href=&quot;@{/testParam(username='admin',password=123456)}&quot;&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt;
</code></pre>
<pre><code class="language-java">@RequestMapping(&quot;/testParam&quot;)
public String testParam(String username, String password){
    System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password);
    return &quot;success&quot;;
}
</code></pre>
<blockquote>
<h4 id="注-4">注：</h4>
<p>若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串 数组或者字符串类型的形参接收此请求参数</p>
<p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p>
<p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p>
</blockquote>
<h3 id="requestparam">@RequestParam</h3>
<p>@RequestParam是将请求参数和控制器方法的形参创建映射关系</p>
<p>@RequestParam注解一共有三个属性：</p>
<p>value：指定为形参赋值的请求参数的参数名</p>
<p>required：设置是否必须传输此请求参数，默认值为true</p>
<p>若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置 defaultValue属性，则页面报错400：Required String parameter 'xxx' is not present；若设置为 false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为 null</p>
<p>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值 为&quot;&quot;时，则使用默认值为形参赋值</p>
<h3 id="requestheader">@RequestHeader</h3>
<p>@RequestHeader是将请求头信息和控制器方法的形参创建映射关系</p>
<p>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p>
<h3 id="cookievalue">@CookieValue</h3>
<p>@CookieValue是将cookie数据和控制器方法的形参创建映射关系</p>
<p>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</p>
<h3 id="通过pojo获取请求参数">通过POJO获取请求参数</h3>
<p>可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值</p>
<pre><code class="language-html">&lt;form th:action=&quot;@{/testpojo}&quot; method=&quot;post&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;
    性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot;
    name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt;
    年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt;
    邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="language-java">@RequestMapping(&quot;/testpojo&quot;)
public String testPOJO(User user){
    System.out.println(user);
    return &quot;success&quot;;
}
//最终结果--&gt;User{id=null, username='张三', password='123', age=23, sex='男',email='123@qq.com'}
</code></pre>
<h3 id="解决获取请求参数的乱码问题">解决获取请求参数的乱码问题</h3>
<p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是 必须在web.xml中进行注册</p>
<pre><code class="language-xml">&lt;!--配置springMVC的编码过滤器--&gt;
&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<h5 id="注-5">注：</h5>
<p>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效</p>
</blockquote>
<h2 id="域对象共享数据">域对象共享数据</h2>
<h3 id="使用servletapi向request域对象共享数据">使用ServletAPI向request域对象共享数据</h3>
<pre><code class="language-java">@RequestMapping(&quot;/testServletAPI&quot;)
public String testServletAPI(HttpServletRequest request){
    request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;);
    return &quot;success&quot;;
}
</code></pre>
<h3 id="使用modelandview向request域对象共享数据">使用ModelAndView向request域对象共享数据</h3>
<pre><code class="language-java">  @RequestMapping(&quot;/testModelAndView&quot;)
  public ModelAndView testModelAndView(){
   /**
   * ModelAndView有Model和View的功能
   * Model主要用于向请求域共享数据
   * View主要用于设置视图，实现页面跳转
   */
   ModelAndView mav = new ModelAndView();
   //向请求域共享数据
   mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;);
   //设置视图，实现页面跳转
   mav.setViewName(&quot;success&quot;);
   return mav;
}
</code></pre>
<h3 id="使用model向request域对象共享数据">使用Model向request域对象共享数据</h3>
<pre><code class="language-java">@RequestMapping(&quot;/testModel&quot;)
public String testModel(Model model){
    model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;);
    return &quot;success&quot;;
}
</code></pre>
<h3 id="使用map向request域对象共享数据">使用map向request域对象共享数据</h3>
<pre><code class="language-java">@RequestMapping(&quot;/testMap&quot;)
public String testMap(Map&lt;String, Object&gt; map){
    map.put(&quot;testScope&quot;, &quot;hello,Map&quot;);
    return &quot;success&quot;;
}
</code></pre>
<h3 id="使用modelmap向request域对象共享数据">使用ModelMap向request域对象共享数据</h3>
<pre><code class="language-java">@RequestMapping(&quot;/testModelMap&quot;)
public String testModelMap(ModelMap modelMap){
    modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;);
    return &quot;success&quot;;
}
</code></pre>
<h3 id="model-modelmap-map的关系">Model、ModelMap、Map的关系</h3>
<p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的</p>
<pre><code class="language-java">public interface Model{}
public class ModelMap extends LinkedHashMap&lt;String, Object&gt; {}
public class ExtendedModelMap extends ModelMap implements Model {}
public class BindingAwareModelMap extends ExtendedModelMap {}
</code></pre>
<h3 id="向session域共享数据">向session域共享数据</h3>
<pre><code class="language-java">@RequestMapping(&quot;/testSession&quot;)
public String testSession(HttpSession session){
    session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;);
    return &quot;success&quot;;
}
</code></pre>
<h3 id="向application域共享数据">向application域共享数据</h3>
<pre><code class="language-java">@RequestMapping(&quot;/testApplication&quot;)
public String testApplication(HttpSession session){
    ServletContext application = session.getServletContext();
    application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;);
    return &quot;success&quot;;
}
</code></pre>
<h2 id="springmvc的视图">SpringMVC的视图</h2>
<p>SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</p>
<p>SpringMVC视图的种类很多，默认有转发视图和重定向视图</p>
<p>当工程引入jstl的依赖，转发视图会自动转换为JstlView</p>
<p>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视 图解析器解析之后所得到的是ThymeleafView</p>
<h3 id="thymeleafview">ThymeleafView</h3>
<p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置 的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转</p>
<pre><code class="language-java">@RequestMapping(&quot;/testHello&quot;)
public String testHello(){
    return &quot;hello&quot;;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img002.png" alt="img002" loading="lazy"></figure>
<h3 id="转发视图">转发视图</h3>
<p>SpringMVC中默认的转发视图是InternalResourceView</p>
<p>SpringMVC中创建转发视图的情况：</p>
<p>当控制器方法中所设置的视图名称以&quot;forward:&quot;为前缀时，创建InternalResourceView视图，此时的视 图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀&quot;forward:&quot;去掉，剩余部 分作为最终路径通过转发的方式实现跳转</p>
<p>例如&quot;forward:/&quot;，&quot;forward:/employee&quot;</p>
<pre><code class="language-java">@RequestMapping(&quot;/testForward&quot;)
public String testForward(){
    return &quot;forward:/testHello&quot;;
}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img003.png" alt="img003" loading="lazy"></figure>
<h3 id="重定向视图">重定向视图</h3>
<p>SpringMVC中默认的重定向视图是RedirectView</p>
<p>当控制器方法中所设置的视图名称以&quot;redirect:&quot;为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀&quot;redirect:&quot;去掉，剩余部分作为最终路径通过重定向的方式实现跳转</p>
<p>例如&quot;redirect:/&quot;，&quot;redirect:/employee&quot;</p>
<pre><code class="language-java">@RequestMapping(&quot;/testRedirect&quot;)
public String testRedirect(){
    return &quot;redirect:/testHello&quot;;
}
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img004.png" alt="img004" loading="lazy"></figure>
<blockquote>
<p>注：</p>
<p>重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径</p>
</blockquote>
<h3 id="视图控制器view-controller">视图控制器view-controller</h3>
<p>当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用viewcontroller标签进行表示</p>
<pre><code class="language-xml">&lt;!--
    path：设置处理的请求地址
    view-name：设置请求地址所对应的视图名称
--&gt;
&lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt;
</code></pre>
<blockquote>
<p>注:</p>
<p>当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需 要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：</p>
<p><code>&lt;mvc:annotation-driven /&gt;</code></p>
</blockquote>
<h2 id="restful">RESTful</h2>
<h3 id="restful简介">RESTful简介</h3>
<p>REST：Representational State Transfer，表现层资源状态转移。</p>
<h4 id="资源">资源</h4>
<p>资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个 可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、 数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端 应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个 资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴 趣的客户端应用，可以通过资源的URI与其进行交互。</p>
<h4 id="资源的表述">资源的表述</h4>
<p>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交 换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格 式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</p>
<h4 id="状态转移">状态转移</h4>
<p>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资 源的表述，来间接实现操作资源的目的。</p>
<h3 id="restful的实现">RESTful的实现</h3>
<p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p>
<p>它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。</p>
<p>REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方 式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统方式</th>
<th>REST风格</th>
</tr>
</thead>
<tbody>
<tr>
<td>查询操作</td>
<td>getUserById?id=1</td>
<td>user/1--&gt;get请求方式</td>
</tr>
<tr>
<td>保存操作</td>
<td>saveUser</td>
<td>user--&gt;post请求方式</td>
</tr>
<tr>
<td>删除操作</td>
<td>deleteUser?id=1</td>
<td>user/1--&gt;delete请求方式</td>
</tr>
<tr>
<td>更新操作</td>
<td>updateUser</td>
<td>user--&gt;put请求方式</td>
</tr>
</tbody>
</table>
<h3 id="hiddenhttpmethodfilter">HiddenHttpMethodFilter</h3>
<p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p>
<p>SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求</p>
<p>HiddenHttpMethodFilter 处理put和delete请求的条件：</p>
<ol>
<li>当前请求的请求方式必须为post</li>
<li>当前请求必须传输请求参数_method</li>
</ol>
<p>满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数 <code>_method</code>的值，因此请求参数<code>_method</code>的值才是最终的请求方式</p>
<p>在web.xml中注册HiddenHttpMethodFilter</p>
<pre><code class="language-xml">&lt;filter&gt;
	&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
&lt;filterclass&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
	&lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<blockquote>
<p>注：</p>
<p>目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和 HiddenHttpMethodFilter</p>
<p>在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p>
<p>原因：</p>
<ul>
<li>
<p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字 符集的</p>
</li>
<li>
<p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p>
</li>
<li>
<p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：</p>
</li>
<li>
<pre><code class="language-java">String paramValue = request.getParameter(this.methodParam);
</code></pre>
</li>
</ul>
</blockquote>
<h2 id="httpmessageconverter">HttpMessageConverter</h2>
<p>HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文</p>
<p>HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，ResponseEntity</p>
<h3 id="requestbody">@RequestBody</h3>
<p>@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值</p>
<pre><code class="language-html">&lt;form th:action=&quot;@{/testRequestBody}&quot; method=&quot;post&quot;&gt;
    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;
    密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;
    &lt;input type=&quot;submit&quot;&gt;
&lt;/form&gt;
</code></pre>
<pre><code class="language-java">@RequestMapping(&quot;/testRequestBody&quot;)
public String testRequestBody(@RequestBody String requestBody){
    System.out.println(&quot;requestBody:&quot;+requestBody);
    return &quot;success&quot;;
}
</code></pre>
<p>输出结果：</p>
<p>requestBody:username=admin&amp;password=123456</p>
<h3 id="requestentity">RequestEntity</h3>
<p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的 请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p>
<pre><code class="language-java">@RequestMapping(&quot;/testRequestEntity&quot;)
public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity){
    System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders());
    System.out.println(&quot;requestBody:&quot;+requestEntity.getBody());
    return &quot;success&quot;;
}
</code></pre>
<h3 id="responsebody">@ResponseBody</h3>
<p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器</p>
<pre><code class="language-java">@RequestMapping(&quot;/testResponseBody&quot;)
@ResponseBody
    public String testResponseBody(){
    return &quot;success&quot;;
}
</code></pre>
<p>结果：浏览器页面显示success</p>
<h3 id="springmvc处理json">SpringMVC处理json</h3>
<p>@ResponseBody处理json的步骤：</p>
<ol>
<li>导入jackson的依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.12.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消 息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格 式的字符串</li>
</ol>
<pre><code class="language-xml">&lt;mvc:annotation-driven /&gt;
</code></pre>
<ol start="3">
<li>
<p>在处理器方法上使用@ResponseBody注解进行标识</p>
</li>
<li>
<p>将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</p>
</li>
</ol>
<pre><code class="language-java">@RequestMapping(&quot;/testResponseUser&quot;)
@ResponseBody
public User testResponseUser(){
    return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;);
}
</code></pre>
<p>浏览器的页面中展示的结果：</p>
<p>{&quot;id&quot;:1001,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;}</p>
<h3 id="springmvc处理ajax">SpringMVC处理ajax</h3>
<ol>
<li>请求超链接：</li>
</ol>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
&lt;a th:href=&quot;@{/testAjax}&quot; @click=&quot;testAjax&quot;&gt;testAjax&lt;/a&gt;&lt;br&gt;
&lt;/div&gt;
</code></pre>
<ol start="2">
<li>通过vue和axios处理点击事件：</li>
</ol>
<pre><code class="language-html">&lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/static/js/vue.js}&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/static/js/axios.min.js}&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vue = new Vue({
        el:&quot;#app&quot;,
            methods:{
                testAjax:function (event) {
                    axios({
                      method:&quot;post&quot;,
                      url:event.target.href,
                      params:{
                        username:&quot;admin&quot;,
                        password:&quot;123456&quot;
                        }
                    }).then(function (response) {
                        alert(response.data);
                    });
                event.preventDefault();
            }
        }
    });
&lt;/script&gt;
</code></pre>
<ol start="3">
<li>&gt;控制器方法：</li>
</ol>
<pre><code class="language-java">@RequestMapping(&quot;/testAjax&quot;)
@ResponseBody
public String testAjax(String username, String password){
    System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password);
    return &quot;hello,ajax&quot;;
}
</code></pre>
<h3 id="restcontroller注解">@RestController注解</h3>
<p>@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了 @Controller注解，并且为其中的每个方法添加了@ResponseBody注解</p>
<h3 id="responseentity">ResponseEntity</h3>
<p>ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文</p>
<h2 id="文件上传和下载">文件上传和下载</h2>
<h3 id="文件下载">文件下载</h3>
<p>使用ResponseEntity实现下载文件的功能</p>
<pre><code class="language-java">    @RequestMapping(&quot;/testDown&quot;)
    public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException {
        //获取ServletContext对象
        ServletContext servletContext = session.getServletContext();
        //获取服务器中文件的真实路径
        String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;);
        //创建输入流
        InputStream is = new FileInputStream(realPath);
        //创建字节数组
        byte[] bytes = new byte[is.available()];
        //将流读到字节数组中
        is.read(bytes);
        //创建HttpHeaders对象设置响应头信息
        MultiValueMap&lt;String, String&gt; headers = new HttpHeaders();
        //设置要下载方式以及下载文件的名字
        headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;);
        //设置响应状态码
        HttpStatus statusCode = HttpStatus.OK;
        //创建ResponseEntity对象
        ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers,
                statusCode);
        //关闭输入流
        is.close();
        return responseEntity;
    }
</code></pre>
<h3 id="文件上传">文件上传</h3>
<p>文件上传要求form表单的请求方式必须为post，并且添加属性enctype=&quot;multipart/form-data&quot; SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息</p>
<p>上传步骤：</p>
<ol>
<li>添加依赖：</li>
</ol>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="2">
<li>在SpringMVC的配置文件中添加配置：</li>
</ol>
<pre><code class="language-xml">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;
&lt;bean id=&quot;multipartResolver&quot;
class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
&lt;/bean&gt;
</code></pre>
<ol start="3">
<li>控制器方法：</li>
</ol>
<pre><code class="language-java">    @RequestMapping(&quot;/testUp&quot;)
    public String testUp(MultipartFile photo, HttpSession session) throws IOException {
        //获取上传的文件的文件名
        String fileName = photo.getOriginalFilename();
        //处理文件重名问题
        String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;));
        fileName = UUID.randomUUID().toString() + hzName;
        //获取服务器中photo目录的路径
        ServletContext servletContext = session.getServletContext();
        String photoPath = servletContext.getRealPath(&quot;photo&quot;);
        File file = new File(photoPath);
        if(!file.exists()){
            file.mkdir();
        }
        String finalPath = photoPath + File.separator + fileName;
        //实现上传功能
        photo.transferTo(new File(finalPath));
        return &quot;success&quot;;
    }
</code></pre>
<h2 id="拦截器">拦截器</h2>
<h3 id="拦截器的配置">拦截器的配置</h3>
<p>SpringMVC中的拦截器用于拦截控制器方法的执行</p>
<p>SpringMVC中的拦截器需要实现HandlerInterceptor</p>
<p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p>
<pre><code class="language-xml">&lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt;
&lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;
&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;
&lt;mvc:interceptor&gt;
    &lt;mvc:mapping path=&quot;/**&quot;/&gt;
    &lt;mvc:exclude-mapping path=&quot;/testRequestEntity&quot;/&gt;
    &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt;
&lt;/mvc:interceptor&gt;
&lt;!--
以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过
mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求
--&gt;
</code></pre>
<h3 id="拦截器的三个抽象方法">拦截器的三个抽象方法</h3>
<p>SpringMVC中的拦截器有三个抽象方法：</p>
<p>preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返 回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法</p>
<p>postHandle：控制器方法执行之后执行postHandle()</p>
<p>afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()</p>
<h3 id="多个拦截器的执行顺序">多个拦截器的执行顺序</h3>
<ol>
<li>若每个拦截器的preHandle()都返回true</li>
</ol>
<p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：</p>
<p>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p>
<ol start="2">
<li>&gt;若某个拦截器的preHandle()返回了false</li>
</ol>
<p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false 的拦截器之前的拦截器的afterComplation()会执行</p>
<h2 id="异常处理器">异常处理器</h2>
<h3 id="基于配置的异常处理">基于配置的异常处理</h3>
<p>SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver</p>
<p>HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和 SimpleMappingExceptionResolver</p>
<p>SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：</p>
<pre><code class="language-xml">&lt;bean
class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt;
	&lt;property name=&quot;exceptionMappings&quot;&gt;
		&lt;props&gt;
            &lt;!--
                properties的键表示处理器方法执行过程中出现的异常
                properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面
            --&gt;
			&lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt;
		&lt;/props&gt;
	&lt;/property&gt;
    &lt;!--
    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享
    --&gt;
	&lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="基于注解的异常处理">基于注解的异常处理</h3>
<pre><code class="language-java">//@ControllerAdvice将当前类标识为异常处理的组件
@ControllerAdvice
public class ExceptionController {
    
	//@ExceptionHandler用于设置所标识方法处理的异常
	@ExceptionHandler(ArithmeticException.class)
	//ex表示当前请求处理中出现的异常对象
	public String handleArithmeticException(Exception ex, Model model){
        model.addAttribute(&quot;ex&quot;, ex);
        return &quot;error&quot;;
    }
}
</code></pre>
<h2 id="注解配置springmvc">注解配置SpringMVC</h2>
<p>使用配置类和注解代替web.xml和SpringMVC配置文件的功能</p>
<h3 id="创建初始化类代替webxml">创建初始化类，代替web.xml</h3>
<p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类， 如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配 置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自 动发现它，并用它来配置Servlet上下文。</p>
<pre><code class="language-java">public class WebInit extends
AbstractAnnotationConfigDispatcherServletInitializer {
    
    /**
    * 指定spring的配置类
    * @return
    */
    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
    	return new Class[]{SpringConfig.class};
    }
    
    /**
    * 指定SpringMVC的配置类
    * @return
    */
    @Override
    protected Class&lt;?&gt;[] getServletConfigClasses() {
        return new Class[]{WebConfig.class};
    }
    
    /**
    * 指定DispatcherServlet的映射规则，即url-pattern
    * @return
    */
    @Override
    protected String[] getServletMappings() {
    	return new String[]{&quot;/&quot;};
    }
    
    /**
    * 添加过滤器
    * @return
    */
    @Override
    protected Filter[] getServletFilters() {
        CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter();
        encodingFilter.setEncoding(&quot;UTF-8&quot;);
        encodingFilter.setForceRequestEncoding(true);
        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();
        return new Filter[]{encodingFilter, hiddenHttpMethodFilter};
    }
}
</code></pre>
<h3 id="创建springconfig配置类代替spring的配置文件">创建SpringConfig配置类，代替spring的配置文件</h3>
<pre><code class="language-java">@Configuration
public class SpringConfig {
	//ssm整合之后，spring的配置信息写在此类中
}
</code></pre>
<h3 id="创建webconfig配置类代替springmvc的配置文件">创建WebConfig配置类，代替SpringMVC的配置文件</h3>
<pre><code class="language-java">@Configuration
//扫描组件
@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)
//开启MVC注解驱动
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    
    //使用默认的servlet处理静态资源
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurerconfigurer) {
    	configurer.enable();
    }
    
    //配置文件上传解析器
    @Bean
    public CommonsMultipartResolver multipartResolver(){
    	return new CommonsMultipartResolver();
    }
    
    //配置拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        FirstInterceptor firstInterceptor = new FirstInterceptor();
        registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;);
    }
    	
	//配置视图控制
	/*@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);
	}*/
    
	//配置异常映射
	/*@Override
	public void
configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) {
	SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();
	Properties prop = new Properties();
	prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);
	//设置异常映射
	exceptionResolver.setExceptionMappings(prop);
	//设置共享异常信息的键
	exceptionResolver.setExceptionAttribute(&quot;ex&quot;);
	resolvers.add(exceptionResolver);
	}*/
    
	//配置生成模板解析器
	@Bean
	public ITemplateResolver templateResolver() {
		WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext();
		// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过 WebApplicationContext 的方法获得
		ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(
            webApplicationContext.getServletContext());
        templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;);
        templateResolver.setSuffix(&quot;.html&quot;);
        templateResolver.setCharacterEncoding(&quot;UTF-8&quot;);
        templateResolver.setTemplateMode(TemplateMode.HTML);
        return templateResolver;
	}
    
	//生成模板引擎并为模板引擎注入模板解析器
    @Bean
    public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();
        templateEngine.setTemplateResolver(templateResolver);
        return templateEngine;
}
	//生成视图解析器并未解析器注入模板引擎
    @Bean		
    public ViewResolver viewResolver(SpringTemplateEngine templateEngine) {
        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
        viewResolver.setCharacterEncoding(&quot;UTF-8&quot;);
        viewResolver.setTemplateEngine(templateEngine);
        return viewResolver;
    }
}
</code></pre>
<h3 id="测试功能">测试功能</h3>
<pre><code class="language-java">@RequestMapping(&quot;/&quot;)
public String index(){
    return &quot;index&quot;;
}
</code></pre>
<h2 id="springmvc执行流程">SpringMVC执行流程</h2>
<h3 id="springmvc常用组件">SpringMVC常用组件</h3>
<ul>
<li>
<p>DispatcherServlet：前端控制器，不需要工程师开发，由框架提供</p>
<p>作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求</p>
</li>
<li>
<p>HandlerMapping：处理器映射器，不需要工程师开发，由框架提供</p>
<p>作用：根据请求的url、method等信息查找Handler，即控制器方法</p>
</li>
<li>
<p>Handler：处理器，需要工程师开发</p>
<p>作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理</p>
</li>
<li>
<p>HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供</p>
<p>作用：通过HandlerAdapter对处理器（控制器方法）进行执行</p>
</li>
<li>
<p>ViewResolver：视图解析器，不需要工程师开发，由框架提供</p>
<p>作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、 RedirectView</p>
</li>
<li>
<p>View：视图</p>
<p>作用：将模型数据通过页面展示给用户</p>
</li>
</ul>
<h3 id="dispatcherservlet初始化过程">DispatcherServlet初始化过程</h3>
<p>DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。</p>
<figure data-type="image" tabindex="5"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img005.png" alt="img005" loading="lazy"></figure>
<h4 id="初始化webapplicationcontext">&gt;初始化WebApplicationContext</h4>
<p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<pre><code class="language-java">protected WebApplicationContext initWebApplicationContext() {
	WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext());
    
	WebApplicationContext wac = null;
   if (this.webApplicationContext != null) {
	// A context instance was injected at construction time -&gt; use it
		wac = this.webApplicationContext;
		if (wac instanceof ConfigurableWebApplicationContext) {
	ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;
			if (!cwac.isActive()) {
				// The context has not yet been refreshed -&gt; provide services such as
				// setting the parent context, setting the application context id, etc
				if (cwac.getParent() == null) {
				// The context instance was injected without an explicitparent -&gt; set
				// the root application context (if any; may be null) as theparent
				cwac.setParent(rootContext);
			}
		configureAndRefreshWebApplicationContext(cwac);
		}
	}
}
	if (wac == null) {
    // No context instance was injected at construction time -&gt; see if one
    // has been registered in the servlet context. If one exists, it is assumed
    // that the parent context (if any) has already been set and that the
    // user has performed any initialization such as setting the context id
		wac = findWebApplicationContext();
	}
	if (wac == null) {
        // No context instance is defined for this servlet -&gt; create a local one
        // 创建WebApplicationContext
		wac = createWebApplicationContext(rootContext);
	}
    
	if (!this.refreshEventReceived) {
		// Either the context is not a ConfigurableApplicationContext with
refresh
        // support or the context injected at construction time had already been
        // refreshed -&gt; trigger initial onRefresh manually here.
		synchronized (this.onRefreshMonitor) {
		// 刷新WebApplicationContext
		onRefresh(wac);
	}
}
    
	if (this.publishContext) {
        // Publish the context as a servlet context attribute.
        // 将IOC容器在应用域共享
		String attrName = getServletContextAttributeName();
		getServletContext().setAttribute(attrName, wac);
	}
	return wac;
} 
</code></pre>
<h4 id="创建webapplicationcontext">&gt;创建WebApplicationContext</h4>
<p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<pre><code class="language-java">protected WebApplicationContext createWebApplicationContext(@Nullable
ApplicationContext parent) {
	Class&lt;?&gt; contextClass = getContextClass();
	if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass))
{
		throw new ApplicationContextException(
			&quot;Fatal initialization error in servlet with name '&quot; +
getServletName() +
			&quot;': custom WebApplicationContext class [&quot; + contextClass.getName() +
			&quot;] is not of type ConfigurableWebApplicationContext&quot;);
	}
    
	// 通过反射创建 IOC 容器对象
	ConfigurableWebApplicationContext wac = ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
      
	wac.setEnvironment(getEnvironment());
	// 设置父容器
	wac.setParent(parent);
	String configLocation = getContextConfigLocation();
	if (configLocation != null) {
		wac.setConfigLocation(configLocation);
	}
	configureAndRefreshWebApplicationContext(wac);
	return wac;
}
</code></pre>
<h4 id="dispatcherservlet初始化策略">&gt;DispatcherServlet初始化策略</h4>
<p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在 DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化 DispatcherServlet的各个组件</p>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<pre><code class="language-java">protected void initStrategies(ApplicationContext context) {
    initMultipartResolver(context);
    initLocaleResolver(context);
    initThemeResolver(context);
    initHandlerMappings(context);
    initHandlerAdapters(context);
    initHandlerExceptionResolvers(context);
    initRequestToViewNameTranslator(context);
    initViewResolvers(context);
    initFlashMapManager(context);
}
</code></pre>
<h3 id="dispatcherservlet调用组件处理请求">DispatcherServlet调用组件处理请求</h3>
<h4 id="processrequest">processRequest()</h4>
<p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p>
<p>所在类：org.springframework.web.servlet.FrameworkServlet</p>
<pre><code class="language-java">    protected final void processRequest(HttpServletRequest request,HttpServletResponse response)throws ServletException, IOException {
        long startTime = System.currentTimeMillis();
        Throwable failureCause = null;
        LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();
        LocaleContext localeContext = buildLocaleContext(request);
        RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();
        ServletRequestAttributes requestAttributes = buildRequestAttributes(request,response, previousAttributes);
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);
        asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(),new RequestBindingInterceptor());
        initContextHolders(request, localeContext, requestAttributes);
        try {
        // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写
            doService(request, response);
        }
        catch (ServletException | IOException ex) {
            failureCause = ex;
            throw ex;
        }
        catch (Throwable ex) {
            failureCause = ex;
            throw new NestedServletException(&quot;Request processing failed&quot;, ex);
        }
        finally {
            resetContextHolders(request, previousLocaleContext, previousAttributes);
            if (requestAttributes != null) {
                requestAttributes.requestCompleted();
            }
            logResult(request, response, failureCause, asyncManager);
            publishRequestHandledEvent(request, response, startTime, failureCause);
        }
    }
</code></pre>
<h4 id="doservice">doService()</h4>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<pre><code class="language-java">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {
    logRequest(request);

    // Keep a snapshot of the request attributes in case of an include,
    // to be able to restore the original attributes after the include.
    Map&lt;String, Object&gt; attributesSnapshot = null;
    if (WebUtils.isIncludeRequest(request)) {
        attributesSnapshot = new HashMap&lt;&gt;();
        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();
        while (attrNames.hasMoreElements()) {
            String attrName = (String) attrNames.nextElement();
            if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {
                attributesSnapshot.put(attrName, request.getAttribute(attrName));
            }
        }
    }

    // Make framework objects available to handlers and view objects.
    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());
    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);
    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);
    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());

    if (this.flashMapManager != null) {
        FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);
        if (inputFlashMap != null) {
            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));
        }
        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());
        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);
    }

    RequestPath requestPath = null;
    if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) {
        requestPath = ServletRequestPathUtils.parseAndCache(request);
    }

    try {
        // 处理请求和响应
        doDispatch(request, response);
    }
    finally {
        if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
            // Restore the original attribute snapshot, in case of an include.
            if (attributesSnapshot != null) {
                restoreAttributesAfterInclude(request, attributesSnapshot);
            }
        }
        if (requestPath != null) {
            ServletRequestPathUtils.clearParsedRequestPath(request);
        }
    }
}  
</code></pre>
<h4 id="dodispatch">doDispatch()</h4>
<p>所在类：org.springframework.web.servlet.DispatcherServlet</p>
<pre><code class="language-java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;

    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        ModelAndView mv = null;
        Exception dispatchException = null;

        try {
            processedRequest = checkMultipart(request);
            multipartRequestParsed = (processedRequest != request);

            // Determine handler for the current request.
            /*
            	mappedHandler：调用链
                包含handler、interceptorList、interceptorIndex
            	handler：浏览器发送的请求所匹配的控制器方法
            	interceptorList：处理控制器方法的所有拦截器集合
            	interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行
            */
            mappedHandler = getHandler(processedRequest);
            if (mappedHandler == null) {
                noHandlerFound(processedRequest, response);
                return;
            }

            // Determine handler adapter for the current request.
           	// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法
            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

            // Process last-modified header, if supported by the handler.
            String method = request.getMethod();
            boolean isGet = &quot;GET&quot;.equals(method);
            if (isGet || &quot;HEAD&quot;.equals(method)) {
                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {
                    return;
                }
            }
			
            // 调用拦截器的preHandle()
            if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                return;
            }

            // Actually invoke the handler.
            // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象
            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

            if (asyncManager.isConcurrentHandlingStarted()) {
                return;
            }

            applyDefaultViewName(processedRequest, mv);
            // 调用拦截器的postHandle()
            mappedHandler.applyPostHandle(processedRequest, response, mv);
        }
        catch (Exception ex) {
            dispatchException = ex;
        }
        catch (Throwable err) {
            // As of 4.3, we're processing Errors thrown from handler methods as well,
            // making them available for @ExceptionHandler methods and other scenarios.
            dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);
        }
        // 后续处理：处理模型数据和渲染视图
        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
    }
    catch (Exception ex) {
        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
    }
    catch (Throwable err) {
        triggerAfterCompletion(processedRequest, response, mappedHandler,
                               new NestedServletException(&quot;Handler processing failed&quot;, err));
    }
    finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            // Instead of postHandle and afterCompletion
            if (mappedHandler != null) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        }
        else {
            // Clean up any resources used by a multipart request.
            if (multipartRequestParsed) {
                cleanupMultipart(processedRequest);
            }
        }
    }
}
</code></pre>
<h4 id="processdispatchresult">processDispatchResult()</h4>
<pre><code class="language-java">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
                                   @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
                                   @Nullable Exception exception) throws Exception {

    boolean errorView = false;

    if (exception != null) {
        if (exception instanceof ModelAndViewDefiningException) {
            logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);
            mv = ((ModelAndViewDefiningException) exception).getModelAndView();
        }
        else {
            Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);
            mv = processHandlerException(request, response, handler, exception);
            errorView = (mv != null);
        }
    }

    // Did the handler return a view to render?
    if (mv != null &amp;&amp; !mv.wasCleared()) {
        // 处理模型数据和渲染视图
        render(mv, request, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    }
    else {
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;);
        }
    }

    if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
        // Concurrent handling started during a forward
        return;
    }

    if (mappedHandler != null) {
        // Exception (if any) is already handled..
        // 调用拦截器的afterCompletion()
        mappedHandler.triggerAfterCompletion(request, response, null);
    }
}
</code></pre>
<h3 id="springmvc的执行流程">SpringMVC的执行流程</h3>
<ol>
<li>
<p>用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。</p>
</li>
<li>
<p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：</p>
<p>a.不存在</p>
<ol>
<li>
<p>再判断是否配置了mvc:default-servlet-handler</p>
</li>
<li>
<p>如果没配置，则控制台报映射查找不到，客户端展示404错误</p>
<figure data-type="image" tabindex="6"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img007.png" alt="img007" loading="lazy"></figure>
</li>
<li>
<p>如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404 错误</p>
<figure data-type="image" tabindex="7"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img008.png" alt="img008" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img009.png" alt="img009" loading="lazy"></figure>
</li>
</ol>
<p>b.存在则执行下面的流程</p>
</li>
<li>
<p>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及 Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。</p>
</li>
<li>
<p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。</p>
</li>
<li>
<p>如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】</p>
</li>
<li>
<p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
<p>a. HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p>
<p>b.数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p>
<p>c.数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p>
<p>d.数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p>
</li>
<li>
<p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。</p>
</li>
<li>
<p>此时将开始执行拦截器的postHandle(...)方法【逆向】</p>
</li>
<li>
<p>根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行 HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model 和View，来渲染视图。</p>
</li>
<li>
<p>渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。</p>
</li>
<li>
<p>将渲染结果返回给客户端。</p>
</li>
</ol>

                </div>
                <div class="clear"></div>
              </section>
            </article>
            <div class="clear"></div>

            <section class="related section">
              
              <article class="prev grid-50 tablet-grid-50 grid-parent">
                <div class="thumb cover lazy loaded" style="background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/お豆腐_99167071.jpg');"></div>
                 <a href="https://nanteng.github.io/post/ssm-zheng-he/" class="full-link"></a>
                 <div class="info">
                  <time datetime="2022-11-15">2022-11-15</time>
                  <h4 class="title white no-margin">SSM整合</h4>
                </div>
                 <span class="epcl-button red">
                  <img src="https://nanteng.github.io/media/images/left-arrow.svg" width="15" alt="Left Arrow">
                </span>
                <div class="overlay"></div>
              </article>
              
              
              <article class="next grid-50 tablet-grid-50 grid-parent">
                <div class="thumb cover lazy loaded" style="background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/20221109_235735.jpg');"></div>
                 <a href="https://nanteng.github.io/post/mybatis/" class="full-link"></a>
                 <div class="info">
                  <time datetime="2022-11-11">2022-11-11</time>
                  <h4 class="title white no-margin">MyBatis</h4>
                </div>
                 <span class="epcl-button red">
                  <img src="https://nanteng.github.io/media/images/right-arrow.svg" width="15" alt="Left Arrow">
                </span>
                <div class="overlay"></div>
              </article>
              

                <div class="clear"></div>
            </section>

              <div class="clear"></div>
              
            
              <div id="comments" class="bg-white hosted ">
                <div class="clear"></div>
<script>
jQuery(document).ready(function($){
    $('.vemoji-btn').text('😀');
    $("#comments").on('click', 'span.vat',function(){
        $(this).parent('div.vmeta').next("div.vcontent").after($("div.vwrap"));
        $('textarea#veditor').focus();
    })
    if(window.location.hash){
        var checkExist = setInterval(function() {
            if ($(window.location.hash).length) {
                $('html, body').animate({scrollTop: $(window.location.hash).offset().top-200}, 600);
                clearInterval(checkExist);
            }
        }, 100);
    }
})
</script>

              </div>
            

            </div>
          </div>
      </main>

          <footer id="footer" class="grid-container">
        <div class="widgets row gradient-effect">
            <div class="default-sidebar border-effect">
              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="tag_cloud-2" class="widget widget_epcl_posts_thumbs underline-effect">
                  <h4 class="widget-title title white bordered">最新文章</h4>
                  
                  
                  <article class="item post-0 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://nanteng.github.io/post/mavenbasics/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/tumblr_b38009612775acb3f606c15e4ca4cfb0_9b8bb164_1280.png');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2022-11-16">2022-11-16</time>
                      <h4 class="title usmall">
                        <a href="https://nanteng.github.io/post/mavenbasics/">MavenBasics</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  <article class="item post-1 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://nanteng.github.io/post/ssm-zheng-he/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/お豆腐_99167071.jpg');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2022-11-15">2022-11-15</time>
                      <h4 class="title usmall">
                        <a href="https://nanteng.github.io/post/ssm-zheng-he/">SSM整合</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  <article class="item post-2 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://nanteng.github.io/post/springmvc/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/20221112_004658.jpg');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2022-11-15">2022-11-15</time>
                      <h4 class="title usmall">
                        <a href="https://nanteng.github.io/post/springmvc/">SpringMVC</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  <div class="clear"></div>
                </section>
              </div>

              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="tag_cloud-2" class="widget widget_tag_cloud underline-effect">
                  <h4 class="widget-title title white bordered">标签云</h4>
                  <div class="tagcloud">
                    
                      <a href="https://nanteng.github.io/tag/TtKdK6ur-/" class="ctag ctag-0 ctag-TtKdK6ur-" aria-label="">Java</a>
                    
                      <a href="https://nanteng.github.io/tag/Pb31zuZQs/" class="ctag ctag-1 ctag-Pb31zuZQs" aria-label="">诗歌</a>
                    
                      <a href="https://nanteng.github.io/tag/wFMTkH_sNe/" class="ctag ctag-2 ctag-wFMTkH_sNe" aria-label="">日记</a>
                    
                      <a href="https://nanteng.github.io/tag/q1drPjJv3/" class="ctag ctag-3 ctag-q1drPjJv3" aria-label="">随笔</a>
                    
                      <a href="https://nanteng.github.io/tag/eSKuLZlYEN/" class="ctag ctag-4 ctag-eSKuLZlYEN" aria-label="">Linux</a>
                    
                      <a href="https://nanteng.github.io/tag/i9Zqgezw0Q/" class="ctag ctag-5 ctag-i9Zqgezw0Q" aria-label="">体验</a>
                    
                      <a href="https://nanteng.github.io/tag/VxnVWpClHS/" class="ctag ctag-6 ctag-VxnVWpClHS" aria-label="">软件</a>
                    
                      <a href="https://nanteng.github.io/tag/1DZ-nCoLTA/" class="ctag ctag-7 ctag-1DZ-nCoLTA" aria-label="">信件</a>
                    
                      <a href="https://nanteng.github.io/tag/Fcf3eo9iSf/" class="ctag ctag-8 ctag-Fcf3eo9iSf" aria-label="">CentOS</a>
                    
                  </div>
                  <div class="clear"></div>
                </section>
              </div>

              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="epcl_about-2" class="widget widget_epcl_about underline-effect">
                  <h4 class="widget-title title white bordered">关于我</h4>
                  <div class="avatar">
                    <a href="" class="translate-effect thumb"><span class="fullimage cover" style="background-image: url(https://nanteng.github.io/images/avatar.png);"></span></a>
                  </div>
                  <div class="info">
                    <h4 class="title small author-name gradient-effect no-margin"><a href="">南藤北玄参</a></h4>
                    <p class="founder">唯沉默为最高的轻蔑</p>
                    <div class="social">
                      
                          
                            <a href="https://github.com/NanTeng" class="translate-effect" target="_blank"><i class="fa fa-github"></i></a>
                        
                      
                          
                            <a href="https://twitter.com/NanTeng418" class="translate-effect" target="_blank"><i class="fa fa-twitter"></i></a>
                        
                      
                        
                      
                          
                            <a href="https://t.me/NanTeng" class="translate-effect" target="_blank"><i class="fa fa-telegram"></i></a>
                        
                      
                        
                      
                    </div> 
                  </div>
                  <div class="clear"></div>
                  </section>
              </div>

            </div>
            <div class="clear"></div>
        </div>

        <div class="logo">
          <a href="https://nanteng.github.io"><img src="\media\images\custom-footerLogo.gif" alt=""></a>
        </div>
        <p class="published border-effect">
          ©2019 共 28 篇文章
          <br/>
          Theme <a href="https://gridea.dev/" target="_blank">「breek」</a> Powered by <a href="https://gridea.dev/" target="_blank">「Gridea」</a>
        </p>
        
        <a href="javascript:void(0)" id="back-to-top" class="epcl-button dark" style="display:none">
          <i class="fa fa-arrow"></i>
        </a>
    </footer>
    
    <div class="clear"></div>

        
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/valine/1.3.10/Valine.Pure.min.js"></script>
<script>
    new Valine({
        el: '#comments',
        appId: 'JCYzcWAfC7BkMZHJ3hrKx85t-gzGzoHsz' ,
        appKey: 'r89Wpg7b2oYFtiu1JGnthBzN',
        pageSize: 30,
        placeholder: '既然来了，那就留个痕迹吧~',
        visitor: true // 阅读量统计
    })
</script>
    

      
    <script src="https://nanteng.github.io/media/js/functions-post.js"></script>

    </div>
    <!-- end: #wrapper -->
  </body>
</html>
