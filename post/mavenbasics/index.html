<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>MavenBasics | 南藤北玄参</title>
<meta name="description" content="唯沉默为最高的轻蔑" />
<link rel="shortcut icon" href="https://nanteng.github.io/favicon.ico">
<link rel="stylesheet" href="https://nanteng.github.io/styles/main.css">

<script src="https://nanteng.github.io/media/js/jquery.min.js"></script>
<script src="https://nanteng.github.io/media/js/masonry.pkgd.min.js"></script>
<script src="https://nanteng.github.io/media/js/aos.js"></script>
<script src="https://nanteng.github.io/media/js/pace.min.js"></script>
<script src="https://nanteng.github.io/media/js/view-image.min.js"></script>
<script src="https://nanteng.github.io/media/js/jquery.magnific-popup.min.js"></script>
<script src="https://nanteng.github.io/media/js/functions.js"></script>
    <meta name="referrer" content="never">
    <meta name="description" content="Maven 作为依赖管理工具
​	管理规模庞大的 jar 包，需要专门工具。
Maven 作为构建管理工具
​	脱离 IDE 环境执行构建操作，需要专门工具。
什么是Maven
构建
构建过程包含的主要环节

清理：删除上一次构建的结果，为..." />
    <meta name="keywords" content="Java" />
    <script src="https://nanteng.github.io/media/js/waterfall.min.js"></script>
    <script src="https://nanteng.github.io/media/js/prism.min.js"></script>
  </head>
  <body>
            <header id="header" class="grid-container">
        <!-- start: .menu-wrapper -->
        <div class="menu-mobile"> 
          <i class="fa fa-reorder"></i>
        </div>
        <div class="menu-wrapper">
          <div class="">
            <div class="logo">
              <a href="https://nanteng.github.io"><img src="\media\images\custom-headerLogo.gif" alt=""></a>
            </div>
            <!-- start: .main-nav -->

            <nav class="main-nav grid-container grid-parent">
              <ul id="menu-header" class="menu gradient-effect">
                <li class=""><a href="https://nanteng.github.io" class="menu">首页</a></li>
                
                  <li class="" >
                    <a href="/archives" class="menu">
                      归档
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="/tags" class="menu">
                      标签
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="https://cloud.dearkai.cn" class="menu">
                      云盘
                    </a>
                  </li>
                
                  <li class="" >
                    <a href="/post/about" class="menu">
                      关于
                    </a>
                  </li>
                
                <li class="search-menu-item hide-on-mobile hide-on-tablet"><a href="#search-lightbox" class="lightbox mfp-inline"><i class="fa fa-search-line"></i></a></li>
              </ul>
            </nav>
            <a href="#search-lightbox" class="lightbox epcl-search-button mfp-inline hide-on-tablet hide-on-desktop"><i class="fa fa-search-line"></i></a>
            <!-- end: .main-nav -->
            <div class="clear"></div>
            <div class="border hide-on-tablet hide-on-mobile"></div>
          </div>    
          <div class="clear"></div>
        </div>
        <!-- end: .menu-wrapper -->
        <div class="clear"></div>
      </header>
      <div class="hide-on-mobile hide-on-tablet hide-on-desktop">
        <div id="search-lightbox" class="grid-container grid-small grid-parent mfp-hide">
          <div class="search-wrapper section">
            <form id="gridea-search-form" data-update="1668567925322" action="/search/index.html" class="search-form" _lpchecked="1">
              <input type="text" name="q" id="s" value="" class="search-field" placeholder="搜点啥..." aria-label="搜点啥..." required="">
              <button type="submit" class="submit" aria-label="Submit">
                <i class="fa fa-search-line"></i>
              </button>
            </form>
          </div>
        </div>
      </div>

      <main id="single" class="main grid-container fullcover no-sidebar aos-init aos-animate" data-aos="fade">

        <div class="center content">
          <div class="featured-image cover" style="background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/tumblr_b38009612775acb3f606c15e4ca4cfb0_9b8bb164_1280.png');">
            <div class="meta top"> 
              <time class="meta-info" style="float:left;" datetime="2022-11-16"><i class="fa fa-calendar"></i><span class="lately">8 分钟前</span></time>
              
              <a href="https://nanteng.github.io/post/mavenbasics/#comments" class="comments meta-info" title="">
                <i class="fa fa-comment remixicon"></i><span class="comment-count valine-comment-count" data-xid="/mavenbasics/"> </span>
              </a>
              <span id="/mavenbasics/" class="leancloud_visitors views-counter meta-info" title=""><i class="fa fa-leancloud remixicon"></i><span class="leancloud-visitors-count"></span></span>
              
            </div>
            <div class="info">
              <div class="tags ">
                
                      <a href="https://nanteng.github.io/tag/TtKdK6ur-/" class="ctag ctag-0 ctag-TtKdK6ur-" aria-label="">Java</a>
                    
              </div>
              <h1 class="title ularge white bold">MavenBasics</h1>
            </div>
          </div>
        </div>  

        <div class="epcl-page-wrapper">
          <div class="left-content grid-70 np-mobile">
            <article class="main-article post">
              <section class="post-content">
                <div class="text">
                  <p><strong>Maven 作为依赖管理工具</strong></p>
<p>​	管理规模庞大的 jar 包，需要专门工具。</p>
<p><strong>Maven 作为构建管理工具</strong></p>
<p>​	脱离 IDE 环境执行构建操作，需要专门工具。</p>
<h2 id="什么是maven">什么是Maven</h2>
<h3 id="构建">构建</h3>
<p>构建过程包含的主要环节</p>
<ul>
<li>清理：删除上一次构建的结果，为下一次构建做准备</li>
<li>编译</li>
<li>测试</li>
<li>报告</li>
<li>打包
<ul>
<li>Java工程：jar包</li>
<li>Web工程：war包</li>
</ul>
</li>
<li>安装：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入Maven的本地仓库</li>
<li>部署
<ul>
<li>部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上</li>
<li>部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上</li>
</ul>
</li>
</ul>
<h3 id="依赖">依赖</h3>
<p>依赖管理中要解决的具体问题：</p>
<ul>
<li>jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li>
<li>jar 包之间的依赖：通过依赖的传递性自动完成</li>
<li>jar 包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入</li>
</ul>
<h3 id="maven的工作机制">Maven的工作机制</h3>
<figure data-type="image" tabindex="1"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img003.f9cc536c.png" alt="img" loading="lazy"></figure>
<h2 id="核心程序的配置">核心程序的配置</h2>
<ol>
<li>
<p>指定本地仓库</p>
<p>本地仓库默认值：用户家目录/.m2/repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中 jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以建议将 Maven 的本地仓库放在其他盘符下。配置方式如下：</p>
<pre><code class="language-xml">&lt;!-- localRepository
| The path to the local repository maven will use to store artifacts.
|
| Default: ${user.home}/.m2/repository
&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;
--&gt;
&lt;localRepository&gt;D:\maven-repository&lt;/localRepository&gt;
</code></pre>
<p>本地仓库这个目录，我们手动创建一个空的目录即可。</p>
<p>记住：一定要把 localRepository 标签从注释中拿出来。</p>
<p>注意：本地仓库本身也需要使用一个非中文、没有空格的目录。</p>
</li>
<li>
<p>配置阿里云提供的镜像仓库</p>
<p>Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，访问国内网站，可以让 Maven 下载 jar 包的时候速度更快。配置的方式是：</p>
<p>①将原有的例子配置注释掉</p>
<pre><code class="language-xml">&lt;!-- &lt;mirror&gt;
  &lt;id&gt;maven-default-http-blocker&lt;/id&gt;
  &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt;
  &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt;
  &lt;url&gt;http://0.0.0.0/&lt;/url&gt;
  &lt;blocked&gt;true&lt;/blocked&gt;
&lt;/mirror&gt; --&gt;
</code></pre>
<p>加入阿里云的配置镜像源</p>
<pre><code class="language-xml">  &lt;mirror&gt;
    &lt;id&gt;nexus-aliyun&lt;/id&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
    &lt;name&gt;Nexus aliyun&lt;/name&gt;
    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;
  &lt;/mirror&gt;
</code></pre>
</li>
<li>
<p>配置 Maven 工程的基础 JDK 版本</p>
<p>如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：将 profile 标签整个复制到 settings.xml 文件的 profiles 标签内。</p>
<pre><code class="language-xml">  &lt;profile&gt;
    &lt;id&gt;jdk-1.8&lt;/id&gt;
    &lt;activation&gt;
    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;jdk&gt;1.8&lt;/jdk&gt;
    &lt;/activation&gt;
    &lt;properties&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
    &lt;/properties&gt;
  &lt;/profile&gt;
</code></pre>
</li>
<li>
<p>配置验证环境变量</p>
<p>~</p>
<p>在windows cmd控制台输入验证查看是否配置成功</p>
<pre><code class="language-bash">mvn -v
</code></pre>
</li>
</ol>
<h2 id="maven命令行">Maven:命令行</h2>
<h3 id="根据坐标创建maven工程">根据坐标创建Maven工程</h3>
<p>使用三个『向量』在『Maven的仓库』中唯一的定位到一个『jar』包。</p>
<ul>
<li>groupId: 公司或组织的id</li>
<li>artifactId: 一个项目或是项目中的一个模块的id</li>
<li>version: 版本号</li>
</ul>
<p>三个“量”的取值方式</p>
<ul>
<li>groupId：公司或组织域名的倒序，通常也会加上项目名称
<ul>
<li>例如：com.atguigu.maven</li>
</ul>
</li>
<li>artifactId：模块的名称，将来作为 Maven 工程的工程名</li>
<li>version：模块的版本号，根据自己的需要设定
<ul>
<li>例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本</li>
<li>例如：RELEASE 表示正式版本</li>
</ul>
</li>
</ul>
<p>坐标和仓库中 jar 包的存储路径之间的对应关系</p>
<h4 id="坐标">坐标</h4>
<pre><code class="language-xml">  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
  &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
  &lt;version&gt;2.5&lt;/version&gt;
</code></pre>
<p>上面坐标对应的 jar 包在 Maven 本地仓库中的位置：</p>
<pre><code class="language-bash">Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar
</code></pre>
<h5 id="使用命令生成maven工程">使用命令生成Maven工程</h5>
<figure data-type="image" tabindex="2"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image.png" alt="img" loading="lazy"></figure>
<p>运行 <code>mvn archetype:generate</code>命令</p>
<p>提示操作</p>
<pre><code class="language-bash">Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:【直接回车，使用默认值】

Define value for property 'groupId': com.atguigu.maven

Define value for property 'artifactId': pro01-maven-java

Define value for property 'version' 1.0-SNAPSHOT: :【直接回车，使用默认值】

Define value for property 'package' com.atguigu.maven: :【直接回车，使用默认值】

Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro01-maven-java version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认。如果前面有输入错误，想要重新输入，则输入 N 再回车。】
</code></pre>
<h5 id="调整">调整</h5>
<p>Maven 默认生成的工程，对 junit 依赖的是较低的 3.8.1 版本，我们可以改成较适合的 4.12 版本。</p>
<pre><code class="language-xml">&lt;!-- 依赖信息配置 --&gt;
&lt;!-- dependencies复数标签：里面包含dependency单数标签 --&gt;
&lt;dependencies&gt;
  &lt;!-- dependency单数标签：配置一个具体的依赖 --&gt;
  &lt;dependency&gt;
    &lt;!-- 通过坐标来依赖其他jar包 --&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    
    &lt;!-- 依赖的范围 --&gt;
    &lt;scope&gt;test&lt;/scope&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h5 id="自动生成的-pomxml-解读">自动生成的 pom.xml 解读</h5>
<pre><code class="language-xml">  &lt;!-- 当前Maven工程的坐标 --&gt;
  &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;
  &lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  
  &lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;
  &lt;!-- jar：表示这个工程是一个Java工程  --&gt;
  &lt;!-- war：表示这个工程是一个Web工程 --&gt;
  &lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;pro01-maven-java&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;

  &lt;properties&gt;
  &lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
  &lt;/properties&gt;

  &lt;!-- 当前工程所依赖的jar包 --&gt;
  &lt;dependencies&gt;
  &lt;!-- 使用dependency配置一个具体的依赖 --&gt;
    &lt;dependency&gt;
  
    &lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.12&lt;/version&gt;
    
    &lt;!-- scope标签配置依赖的范围 --&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

</code></pre>
<h4 id="pom">POM</h4>
<h5 id="含义">含义</h5>
<p>POM：Project Object Model，项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</p>
<h5 id="模型化思想">模型化思想</h5>
<p>POM 表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。</p>
<h5 id="对应的配置文件">对应的配置文件</h5>
<p>POM 理念集中体现在 Maven 工程根目录下 pom.xml 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。</p>
<h4 id="约定目录结构">约定目录结构</h4>
<h5 id="各个目录的作用">各个目录的作用</h5>
<figure data-type="image" tabindex="3"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image.png" alt="img" loading="lazy"></figure>
<p>另外还有一个 target 目录专门存放构建操作输出的结果。</p>
<h5 id="约定目录结构的意义">约定目录结构的意义</h5>
<p>Maven 为了让构建过程能够尽可能<strong>自动化</strong>完成，所以必须约定目录结构的作用。例如：Maven 执行编译操作，必须先去 Java 源程序目录读取 Java 源代码，然后执行编译，最后把编译结果存放在 target 目录。</p>
<h5 id="约定大于配置">约定大于配置</h5>
<p>Maven 对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建 Maven 工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。</p>
<p>目前开发领域的技术发展趋势就是：约定大于配置，配置大于编码。</p>
<h3 id="在maven工程中编写代码">在Maven工程中编写代码</h3>
<h4 id="主体程序">主体程序</h4>
<figure data-type="image" tabindex="4"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image1.png" alt="image1" loading="lazy"></figure>
<p>主体程序指的是被测试的程序，同时也是将来在项目中真正要使用的程序。</p>
<pre><code class="language-java">package com.atguigu.maven;
  
public class Calculator {
  
  public int sum(int i, int j){
    return i + j;
  }
  
}
</code></pre>
<h4 id="测试程序">测试程序</h4>
<figure data-type="image" tabindex="5"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image1.png" alt="image" loading="lazy"></figure>
<pre><code class="language-java">package com.atguigu.maven;
  
import org.junit.Test;
import com.atguigu.maven.Calculator;
  
// 静态导入的效果是将Assert类中的静态资源导入当前类
// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名
import static org.junit.Assert.*;
  
public class CalculatorTest{
  
  @Test
  public void testSum(){
    
    // 1.创建Calculator对象
    Calculator calculator = new Calculator();
    
    // 2.调用Calculator对象的方法，获取到程序运行实际的结果
    int actualResult = calculator.sum(5, 3);
    
    // 3.声明一个变量，表示程序运行期待的结果
    int expectedResult = 8;
    
    // 4.使用断言来判断实际结果和期待结果是否一致
    // 如果一致：测试通过，不会抛出异常
    // 如果不一致：抛出异常，测试失败
    assertEquals(expectedResult, actualResult);
    
  }
  
}

</code></pre>
<h3 id="执行-maven-的构建命令">执行 Maven 的构建命令</h3>
<h4 id="要求">要求</h4>
<p>运行 Maven 中和构建操作相关的命令时，必须进入到 pom.xml 所在的目录。如果没有在 pom.xml 所在的目录运行 Maven 的构建命令，那么会看到下面的错误信息：</p>
<pre><code class="language-bash">The goal you specified requires a project to execute but there is no POM in this directory
</code></pre>
<blockquote>
<p>mvn -v 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录。</p>
</blockquote>
<h4 id="清理操作">清理操作</h4>
<p>mvn clean</p>
<p>效果：删除 target 目录</p>
<h4 id="编译操作">编译操作</h4>
<p>主程序编译：mvn compile</p>
<p>测试程序编译：mvn test-compile</p>
<p>主体程序编译结果存放的目录：target/classes</p>
<p>测试程序编译结果存放的目录：target/test-classes</p>
<h4 id="测试操作">测试操作</h4>
<p>4、测试操作</p>
<h4 id="打包操作">打包操作</h4>
<p>mvn package</p>
<p>打包的结果——jar 包，存放的目录：target</p>
<h4 id="安装操作">安装操作</h4>
<p>mvn install</p>
<pre><code class="language-bash">[INFO] Installing D:\maven-workspace\space201026\pro01-maven-java\target\pro01-maven-java-1.0-SNAPSHOT.jar to D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar
[INFO] Installing D:\maven-workspace\space201026\pro01-maven-java\pom.xml to D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.pom
</code></pre>
<p>安装的效果是将本地构建过程中生成的 jar 包存入 Maven 本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。</p>
<p>坐标信息如下：</p>
<pre><code class="language-xml">  &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;
  &lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
</code></pre>
<p>坐标信息如下：</p>
<pre><code class="language-bash">D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar
</code></pre>
<p>另外，安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</p>
<h3 id="创建maven版的web工程">创建Maven版的Web工程</h3>
<h4 id="说明">说明</h4>
<p>使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。这个专门生成 Web 工程骨架的 archetype 可以参照官网看到它的用法：</p>
<p><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img014.942770a3.png" alt="img" loading="lazy">参数 archetypeGroupId、archetypeArtifactId、archetypeVersion 用来指定现在使用的 maven-archetype-webapp 的坐标。</p>
<h4 id="操作">操作</h4>
<p>注意：如果在上一个工程的目录下执行 mvn archetype:generate 命令，那么 Maven 会报错：不能在一个非 pom 的工程下再创建其他工程。所以不要再刚才创建的工程里再创建新的工程，请回到工作空间根目录来操作。</p>
<p>然后运行生成工程的命令：</p>
<pre><code class="language-bash">mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4
</code></pre>
<p>下面的操作按照提示执行：</p>
<pre><code class="language-bash">Define value for property 'groupId': com.atguigu.maven Define value for property 'artifactId': pro02-maven-web Define value for property 'version' 1.0-SNAPSHOT: :【直接回车，使用默认值】

Define value for property 'package' com.atguigu.maven: :【直接回车，使用默认值】 Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro02-maven-web version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认】
</code></pre>
<h4 id="生成的pomxml">生成的pom.xml</h4>
<p>确认打包的方式是war包形式</p>
<pre><code class="language-xml">&lt;packaging&gt;war&lt;/packaging&gt;
</code></pre>
<h4 id="生成的web工程的目录结构">生成的Web工程的目录结构</h4>
<figure data-type="image" tabindex="6"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/image3.png" alt="image3" loading="lazy"></figure>
<p>webapp 目录下有 index.jsp</p>
<p>WEB-INF 目录下有 web.xml</p>
<h4 id="创建-servlet">创建 Servlet</h4>
<ol>
<li>
<p>在 main 目录下创建 java 目录</p>
<figure data-type="image" tabindex="7"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/download1.png" alt="download1" loading="lazy"></figure>
</li>
<li>
<p>在 java 目录下创建 Servlet 类所在的包的目录</p>
<figure data-type="image" tabindex="8"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/download2.png" alt="download2" loading="lazy"></figure>
</li>
<li>
<p>在包下创建 Servlet 类</p>
<pre><code class="language-java">package com.atguigu.maven;
	
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;
import java.io.IOException;
	
public class HelloServlet extends HttpServlet{
	
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
		response.getWriter().write(&quot;hello maven web&quot;);
		
	}
	
}
</code></pre>
</li>
<li>
<p>在 web.xml 中注册 Servlet</p>
<pre><code class="language-xml"> &lt;servlet&gt;
	&lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.atguigu.maven.HelloServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
	&lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>在 index.jsp 页面编写超链接</p>
<pre><code class="language-html">&lt;html&gt;
&lt;body&gt;
&lt;h2&gt;Hello World!&lt;/h2&gt;
&lt;a href=&quot;helloServlet&quot;&gt;Access Servlet&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<blockquote>
<p>TIP</p>
<p>JSP全称是 Java Server Page，和 Thymeleaf 一样，是服务器端页面渲染技术。这里我们不必关心 JSP 语法细节，编写一个超链接标签即可。</p>
</blockquote>
</li>
<li>
<p>编译</p>
<p>此时直接执行 mvn compile 命令出错：</p>
<blockquote>
<p>DANGER</p>
<p>程序包 javax.servlet.http 不存在</p>
<p>程序包 javax.servlet 不存在</p>
<p>找不到符号</p>
<p>符号: 类 HttpServlet</p>
<p>……</p>
</blockquote>
<p>上面的错误信息说明：我们的 Web 工程用到了 HttpServlet 这个类，而 HttpServlet 这个类属于 servlet-api.jar 这个 jar 包。此时我们说，Web 工程需要依赖 servlet-api.jar 包。</p>
<figure data-type="image" tabindex="9"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img018.f836f056.png" alt="./images" loading="lazy"></figure>
</li>
<li>
<p>配置对servlet-api.jar包的依赖</p>
<p>对于不知道详细信息的依赖可以到https://mvnrepository.com/网站查询。使用关键词搜索，然后在搜索结果列表中选择适合的使用。</p>
<figure data-type="image" tabindex="10"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img019.46741083.png" alt="./images" loading="lazy"></figure>
<p>比如，我们找到的 servlet-api 的依赖信息：</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>这样就可以把上面的信息加入 pom.xml。重新执行 mvn compile 命令。</p>
</li>
<li>
<p>将Web工程打包为war包</p>
<p>运行 mvn package 命令，生成 war 包的位置如下图所示：</p>
<figure data-type="image" tabindex="11"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/download3.png" alt="download3" loading="lazy"></figure>
</li>
<li>
<p>将 war 包部署到 Tomcat 上运行</p>
<p>将 war 包复制到 Tomcat/webapps 目录下</p>
<figure data-type="image" tabindex="12"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/download5.png" alt="download5" loading="lazy"></figure>
<p>启动Tomcat:</p>
<figure data-type="image" tabindex="13"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/download6.png" alt="download5" loading="lazy"></figure>
<p>通过浏览器尝试访问：http://localhost:8080/pro02-maven-web/index.jsp</p>
</li>
</ol>
<h3 id="让web工程依赖java工程">让Web工程依赖Java工程</h3>
<h4 id="观念">观念</h4>
<p>明确一个意识：从来只有 Web 工程依赖 Java 工程，没有反过来 Java 工程依赖 Web 工程。本质上来说，Web 工程依赖的 Java 工程其实就是 Web 工程里导入的 jar 包。最终 Java 工程会变成 jar 包，放在 Web 工程的 WEB-INF/lib 目录下。</p>
<h4 id="操作-2">操作</h4>
<p>在 pro02-maven-web 工程的 pom.xml 中，找到 dependencies 标签，在 dependencies 标签中做如下配置：</p>
<pre><code class="language-xml">&lt;!-- 配置对Java工程pro01-maven-java的依赖 --&gt;
&lt;!-- 具体的配置方式：在dependency标签内使用坐标实现依赖 --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;
	&lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt;
	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="在web工程中编写测试代码">在Web工程中，编写测试代码</h4>
<h5 id="补充创建代码">补充创建代码</h5>
<p>pro02-maven-web**\src\test\java\com\atguigu\maven**</p>
<h5 id="确定web工程依赖了junit">确定Web工程依赖了junit</h5>
<pre><code class="language-xml">    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.12&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
</code></pre>
<h5 id="创建测试类">创建测试类</h5>
<p>把 Java工程的 CalculatorTest.java 类复制到 pro02-maven-wb**\src\test\java\com\atguigu\maven** 目录下</p>
<h4 id="执行maven命令">执行Maven命令</h4>
<h5 id="测试命令">测试命令</h5>
<p>mvn test</p>
<p>说明：测试操作中会提前自动执行编译操作，测试成功就说明编译也是成功的。</p>
<h5 id="打包命令">打包命令</h5>
<p>mvn package</p>
<figure data-type="image" tabindex="14"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img024.91b00e04.png" alt="img024.91b00e04" loading="lazy"></figure>
<p>通过查看 war 包内的结构，我们看到被 Web 工程依赖的 Java 工程确实是会变成 Web 工程的 WEB-INF/lib 目录下的 jar 包。</p>
<figure data-type="image" tabindex="15"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/download7.png" alt="download7" loading="lazy"></figure>
<h5 id="查看当前-web-工程所依赖的-jar-包的列表">查看当前 Web 工程所依赖的 jar 包的列表</h5>
<p>mvn dependency:list</p>
<blockquote>
<p>[INFO] The following files have been resolved:<br>
[INFO] org.hamcrest:hamcrest-core:jar:1.3:test<br>
[INFO] javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>
[INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile<br>
[INFO] junit:junit:jar:4.12:test</p>
</blockquote>
<p>说明：javax.servlet:javax.servlet-api:jar:3.1.0:provided 格式显示的是一个 jar 包的坐标信息。格式是：</p>
<blockquote>
<p>groupId:artifactId:打包方式:version:依赖的范围</p>
</blockquote>
<p>这样的格式虽然和我们 XML 配置文件中坐标的格式不同，但是本质上还是坐标信息，需要能够认识这样的格式，将来从 Maven 命令的日志或错误信息中看到这样格式的信息，就能够识别出来这是坐标。进而根据坐标到Maven 仓库找到对应的jar包，用这样的方式解决我们遇到的报错的情况。</p>
<h5 id="以树形结构查看当前-web-工程的依赖信息">以树形结构查看当前 Web 工程的依赖信息</h5>
<p>mvn dependency:tree</p>
<blockquote>
<p>[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT<br>
[INFO] +- junit:junit:jar:4.12:test<br>
[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>
[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>
[INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</p>
</blockquote>
<p>我们在 pom.xml 中并没有依赖 hamcrest-core，但是它却被加入了我们依赖的列表。原因是：junit 依赖了hamcrest-core，然后基于依赖的传递性，hamcrest-core 被传递到我们的工程了。</p>
<h3 id="依赖的范围">依赖的范围</h3>
<h4 id="依赖范围">依赖范围</h4>
<p>标签的位置：dependencies/dependency/scope</p>
<p>标签的可选值：compile/test/provided/system/runtime/import</p>
<h5 id="compile和test对比">compile和Test对比</h5>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">main目录（空间）</th>
<th style="text-align:center">test目录（空间）</th>
<th style="text-align:center">开发过程（时间）</th>
<th style="text-align:center">部署到服务器（时间）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">test</td>
<td style="text-align:center">无效</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">无效</td>
</tr>
</tbody>
</table>
<h5 id="compile和provided对比">compile和provided对比</h5>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">main目录（空间）</th>
<th style="text-align:center">test目录（空间）</th>
<th style="text-align:center">开发过程（时间）</th>
<th style="text-align:center">部署到服务器（时间）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td style="text-align:center">provided</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">无效</td>
</tr>
</tbody>
</table>
<h5 id="结论">结论</h5>
<p>compile：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</p>
<p>test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。</p>
<p>provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。</p>
<h4 id="测试">测试</h4>
<h5 id="验证-compile-范围对-main-目录有效">验证 compile 范围对 main 目录有效</h5>
<blockquote>
<p>main目录下的类：HelloServlet 使用compile范围导入的依赖：pro01-atguigu-maven</p>
<p>验证：使用compile范围导入的依赖对main目录下的类来说是有效的</p>
<p>有效：HelloServlet 能够使用 pro01-atguigu-maven 工程中的 Calculator 类</p>
<p>验证方式：在 HelloServlet 类中导入 Calculator 类，然后编译就说明有效。</p>
</blockquote>
<h5 id="验证test范围对main目录无效">验证test范围对main目录无效</h5>
<p>测试方式：在主体程序中导入org.junit.Test这个注解，然后执行编译。</p>
<p>具体操作：在pro01-maven-java\src\main\java\com\atguigu\maven目录下修改Calculator.java</p>
<pre><code class="language-java">package com.atguigu.maven;

import org.junit.Test;

public class Calculator {
	
	public int sum(int i, int j){
		return i + j;
	}
	
}
</code></pre>
<p>执行Maven编译命令</p>
<pre><code class="language-java">[ERROR] /D:/maven-workspace/space201026/pro01-maven-java/src/main/java/com/atguigu/maven/Calculator.java:[3,17] 程序包org.junit不存在
</code></pre>
<h5 id="验证test和provided范围不参与服务器部署">验证test和provided范围不参与服务器部署</h5>
<p>通过compile范围依赖的jar包会放入war包，通过test范围依赖的jar包不会放入war包。</p>
<figure data-type="image" tabindex="16"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img026.0ad36150.png" alt="img026.0ad36150" loading="lazy"></figure>
<h5 id="验证provided范围对测试程序有效">验证provided范围对测试程序有效</h5>
<p>测试方式是在pro02-maven-web的测试程序中加入servlet-api.jar包中的类</p>
<p>修改：<strong>pro02-maven-web</strong>\src\test**\java\com\atguigu\maven*<em>CalculatorTest.java</em>*</p>
<pre><code class="language-java">package com.atguigu.maven;

import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.ServletException;

import org.junit.Test;
import com.atguigu.maven.Calculator;

// 静态导入的效果是将Assert类中的静态资源导入当前类
// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名
import static org.junit.Assert.*;

public class CalculatorTest{
	
	@Test
	public void testSum(){
		
		// 1.创建Calculator对象
		Calculator calculator = new Calculator();
		
		// 2.调用Calculator对象的方法，获取到程序运行实际的结果
		int actualResult = calculator.sum(5, 3);
		
		// 3.声明一个变量，表示程序运行期待的结果
		int expectedResult = 8;
		
		// 4.使用断言来判断实际结果和期待结果是否一致
		// 如果一致：测试通过，不会抛出异常
		// 如果不一致：抛出异常，测试失败
		assertEquals(expectedResult, actualResult);
		
	}
	
}
</code></pre>
<p>运行Maven的编译命令：mvn compile</p>
<h3 id="依赖的传递性">依赖的传递性</h3>
<h4 id="概念">概念</h4>
<p>A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？</p>
<h4 id="传递的原则">传递的原则</h4>
<p>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。</p>
<ul>
<li>B 依赖 C 时使用 compile 范围：可以传递</li>
<li>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</li>
</ul>
<h4 id="使用compile范围的依赖spring-core">使用compile范围的依赖spring-core</h4>
<p>测试方式：让 pro01-maven-java 工程依赖 spring-core</p>
<p>具体操作：编辑 pro01-maven-java 工程根目录下 pom.xml</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.springframework&lt;/groupId&gt;
	&lt;artifactId&gt;spring-core&lt;/artifactId&gt;
	&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>使用 mvn dependency:tree 命令查看效果：</p>
<blockquote>
<p>[INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT<br>
[INFO] +- junit:junit:jar:4.12:test<br>
[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>
[INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile<br>
[INFO] - commons-logging:commons-logging:jar:1.1.1:compile</p>
</blockquote>
<p>还可以在 Web 工程中，使用 mvn dependency:tree 命令查看效果（需要重新将 pro01-maven-java 安装到仓库）：</p>
<blockquote>
<p>[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT<br>
[INFO] +- junit:junit:jar:4.12:test<br>
[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>
[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>
[INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile<br>
[INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile<br>
[INFO] - commons-logging:commons-logging:jar:1.1.1:compile</p>
</blockquote>
<h4 id="验证-test-和-provided-范围不能传递">验证 test 和 provided 范围不能传递</h4>
<p>从上面的例子已经能够看到，pro01-maven-java 依赖了 junit，但是在 pro02-maven-web 工程中查看依赖树的时候并没有看到 junit。</p>
<p>要验证 provided 范围不能传递，可以在 pro01-maven-java 工程中加入 servlet-api 的依赖。</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
	&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
	&lt;version&gt;3.1.0&lt;/version&gt;
	&lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>效果还是和之前一样：</p>
<blockquote>
<p>[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT<br>
[INFO] +- junit:junit:jar:4.12:test<br>
[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>
[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>
[INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile<br>
[INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile<br>
[INFO] - commons-logging:commons-logging:jar:1.1.1:compile</p>
</blockquote>
<h3 id="依赖的排除">依赖的排除</h3>
<h5 id="概念-2">概念</h5>
<p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是为了避免 jar 包之间的冲突。</p>
<p><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img027.2faff879.png" alt="img027.2faff879" loading="lazy">所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。</p>
<h5 id="配置方式">配置方式</h5>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;
	&lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt;
	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
	&lt;scope&gt;compile&lt;/scope&gt;
	&lt;!-- 使用excludes标签配置依赖的排除	--&gt;
	&lt;exclusions&gt;
		&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;
		&lt;exclusion&gt;
			&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;
			&lt;groupId&gt;commons-logging&lt;/groupId&gt;
			&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
		&lt;/exclusion&gt;
	&lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="测试-2">测试</h5>
<p>测试的方式：在 pro02-maven-web 工程中配置对 commons-logging 的排除</p>
<pre><code class="language-xml">&lt;dependency&gt;
	&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;
	&lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt;
	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
	&lt;scope&gt;compile&lt;/scope&gt;
	&lt;!-- 使用excludes标签配置依赖的排除	--&gt;
	&lt;exclusions&gt;
		&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;
		&lt;exclusion&gt;
			&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;
			&lt;groupId&gt;commons-logging&lt;/groupId&gt;
			&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
		&lt;/exclusion&gt;
	&lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre>
<p>运行 mvn dependency:tree 命令查看效果：</p>
<blockquote>
<p>[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT<br>
[INFO] +- junit:junit:jar:4.12:test<br>
[INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test<br>
[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided<br>
[INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile<br>
[INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile</p>
</blockquote>
<p>发现在 spring-core 下面就没有 commons-logging 了。</p>
<h3 id="继承">继承</h3>
<h4 id="概念-3">概念</h4>
<p>Maven工程之间，A 工程继承 B 工程</p>
<ul>
<li>B 工程：父工程</li>
<li>A 工程 ：子工程</li>
</ul>
<p>本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置。</p>
<h4 id="作用">作用</h4>
<p>在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。</p>
<p>背景</p>
<ul>
<li>对一个比较大型的项目进行了模块拆分。</li>
<li>一个 project 下面，创建了很多个 module。</li>
<li>每一个 module 都需要配置自己的依赖信息。</li>
</ul>
<p>背后的需求</p>
<ul>
<li>在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li>
<li>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</li>
<li>使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。</li>
</ul>
<p>通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的 jar 包</strong>；又能够将<strong>以往的经验沉淀</strong>下来，节约时间和精力。</p>
<h4 id="举例">举例</h4>
<p>在一个工程中依赖多个 Spring 的 jar 包</p>
<blockquote>
<p>[INFO] +- org.springframework:<strong>spring-core</strong>:jar:<strong>4.0.0</strong>.RELEASE:compile<br>
[INFO] | - commons-logging:commons-logging:jar:1.1.1:compile<br>
[INFO] +- org.springframework:<strong>spring-beans</strong>:jar:<strong>4.0.0</strong>.RELEASE:compile<br>
[INFO] +- org.springframework:<strong>spring-context</strong>:jar:<strong>4.0.0</strong>.RELEASE:compile<br>
[INFO] +- org.springframework:<strong>spring-expression</strong>:jar:4.0.0.RELEASE:compile<br>
[INFO] +- org.springframework:<strong>spring-aop</strong>:jar:<strong>4.0.0</strong>.RELEASE:compile<br>
[INFO] | - aopalliance:aopalliance:jar:1.0:compile</p>
</blockquote>
<p>使用 Spring 时要求所有 Spring 自己的 jar 包版本必须一致。为了能够对这些 jar 包的版本进行统一管理，我们使用继承这个机制，将所有版本信息统一在父工程中进行管理。</p>
<h4 id="操作-3">操作</h4>
<h5 id="创建父工程">创建父工程</h5>
<p>创建的过程和前面创建 pro01-maven-java 一样。</p>
<p>工程名称：pro03-maven-parent</p>
<p>修改它的打包方式：</p>
<pre><code class="language-xml">&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;
  &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

  &lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
</code></pre>
<p>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。</p>
<h5 id="创建模块工程">创建模块工程</h5>
<p>模块工程类似于 IDEA 中的 module，所以需要<strong>进入 pro03-maven-parent 工程的根目录</strong>，然后运行 mvn archetype:generate 命令来创建模块工程。</p>
<p>假设，创建三个模块工程：</p>
<figure data-type="image" tabindex="17"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/download8.png" alt="download8" loading="lazy"></figure>
<h3 id="查看被添加新内容的父工程-pomxml">查看被添加新内容的父工程 pom.xml</h3>
<p>下面 modules 和 module 标签是聚合功能的配置</p>
<pre><code class="language-xml">&lt;modules&gt;  
	&lt;module&gt;pro04-maven-module&lt;/module&gt;
	&lt;module&gt;pro05-maven-module&lt;/module&gt;
	&lt;module&gt;pro06-maven-module&lt;/module&gt;
&lt;/modules&gt;
</code></pre>
<h5 id="解读子工程的pomxml">解读子工程的pom.xml</h5>
<pre><code class="language-xml">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;
&lt;parent&gt;
	&lt;!-- 父工程的坐标 --&gt;
	&lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt;
	&lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt;
	&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/parent&gt;

&lt;!-- 子工程的坐标 --&gt;
&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;
&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;
&lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt;
&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;
</code></pre>
<h5 id="在父工程中配置依赖的统一管理">在父工程中配置依赖的统一管理</h5>
<pre><code class="language-xml">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;
&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;
&lt;dependencyManagement&gt;
	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-core&lt;/artifactId&gt;
			&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
			&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
			&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
			&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
			&lt;version&gt;4.0.0.RELEASE&lt;/version&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<h5 id="子工程中引用那些被父工程管理的依赖">子工程中引用那些被父工程管理的依赖</h5>
<p>关键点：省略版本号</p>
<pre><code class="language-xml">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。	--&gt;
&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;
&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;
&lt;dependencies&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-core&lt;/artifactId&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-expression&lt;/artifactId&gt;
	&lt;/dependency&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework&lt;/groupId&gt;
		&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h5 id="在父工程中升级依赖信息的版本">在父工程中升级依赖信息的版本</h5>
<pre><code class="language-xml">……
			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework&lt;/groupId&gt;
				&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
				&lt;version&gt;4.1.4.RELEASE&lt;/version&gt;
			&lt;/dependency&gt;
……
</code></pre>
<h5 id="在父工程中声明自定义属性">在父工程中声明自定义属性</h5>
<pre><code class="language-xml">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;
&lt;properties&gt;
	&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
	
	&lt;!-- 自定义标签，维护Spring版本数据 --&gt;
	&lt;atguigu.spring.version&gt;4.3.6.RELEASE&lt;/atguigu.spring.version&gt;
&lt;/properties&gt;
</code></pre>
<p>在需要的地方使用${}的形式来引用自定义的属性名：</p>
<pre><code class="language-xml">			&lt;dependency&gt;
				&lt;groupId&gt;org.springframework&lt;/groupId&gt;
				&lt;artifactId&gt;spring-core&lt;/artifactId&gt;
				&lt;version&gt;${atguigu.spring.version}&lt;/version&gt;
			&lt;/dependency&gt;
</code></pre>
<p>真正实现“一处修改，处处生效”。</p>
<h4 id="实际意义">实际意义</h4>
<figure data-type="image" tabindex="18"><img src="https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/img037.53c95c38.jpg" alt="img037.53c95c38" loading="lazy"></figure>
<p>编写一套符合要求、开发各种功能都能正常工作的依赖组合并不容易。如果公司里已经有人总结了成熟的组合方案，那么再开发新项目时，如果不使用原有的积累，而是重新摸索，会浪费大量的时间。为了提高效率，我们可以使用工程继承的机制，让成熟的依赖组合方案能够保留下来。</p>
<p>如上图所示，公司级的父工程中管理的就是成熟的依赖组合方案，各个新项目、子系统各取所需即可。</p>
<h3 id="聚合">聚合</h3>
<h4 id="maven-中的聚合">Maven 中的聚合</h4>
<p>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。</p>
<ul>
<li>项目 : 整体</li>
<li>模块 : 部分</li>
</ul>
<blockquote>
<h5 id="tip">TIP</h5>
<p>概念的对应关系：</p>
<p>从继承关系角度来看：</p>
<ul>
<li>父工程</li>
<li>子工程</li>
</ul>
<p>从聚合关系角度来看：</p>
<ul>
<li>总工程</li>
<li>模块工程</li>
</ul>
</blockquote>
<h4 id="好处">好处</h4>
<ul>
<li>
<p>一键执行 Maven 命令：很多构建命令都可以在“总工程”中一键执行。</p>
<p>以 mvn install 命令为例：Maven 要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是工程聚合之后，在总工程执行 mvn install 可以一键完成安装，而且会自动按照正确的顺序执行。</p>
</li>
<li>
<p>配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然。</p>
</li>
</ul>
<h4 id="聚合的配置">聚合的配置</h4>
<p>在总工程的modules即可</p>
<pre><code class="language-xml">	&lt;modules&gt;  
		&lt;module&gt;pro04-maven-module&lt;/module&gt;
		&lt;module&gt;pro05-maven-module&lt;/module&gt;
		&lt;module&gt;pro06-maven-module&lt;/module&gt;
	&lt;/modules&gt;
</code></pre>
<h4 id="依赖循环问题">依赖循环问题</h4>
<p>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误：</p>
<blockquote>
<h4 id="danger">DANGER</h4>
<p>[ERROR] [ERROR] The projects in the reactor contain a cyclic reference:</p>
</blockquote>
<p>这个错误的含义是：循环引用。</p>
<blockquote>
<h3 id="补充">补充</h3>
<pre><code class="language-sh"># -D 表示后面要附加命令的参数，字母 D 和后面的参数是紧挨着的，中间没有任何其它字符
# maven.test.skip=true 表示在执行命令的过程中跳过测试
mvn clean install -Dmaven.test.skip=true
</code></pre>
</blockquote>
<h2 id="其他核心概念">其他核心概念</h2>
<h3 id="生命周期">生命周期</h3>
<h4 id="作用-2">作用</h4>
<p>为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。</p>
<h4 id="三个生命周期">三个生命周期</h4>
<table>
<thead>
<tr>
<th style="text-align:center">生命周期名称</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">各个环节</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Clean</td>
<td style="text-align:center">清理操作相关</td>
<td style="text-align:center">pre-clean<br/>clean<br/>post-clean</td>
</tr>
<tr>
<td style="text-align:center">Site</td>
<td style="text-align:center">生成站点相关</td>
<td style="text-align:center">pre-site<br/>site<br/>post-site<br/>deploy-site</td>
</tr>
<tr>
<td style="text-align:center">Default</td>
<td style="text-align:center">主要构建过程</td>
<td style="text-align:center">validate<br/>generate-sources<br/>process-sources<br/>generate-resources<br/>process-resources 复制并处理资源文件，至目标目录，准备打包。<br/>compile 编译项目 main 目录下的源代码。<br/>process-classes<br/>generate-test-sources<br/>process-test-sources<br/>generate-test-resources<br/>process-test-resources 复制并处理资源文件，至目标测试目录。<br/>test-compile 编译测试源代码。<br/>process-test-classes<br/>test 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。<br/>prepare-package<br/>package 接受编译好的代码，打包成可发布的格式，如JAR。<br/>pre-integration-test<br/>integration-test<br/>post-integration-test<br/>verify<br/>install将包安装至本地仓库，以让其它项目依赖。<br/>deploy将最终的包复制到远程的仓库，以让其它开发人员共享；或者部署到服务器上运行（需借助插件，例如：cargo）。</td>
</tr>
</tbody>
</table>
<h4 id="特点">特点</h4>
<ul>
<li>前面三个生命周期彼此是独立的。</li>
<li>在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。（本节记住这句话就行了，其他的都不需要记）</li>
</ul>
<p>Maven 之所以这么设计其实就是为了提高构建过程的自动化程度：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。</p>
<h3 id="插件和目标">插件和目标</h3>
<h4 id="插件">插件</h4>
<p>Maven 的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p>
<h4 id="目标">目标</h4>
<p>一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。</p>
<p>Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。</p>
<h3 id="仓库">仓库</h3>
<ul>
<li>本地仓库：在当前电脑上，为电脑上所有 Maven 工程服务</li>
<li>远程仓库：需要联网
<ul>
<li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li>
<li>Internet
<ul>
<li>中央仓库</li>
<li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>建议：不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突。</p>
<p>专门搜索 Maven 依赖信息的网站：https://mvnrepository.com/</p>

                </div>
                <div class="clear"></div>
              </section>
            </article>
            <div class="clear"></div>

            <section class="related section">
              
              
              <article class="next grid-50 tablet-grid-50 grid-parent">
                <div class="thumb cover lazy loaded" style="background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/お豆腐_99167071.jpg');"></div>
                 <a href="https://nanteng.github.io/post/ssm-zheng-he/" class="full-link"></a>
                 <div class="info">
                  <time datetime="2022-11-15">2022-11-15</time>
                  <h4 class="title white no-margin">SSM整合</h4>
                </div>
                 <span class="epcl-button red">
                  <img src="https://nanteng.github.io/media/images/right-arrow.svg" width="15" alt="Left Arrow">
                </span>
                <div class="overlay"></div>
              </article>
              

                <div class="clear"></div>
            </section>

              <div class="clear"></div>
              
            
              <div id="comments" class="bg-white hosted ">
                <div class="clear"></div>
<script>
jQuery(document).ready(function($){
    $('.vemoji-btn').text('😀');
    $("#comments").on('click', 'span.vat',function(){
        $(this).parent('div.vmeta').next("div.vcontent").after($("div.vwrap"));
        $('textarea#veditor').focus();
    })
    if(window.location.hash){
        var checkExist = setInterval(function() {
            if ($(window.location.hash).length) {
                $('html, body').animate({scrollTop: $(window.location.hash).offset().top-200}, 600);
                clearInterval(checkExist);
            }
        }, 100);
    }
})
</script>

              </div>
            

            </div>
          </div>
      </main>

          <footer id="footer" class="grid-container">
        <div class="widgets row gradient-effect">
            <div class="default-sidebar border-effect">
              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="tag_cloud-2" class="widget widget_epcl_posts_thumbs underline-effect">
                  <h4 class="widget-title title white bordered">最新文章</h4>
                  
                  
                  <article class="item post-0 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://nanteng.github.io/post/mavenbasics/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/tumblr_b38009612775acb3f606c15e4ca4cfb0_9b8bb164_1280.png');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2022-11-16">2022-11-16</time>
                      <h4 class="title usmall">
                        <a href="https://nanteng.github.io/post/mavenbasics/">MavenBasics</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  <article class="item post-1 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://nanteng.github.io/post/ssm-zheng-he/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/お豆腐_99167071.jpg');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2022-11-15">2022-11-15</time>
                      <h4 class="title usmall">
                        <a href="https://nanteng.github.io/post/ssm-zheng-he/">SSM整合</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  <article class="item post-2 post type-post status-publish format-standard has-post-thumbnail hentry">
                    <a href="https://nanteng.github.io/post/springmvc/" class="thumb hover-effect">
                      <span class="fullimage cover" style="display:block;border-radius:50%;background-image: url('https://dearkai.oss-cn-beijing.aliyuncs.com/typora-img/20221112_004658.jpg');"></span>
                    </a>
                    <div class="info gradient-effect">
                      <time datetime="2022-11-15">2022-11-15</time>
                      <h4 class="title usmall">
                        <a href="https://nanteng.github.io/post/springmvc/">SpringMVC</a>
                      </h4>
                    </div>
                    <div class="clear"></div>
                  </article>
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  
                  <div class="clear"></div>
                </section>
              </div>

              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="tag_cloud-2" class="widget widget_tag_cloud underline-effect">
                  <h4 class="widget-title title white bordered">标签云</h4>
                  <div class="tagcloud">
                    
                      <a href="https://nanteng.github.io/tag/TtKdK6ur-/" class="ctag ctag-0 ctag-TtKdK6ur-" aria-label="">Java</a>
                    
                      <a href="https://nanteng.github.io/tag/Pb31zuZQs/" class="ctag ctag-1 ctag-Pb31zuZQs" aria-label="">诗歌</a>
                    
                      <a href="https://nanteng.github.io/tag/wFMTkH_sNe/" class="ctag ctag-2 ctag-wFMTkH_sNe" aria-label="">日记</a>
                    
                      <a href="https://nanteng.github.io/tag/q1drPjJv3/" class="ctag ctag-3 ctag-q1drPjJv3" aria-label="">随笔</a>
                    
                      <a href="https://nanteng.github.io/tag/eSKuLZlYEN/" class="ctag ctag-4 ctag-eSKuLZlYEN" aria-label="">Linux</a>
                    
                      <a href="https://nanteng.github.io/tag/i9Zqgezw0Q/" class="ctag ctag-5 ctag-i9Zqgezw0Q" aria-label="">体验</a>
                    
                      <a href="https://nanteng.github.io/tag/VxnVWpClHS/" class="ctag ctag-6 ctag-VxnVWpClHS" aria-label="">软件</a>
                    
                      <a href="https://nanteng.github.io/tag/1DZ-nCoLTA/" class="ctag ctag-7 ctag-1DZ-nCoLTA" aria-label="">信件</a>
                    
                      <a href="https://nanteng.github.io/tag/Fcf3eo9iSf/" class="ctag ctag-8 ctag-Fcf3eo9iSf" aria-label="">CentOS</a>
                    
                  </div>
                  <div class="clear"></div>
                </section>
              </div>

              <div class="grid-33 tablet-grid-50 mobile-grid-100">
                <section id="epcl_about-2" class="widget widget_epcl_about underline-effect">
                  <h4 class="widget-title title white bordered">关于我</h4>
                  <div class="avatar">
                    <a href="" class="translate-effect thumb"><span class="fullimage cover" style="background-image: url(https://nanteng.github.io/images/avatar.png);"></span></a>
                  </div>
                  <div class="info">
                    <h4 class="title small author-name gradient-effect no-margin"><a href="">南藤北玄参</a></h4>
                    <p class="founder">唯沉默为最高的轻蔑</p>
                    <div class="social">
                      
                          
                            <a href="https://github.com/NanTeng" class="translate-effect" target="_blank"><i class="fa fa-github"></i></a>
                        
                      
                          
                            <a href="https://twitter.com/NanTeng418" class="translate-effect" target="_blank"><i class="fa fa-twitter"></i></a>
                        
                      
                        
                      
                          
                            <a href="https://t.me/NanTeng" class="translate-effect" target="_blank"><i class="fa fa-telegram"></i></a>
                        
                      
                        
                      
                    </div> 
                  </div>
                  <div class="clear"></div>
                  </section>
              </div>

            </div>
            <div class="clear"></div>
        </div>

        <div class="logo">
          <a href="https://nanteng.github.io"><img src="\media\images\custom-footerLogo.gif" alt=""></a>
        </div>
        <p class="published border-effect">
          ©2019 共 28 篇文章
          <br/>
          Theme <a href="https://gridea.dev/" target="_blank">「breek」</a> Powered by <a href="https://gridea.dev/" target="_blank">「Gridea」</a>
        </p>
        
        <a href="javascript:void(0)" id="back-to-top" class="epcl-button dark" style="display:none">
          <i class="fa fa-arrow"></i>
        </a>
    </footer>
    
    <div class="clear"></div>

        
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/leancloud-storage/dist/av-min.js"></script>
<script type="text/javascript" src="https://cdn.staticfile.org/valine/1.3.10/Valine.Pure.min.js"></script>
<script>
    new Valine({
        el: '#comments',
        appId: 'JCYzcWAfC7BkMZHJ3hrKx85t-gzGzoHsz' ,
        appKey: 'r89Wpg7b2oYFtiu1JGnthBzN',
        pageSize: 30,
        placeholder: '既然来了，那就留个痕迹吧~',
        visitor: true // 阅读量统计
    })
</script>
    

      
    <script src="https://nanteng.github.io/media/js/functions-post.js"></script>

    </div>
    <!-- end: #wrapper -->
  </body>
</html>
