{"posts":[{"title":"MavenBasics","content":"Maven 作为依赖管理工具 ​ 管理规模庞大的 jar 包，需要专门工具。 Maven 作为构建管理工具 ​ 脱离 IDE 环境执行构建操作，需要专门工具。 什么是Maven 构建 构建过程包含的主要环节 清理：删除上一次构建的结果，为下一次构建做准备 编译 测试 报告 打包 Java工程：jar包 Web工程：war包 安装：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入Maven的本地仓库 部署 部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上 部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上 依赖 依赖管理中要解决的具体问题： jar 包的下载：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地 jar 包之间的依赖：通过依赖的传递性自动完成 jar 包之间的冲突：通过对依赖的配置进行调整，让某些jar包不会被导入 Maven的工作机制 核心程序的配置 指定本地仓库 本地仓库默认值：用户家目录/.m2/repository。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中 jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以建议将 Maven 的本地仓库放在其他盘符下。配置方式如下： &lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; --&gt; &lt;localRepository&gt;D:\\maven-repository&lt;/localRepository&gt; 本地仓库这个目录，我们手动创建一个空的目录即可。 记住：一定要把 localRepository 标签从注释中拿出来。 注意：本地仓库本身也需要使用一个非中文、没有空格的目录。 配置阿里云提供的镜像仓库 Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。改成阿里云提供的镜像仓库，访问国内网站，可以让 Maven 下载 jar 包的时候速度更快。配置的方式是： ①将原有的例子配置注释掉 &lt;!-- &lt;mirror&gt; &lt;id&gt;maven-default-http-blocker&lt;/id&gt; &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt; &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt; &lt;url&gt;http://0.0.0.0/&lt;/url&gt; &lt;blocked&gt;true&lt;/blocked&gt; &lt;/mirror&gt; --&gt; 加入阿里云的配置镜像源 &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 配置 Maven 工程的基础 JDK 版本 如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：将 profile 标签整个复制到 settings.xml 文件的 profiles 标签内。 &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 配置验证环境变量 ~ 在windows cmd控制台输入验证查看是否配置成功 mvn -v Maven:命令行 根据坐标创建Maven工程 使用三个『向量』在『Maven的仓库』中唯一的定位到一个『jar』包。 groupId: 公司或组织的id artifactId: 一个项目或是项目中的一个模块的id version: 版本号 三个“量”的取值方式 groupId：公司或组织域名的倒序，通常也会加上项目名称 例如：com.atguigu.maven artifactId：模块的名称，将来作为 Maven 工程的工程名 version：模块的版本号，根据自己的需要设定 例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本 例如：RELEASE 表示正式版本 坐标和仓库中 jar 包的存储路径之间的对应关系 坐标 &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; 上面坐标对应的 jar 包在 Maven 本地仓库中的位置： Maven本地仓库根目录\\javax\\servlet\\servlet-api\\2.5\\servlet-api-2.5.jar 使用命令生成Maven工程 运行 mvn archetype:generate命令 提示操作 Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:【直接回车，使用默认值】 Define value for property 'groupId': com.atguigu.maven Define value for property 'artifactId': pro01-maven-java Define value for property 'version' 1.0-SNAPSHOT: :【直接回车，使用默认值】 Define value for property 'package' com.atguigu.maven: :【直接回车，使用默认值】 Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro01-maven-java version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认。如果前面有输入错误，想要重新输入，则输入 N 再回车。】 调整 Maven 默认生成的工程，对 junit 依赖的是较低的 3.8.1 版本，我们可以改成较适合的 4.12 版本。 &lt;!-- 依赖信息配置 --&gt; &lt;!-- dependencies复数标签：里面包含dependency单数标签 --&gt; &lt;dependencies&gt; &lt;!-- dependency单数标签：配置一个具体的依赖 --&gt; &lt;dependency&gt; &lt;!-- 通过坐标来依赖其他jar包 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!-- 依赖的范围 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 自动生成的 pom.xml 解读 &lt;!-- 当前Maven工程的坐标 --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt; &lt;!-- jar：表示这个工程是一个Java工程 --&gt; &lt;!-- war：表示这个工程是一个Web工程 --&gt; &lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;pro01-maven-java&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;!-- 当前工程所依赖的jar包 --&gt; &lt;dependencies&gt; &lt;!-- 使用dependency配置一个具体的依赖 --&gt; &lt;dependency&gt; &lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!-- scope标签配置依赖的范围 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; POM 含义 POM：Project Object Model，项目对象模型。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。 模型化思想 POM 表示将工程抽象为一个模型，再用程序中的对象来描述这个模型。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据。 对应的配置文件 POM 理念集中体现在 Maven 工程根目录下 pom.xml 这个配置文件中。所以这个 pom.xml 配置文件就是 Maven 工程的核心配置文件。其实学习 Maven 就是学这个文件怎么配置，各个配置有什么用。 约定目录结构 各个目录的作用 另外还有一个 target 目录专门存放构建操作输出的结果。 约定目录结构的意义 Maven 为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用。例如：Maven 执行编译操作，必须先去 Java 源程序目录读取 Java 源代码，然后执行编译，最后把编译结果存放在 target 目录。 约定大于配置 Maven 对于目录结构这个问题，没有采用配置的方式，而是基于约定。这样会让我们在开发过程中非常方便。如果每次创建 Maven 工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。 目前开发领域的技术发展趋势就是：约定大于配置，配置大于编码。 在Maven工程中编写代码 主体程序 主体程序指的是被测试的程序，同时也是将来在项目中真正要使用的程序。 package com.atguigu.maven; public class Calculator { public int sum(int i, int j){ return i + j; } } 测试程序 package com.atguigu.maven; import org.junit.Test; import com.atguigu.maven.Calculator; // 静态导入的效果是将Assert类中的静态资源导入当前类 // 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名 import static org.junit.Assert.*; public class CalculatorTest{ @Test public void testSum(){ // 1.创建Calculator对象 Calculator calculator = new Calculator(); // 2.调用Calculator对象的方法，获取到程序运行实际的结果 int actualResult = calculator.sum(5, 3); // 3.声明一个变量，表示程序运行期待的结果 int expectedResult = 8; // 4.使用断言来判断实际结果和期待结果是否一致 // 如果一致：测试通过，不会抛出异常 // 如果不一致：抛出异常，测试失败 assertEquals(expectedResult, actualResult); } } 执行 Maven 的构建命令 要求 运行 Maven 中和构建操作相关的命令时，必须进入到 pom.xml 所在的目录。如果没有在 pom.xml 所在的目录运行 Maven 的构建命令，那么会看到下面的错误信息： The goal you specified requires a project to execute but there is no POM in this directory mvn -v 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录。 清理操作 mvn clean 效果：删除 target 目录 编译操作 主程序编译：mvn compile 测试程序编译：mvn test-compile 主体程序编译结果存放的目录：target/classes 测试程序编译结果存放的目录：target/test-classes 测试操作 4、测试操作 打包操作 mvn package 打包的结果——jar 包，存放的目录：target 安装操作 mvn install [INFO] Installing D:\\maven-workspace\\space201026\\pro01-maven-java\\target\\pro01-maven-java-1.0-SNAPSHOT.jar to D:\\maven-rep1026\\com\\atguigu\\maven\\pro01-maven-java\\1.0-SNAPSHOT\\pro01-maven-java-1.0-SNAPSHOT.jar [INFO] Installing D:\\maven-workspace\\space201026\\pro01-maven-java\\pom.xml to D:\\maven-rep1026\\com\\atguigu\\maven\\pro01-maven-java\\1.0-SNAPSHOT\\pro01-maven-java-1.0-SNAPSHOT.pom 安装的效果是将本地构建过程中生成的 jar 包存入 Maven 本地仓库。这个 jar 包在 Maven 仓库中的路径是根据它的坐标生成的。 坐标信息如下： &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 坐标信息如下： D:\\maven-rep1026\\com\\atguigu\\maven\\pro01-maven-java\\1.0-SNAPSHOT\\pro01-maven-java-1.0-SNAPSHOT.jar 另外，安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。 创建Maven版的Web工程 说明 使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。这个专门生成 Web 工程骨架的 archetype 可以参照官网看到它的用法： 参数 archetypeGroupId、archetypeArtifactId、archetypeVersion 用来指定现在使用的 maven-archetype-webapp 的坐标。 操作 注意：如果在上一个工程的目录下执行 mvn archetype:generate 命令，那么 Maven 会报错：不能在一个非 pom 的工程下再创建其他工程。所以不要再刚才创建的工程里再创建新的工程，请回到工作空间根目录来操作。 然后运行生成工程的命令： mvn archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.4 下面的操作按照提示执行： Define value for property 'groupId': com.atguigu.maven Define value for property 'artifactId': pro02-maven-web Define value for property 'version' 1.0-SNAPSHOT: :【直接回车，使用默认值】 Define value for property 'package' com.atguigu.maven: :【直接回车，使用默认值】 Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro02-maven-web version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认】 生成的pom.xml 确认打包的方式是war包形式 &lt;packaging&gt;war&lt;/packaging&gt; 生成的Web工程的目录结构 webapp 目录下有 index.jsp WEB-INF 目录下有 web.xml 创建 Servlet 在 main 目录下创建 java 目录 在 java 目录下创建 Servlet 类所在的包的目录 在包下创建 Servlet 类 package com.atguigu.maven; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.ServletException; import java.io.IOException; public class HelloServlet extends HttpServlet{ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.getWriter().write(&quot;hello maven web&quot;); } } 在 web.xml 中注册 Servlet &lt;servlet&gt; &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.maven.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;helloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 在 index.jsp 页面编写超链接 &lt;html&gt; &lt;body&gt; &lt;h2&gt;Hello World!&lt;/h2&gt; &lt;a href=&quot;helloServlet&quot;&gt;Access Servlet&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; TIP JSP全称是 Java Server Page，和 Thymeleaf 一样，是服务器端页面渲染技术。这里我们不必关心 JSP 语法细节，编写一个超链接标签即可。 编译 此时直接执行 mvn compile 命令出错： DANGER 程序包 javax.servlet.http 不存在 程序包 javax.servlet 不存在 找不到符号 符号: 类 HttpServlet …… 上面的错误信息说明：我们的 Web 工程用到了 HttpServlet 这个类，而 HttpServlet 这个类属于 servlet-api.jar 这个 jar 包。此时我们说，Web 工程需要依赖 servlet-api.jar 包。 配置对servlet-api.jar包的依赖 对于不知道详细信息的依赖可以到https://mvnrepository.com/网站查询。使用关键词搜索，然后在搜索结果列表中选择适合的使用。 比如，我们找到的 servlet-api 的依赖信息： &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 这样就可以把上面的信息加入 pom.xml。重新执行 mvn compile 命令。 将Web工程打包为war包 运行 mvn package 命令，生成 war 包的位置如下图所示： 将 war 包部署到 Tomcat 上运行 将 war 包复制到 Tomcat/webapps 目录下 启动Tomcat: 通过浏览器尝试访问：http://localhost:8080/pro02-maven-web/index.jsp 让Web工程依赖Java工程 观念 明确一个意识：从来只有 Web 工程依赖 Java 工程，没有反过来 Java 工程依赖 Web 工程。本质上来说，Web 工程依赖的 Java 工程其实就是 Web 工程里导入的 jar 包。最终 Java 工程会变成 jar 包，放在 Web 工程的 WEB-INF/lib 目录下。 操作 在 pro02-maven-web 工程的 pom.xml 中，找到 dependencies 标签，在 dependencies 标签中做如下配置： &lt;!-- 配置对Java工程pro01-maven-java的依赖 --&gt; &lt;!-- 具体的配置方式：在dependency标签内使用坐标实现依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; 在Web工程中，编写测试代码 补充创建代码 pro02-maven-web**\\src\\test\\java\\com\\atguigu\\maven** 确定Web工程依赖了junit &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 创建测试类 把 Java工程的 CalculatorTest.java 类复制到 pro02-maven-wb**\\src\\test\\java\\com\\atguigu\\maven** 目录下 执行Maven命令 测试命令 mvn test 说明：测试操作中会提前自动执行编译操作，测试成功就说明编译也是成功的。 打包命令 mvn package 通过查看 war 包内的结构，我们看到被 Web 工程依赖的 Java 工程确实是会变成 Web 工程的 WEB-INF/lib 目录下的 jar 包。 查看当前 Web 工程所依赖的 jar 包的列表 mvn dependency:list [INFO] The following files have been resolved: [INFO] org.hamcrest:hamcrest-core:jar:1.3:test [INFO] javax.servlet:javax.servlet-api:jar:3.1.0:provided [INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile [INFO] junit:junit:jar:4.12:test 说明：javax.servlet:javax.servlet-api:jar:3.1.0:provided 格式显示的是一个 jar 包的坐标信息。格式是： groupId:artifactId:打包方式:version:依赖的范围 这样的格式虽然和我们 XML 配置文件中坐标的格式不同，但是本质上还是坐标信息，需要能够认识这样的格式，将来从 Maven 命令的日志或错误信息中看到这样格式的信息，就能够识别出来这是坐标。进而根据坐标到Maven 仓库找到对应的jar包，用这样的方式解决我们遇到的报错的情况。 以树形结构查看当前 Web 工程的依赖信息 mvn dependency:tree [INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT [INFO] +- junit:junit:jar:4.12:test [INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test [INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided [INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile 我们在 pom.xml 中并没有依赖 hamcrest-core，但是它却被加入了我们依赖的列表。原因是：junit 依赖了hamcrest-core，然后基于依赖的传递性，hamcrest-core 被传递到我们的工程了。 依赖的范围 依赖范围 标签的位置：dependencies/dependency/scope 标签的可选值：compile/test/provided/system/runtime/import compile和Test对比 main目录（空间） test目录（空间） 开发过程（时间） 部署到服务器（时间） compile 有效 有效 有效 有效 test 无效 有效 有效 无效 compile和provided对比 main目录（空间） test目录（空间） 开发过程（时间） 部署到服务器（时间） compile 有效 有效 有效 有效 provided 有效 有效 有效 无效 结论 compile：通常使用的第三方框架的 jar 包这样在项目实际运行时真正要用到的 jar 包都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。 test：测试过程中使用的 jar 包，以 test 范围依赖进来。比如 junit。 provided：在开发过程中需要用到的“服务器上的 jar 包”通常以 provided 范围依赖进来。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担。 测试 验证 compile 范围对 main 目录有效 main目录下的类：HelloServlet 使用compile范围导入的依赖：pro01-atguigu-maven 验证：使用compile范围导入的依赖对main目录下的类来说是有效的 有效：HelloServlet 能够使用 pro01-atguigu-maven 工程中的 Calculator 类 验证方式：在 HelloServlet 类中导入 Calculator 类，然后编译就说明有效。 验证test范围对main目录无效 测试方式：在主体程序中导入org.junit.Test这个注解，然后执行编译。 具体操作：在pro01-maven-java\\src\\main\\java\\com\\atguigu\\maven目录下修改Calculator.java package com.atguigu.maven; import org.junit.Test; public class Calculator { public int sum(int i, int j){ return i + j; } } 执行Maven编译命令 [ERROR] /D:/maven-workspace/space201026/pro01-maven-java/src/main/java/com/atguigu/maven/Calculator.java:[3,17] 程序包org.junit不存在 验证test和provided范围不参与服务器部署 通过compile范围依赖的jar包会放入war包，通过test范围依赖的jar包不会放入war包。 验证provided范围对测试程序有效 测试方式是在pro02-maven-web的测试程序中加入servlet-api.jar包中的类 修改：pro02-maven-web\\src\\test**\\java\\com\\atguigu\\maven*CalculatorTest.java* package com.atguigu.maven; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.ServletException; import org.junit.Test; import com.atguigu.maven.Calculator; // 静态导入的效果是将Assert类中的静态资源导入当前类 // 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名 import static org.junit.Assert.*; public class CalculatorTest{ @Test public void testSum(){ // 1.创建Calculator对象 Calculator calculator = new Calculator(); // 2.调用Calculator对象的方法，获取到程序运行实际的结果 int actualResult = calculator.sum(5, 3); // 3.声明一个变量，表示程序运行期待的结果 int expectedResult = 8; // 4.使用断言来判断实际结果和期待结果是否一致 // 如果一致：测试通过，不会抛出异常 // 如果不一致：抛出异常，测试失败 assertEquals(expectedResult, actualResult); } } 运行Maven的编译命令：mvn compile 依赖的传递性 概念 A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？ 传递的原则 在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围。 B 依赖 C 时使用 compile 范围：可以传递 B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。 使用compile范围的依赖spring-core 测试方式：让 pro01-maven-java 工程依赖 spring-core 具体操作：编辑 pro01-maven-java 工程根目录下 pom.xml &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; 使用 mvn dependency:tree 命令查看效果： [INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT [INFO] +- junit:junit:jar:4.12:test [INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test [INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile [INFO] - commons-logging:commons-logging:jar:1.1.1:compile 还可以在 Web 工程中，使用 mvn dependency:tree 命令查看效果（需要重新将 pro01-maven-java 安装到仓库）： [INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT [INFO] +- junit:junit:jar:4.12:test [INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test [INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided [INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile [INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile [INFO] - commons-logging:commons-logging:jar:1.1.1:compile 验证 test 和 provided 范围不能传递 从上面的例子已经能够看到，pro01-maven-java 依赖了 junit，但是在 pro02-maven-web 工程中查看依赖树的时候并没有看到 junit。 要验证 provided 范围不能传递，可以在 pro01-maven-java 工程中加入 servlet-api 的依赖。 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 效果还是和之前一样： [INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT [INFO] +- junit:junit:jar:4.12:test [INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test [INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided [INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile [INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile [INFO] - commons-logging:commons-logging:jar:1.1.1:compile 依赖的排除 概念 当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是为了避免 jar 包之间的冲突。 所以配置依赖的排除其实就是阻止某些 jar 包的传递。因为这样的 jar 包传递过来会和其他 jar 包冲突。 配置方式 &lt;dependency&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;!-- 使用excludes标签配置依赖的排除 --&gt; &lt;exclusions&gt; &lt;!-- 在exclude标签中配置一个具体的排除 --&gt; &lt;exclusion&gt; &lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 测试 测试的方式：在 pro02-maven-web 工程中配置对 commons-logging 的排除 &lt;dependency&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro01-maven-java&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;!-- 使用excludes标签配置依赖的排除 --&gt; &lt;exclusions&gt; &lt;!-- 在exclude标签中配置一个具体的排除 --&gt; &lt;exclusion&gt; &lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 运行 mvn dependency:tree 命令查看效果： [INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT [INFO] +- junit:junit:jar:4.12:test [INFO] | - org.hamcrest:hamcrest-core:jar:1.3:test [INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided [INFO] - com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile [INFO] - org.springframework:spring-core:jar:4.0.0.RELEASE:compile 发现在 spring-core 下面就没有 commons-logging 了。 继承 概念 Maven工程之间，A 工程继承 B 工程 B 工程：父工程 A 工程 ：子工程 本质上是 A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置。 作用 在父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本。 背景 对一个比较大型的项目进行了模块拆分。 一个 project 下面，创建了很多个 module。 每一个 module 都需要配置自己的依赖信息。 背后的需求 在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。 使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。 使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。 通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。 举例 在一个工程中依赖多个 Spring 的 jar 包 [INFO] +- org.springframework:spring-core:jar:4.0.0.RELEASE:compile [INFO] | - commons-logging:commons-logging:jar:1.1.1:compile [INFO] +- org.springframework:spring-beans:jar:4.0.0.RELEASE:compile [INFO] +- org.springframework:spring-context:jar:4.0.0.RELEASE:compile [INFO] +- org.springframework:spring-expression:jar:4.0.0.RELEASE:compile [INFO] +- org.springframework:spring-aop:jar:4.0.0.RELEASE:compile [INFO] | - aopalliance:aopalliance:jar:1.0:compile 使用 Spring 时要求所有 Spring 自己的 jar 包版本必须一致。为了能够对这些 jar 包的版本进行统一管理，我们使用继承这个机制，将所有版本信息统一在父工程中进行管理。 操作 创建父工程 创建的过程和前面创建 pro01-maven-java 一样。 工程名称：pro03-maven-parent 修改它的打包方式： &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt; 只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程。打包方式为 pom 的 Maven 工程中不写业务代码，它是专门管理其他 Maven 工程的工程。 创建模块工程 模块工程类似于 IDEA 中的 module，所以需要进入 pro03-maven-parent 工程的根目录，然后运行 mvn archetype:generate 命令来创建模块工程。 假设，创建三个模块工程： 查看被添加新内容的父工程 pom.xml 下面 modules 和 module 标签是聚合功能的配置 &lt;modules&gt; &lt;module&gt;pro04-maven-module&lt;/module&gt; &lt;module&gt;pro05-maven-module&lt;/module&gt; &lt;module&gt;pro06-maven-module&lt;/module&gt; &lt;/modules&gt; 解读子工程的pom.xml &lt;!-- 使用parent标签指定当前工程的父工程 --&gt; &lt;parent&gt; &lt;!-- 父工程的坐标 --&gt; &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; &lt;artifactId&gt;pro03-maven-parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!-- 子工程的坐标 --&gt; &lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt; &lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt; &lt;artifactId&gt;pro04-maven-module&lt;/artifactId&gt; &lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt; 在父工程中配置依赖的统一管理 &lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt; &lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.0.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 子工程中引用那些被父工程管理的依赖 关键点：省略版本号 &lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。 --&gt; &lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt; &lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在父工程中升级依赖信息的版本 …… &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.1.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; …… 在父工程中声明自定义属性 &lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 自定义标签，维护Spring版本数据 --&gt; &lt;atguigu.spring.version&gt;4.3.6.RELEASE&lt;/atguigu.spring.version&gt; &lt;/properties&gt; 在需要的地方使用${}的形式来引用自定义的属性名： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${atguigu.spring.version}&lt;/version&gt; &lt;/dependency&gt; 真正实现“一处修改，处处生效”。 实际意义 编写一套符合要求、开发各种功能都能正常工作的依赖组合并不容易。如果公司里已经有人总结了成熟的组合方案，那么再开发新项目时，如果不使用原有的积累，而是重新摸索，会浪费大量的时间。为了提高效率，我们可以使用工程继承的机制，让成熟的依赖组合方案能够保留下来。 如上图所示，公司级的父工程中管理的就是成熟的依赖组合方案，各个新项目、子系统各取所需即可。 聚合 Maven 中的聚合 使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目。 项目 : 整体 模块 : 部分 TIP 概念的对应关系： 从继承关系角度来看： 父工程 子工程 从聚合关系角度来看： 总工程 模块工程 好处 一键执行 Maven 命令：很多构建命令都可以在“总工程”中一键执行。 以 mvn install 命令为例：Maven 要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是工程聚合之后，在总工程执行 mvn install 可以一键完成安装，而且会自动按照正确的顺序执行。 配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然。 聚合的配置 在总工程的modules即可 &lt;modules&gt; &lt;module&gt;pro04-maven-module&lt;/module&gt; &lt;module&gt;pro05-maven-module&lt;/module&gt; &lt;module&gt;pro06-maven-module&lt;/module&gt; &lt;/modules&gt; 依赖循环问题 如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误： DANGER [ERROR] [ERROR] The projects in the reactor contain a cyclic reference: 这个错误的含义是：循环引用。 补充 # -D 表示后面要附加命令的参数，字母 D 和后面的参数是紧挨着的，中间没有任何其它字符 # maven.test.skip=true 表示在执行命令的过程中跳过测试 mvn clean install -Dmaven.test.skip=true 其他核心概念 生命周期 作用 为了让构建过程自动化完成，Maven 设定了三个生命周期，生命周期中的每一个环节对应构建过程中的一个操作。 三个生命周期 生命周期名称 作用 各个环节 Clean 清理操作相关 pre-cleancleanpost-clean Site 生成站点相关 pre-sitesitepost-sitedeploy-site Default 主要构建过程 validategenerate-sourcesprocess-sourcesgenerate-resourcesprocess-resources 复制并处理资源文件，至目标目录，准备打包。compile 编译项目 main 目录下的源代码。process-classesgenerate-test-sourcesprocess-test-sourcesgenerate-test-resourcesprocess-test-resources 复制并处理资源文件，至目标测试目录。test-compile 编译测试源代码。process-test-classestest 使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。prepare-packagepackage 接受编译好的代码，打包成可发布的格式，如JAR。pre-integration-testintegration-testpost-integration-testverifyinstall将包安装至本地仓库，以让其它项目依赖。deploy将最终的包复制到远程的仓库，以让其它开发人员共享；或者部署到服务器上运行（需借助插件，例如：cargo）。 特点 前面三个生命周期彼此是独立的。 在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方。（本节记住这句话就行了，其他的都不需要记） Maven 之所以这么设计其实就是为了提高构建过程的自动化程度：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。 插件和目标 插件 Maven 的核心程序仅仅负责宏观调度，不做具体工作。具体工作都是由 Maven 插件完成的。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。 目标 一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应。 Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。 仓库 本地仓库：在当前电脑上，为电脑上所有 Maven 工程服务 远程仓库：需要联网 局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。 Internet 中央仓库 镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun 建议：不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突。 专门搜索 Maven 依赖信息的网站：https://mvnrepository.com/ ","link":"https://nanteng.github.io/post/mavenbasics/"},{"title":"SSM整合","content":"ContextLoaderListener Spring提供了监听器ContextLoaderListener，实现ServletContextListener接口，可监听 ServletContext的状态，在web服务器的启动，读取Spring的配置文件，创建Spring的IOC容器。web 应用中必须在web.xml中配置 &lt;listener&gt; &lt;!-- 配置Spring的监听器，在服务器启动时加载Spring的配置文件 Spring配置文件默认位置和名称：/WEB-INF/applicationContext.xml 可通过上下文参数自定义Spring配置文件的位置和名称 --&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--自定义Spring配置文件的位置和名称--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; 准备工作 创建Maven Module 导入依赖 &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;spring.version&gt;5.3.1&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--springmvc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Mybatis核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis和spring的整合包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建表 CREATE TABLE `t_emp` ( `emp_id` int(11) NOT NULL AUTO_INCREMENT, `emp_name` varchar(20) DEFAULT NULL, `age` int(11) DEFAULT NULL, `sex` char(1) DEFAULT NULL, `email` varchar(50) DEFAULT NULL, PRIMARY KEY (`emp_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 配置web.xml &lt;!-- 配置Spring的编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置处理请求方式PUT和DELETE的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter\u0002class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置SpringMVC的前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 设置SpringMVC的配置文件的位置和名称 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:SpringMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 设置Spring的配置文件的位置和名称 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:Spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 配置Spring的监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 创建SpringMVC的配置文件并配置 &lt;!--扫描组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.ssm.controller&quot;&gt;&lt;/context:component-scan&gt; &lt;!--配置视图解析器--&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置访问首页的视图控制 --&gt; &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;&gt;&lt;/mvc:view-controller&gt; &lt;!-- 配置默认的servlet处理静态资源 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 开启MVC的注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; 搭建MyBatis环境 创建属性文件jdbc.properties jdbc.user=root jdbc.password=atguigu jdbc.url=jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC jdbc.driver=com.mysql.cj.jdbc.Driver 创建MyBatis的核心配置文件mybatis-config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;settings&gt; &lt;!--将下划线映射为驼峰--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;plugins&gt; &lt;!--配置分页插件--&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; 创建Mapper接口和映射文件 public interface EmployeeMapper { List&lt;Employee&gt; getEmployeeList(); } &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.atguigu.ssm.mapper.EmployeeMapper&quot;&gt; &lt;select id=&quot;getEmployeeList&quot; resultType=&quot;Employee&quot;&gt; select * from t_emp &lt;/select&gt; &lt;/mapper&gt; 创建日志文件log4j.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt; &lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d{MM-dd HH:mm:ss,SSS}%m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;/log4j:configuration&gt; 创建Spring的配置文件并配置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--扫描组件--&gt; &lt;context:component-scan base-package=&quot;com.atguigu.ssm&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!-- 引入jdbc.properties --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt; &lt;/context:property-placeholder&gt; &lt;!-- 配置Druid数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置用于创建SqlSessionFactory的工厂bean --&gt; &lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 设置MyBatis配置文件的路径（可以不设置） --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt; &lt;/property&gt; &lt;!-- 设置数据源 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 设置类型别名所对应的包 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.atguigu.ssm.pojo&quot;&gt; &lt;/property&gt; &lt;!-- 设置映射文件的路径 若映射文件所在路径和mapper接口所在路径一致，则不需要设置 --&gt; &lt;!-- &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&gt; &lt;/property&gt; --&gt; &lt;/bean&gt; &lt;!-- 配置mapper接口的扫描配置 由mybatis-spring提供，可以将指定包下所有的mapper接口创建动态代理 并将这些动态代理作为IOC容器的bean管理 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.atguigu.ssm.mapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 测试功能 创建组件 实体类Employee public class Employee { private Integer empId; private String empName; private Integer age; private String sex; private String email; public Employee() { } public Employee(Integer empId, String empName, Integer age, String sex, String email) { this.empId = empId; this.empName = empName; this.age = age; this.sex = sex; this.email = email; } public Integer getEmpId() { return empId; } public void setEmpId(Integer empId) { this.empId = empId; } public String getEmpName() { return empName; } public void setEmpName(String empName) { this.empName = empName; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } } 创建控制层组件EmployeeController @Controller public class EmployeeController { @Autowired private EmployeeService employeeService; @RequestMapping(value = &quot;/employee/page/{pageNum}&quot;, method = RequestMethod.GET) public String getEmployeeList(Model model, @PathVariable(&quot;pageNum&quot;) Integer pageNum){ PageInfo&lt;Employee&gt; page = employeeService.getEmployeeList(pageNum); model.addAttribute(&quot;page&quot;, page); return &quot;employee_list&quot;; } } 创建接口EmployeeService public interface EmployeeService { PageInfo&lt;Employee&gt; getEmployeeList(Integer pageNum); } 创建实现类EmployeeServiceImpl @Service public class EmployeeServiceImpl implements EmployeeService { @Autowired private EmployeeMapper employeeMapper; @Override public PageInfo&lt;Employee&gt; getEmployeeList(Integer pageNum) { PageHelper.startPage(pageNum, 4); List&lt;Employee&gt; list = employeeMapper.getEmployeeList(); PageInfo&lt;Employee&gt; page = new PageInfo&lt;&gt;(list, 5); return page; } } 创建页面 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Employee Info&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@{/static/css/index_work.css}&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th colspan=&quot;6&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;emp_id&lt;/th&gt; &lt;th&gt;emp_name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;th&gt;sex&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;options&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : ${page.list}&quot;&gt; &lt;td th:text=&quot;${employee.empId}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${employee.empName}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${employee.age}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${employee.sex}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${employee.email}&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;6&quot;&gt; &lt;span th:if=&quot;${page.hasPreviousPage}&quot;&gt; &lt;a th:href=&quot;@{/employee/page/1}&quot;&gt;首页&lt;/a&gt; &lt;a th:href=&quot;@{'/employee/page/'+${page.prePage}}&quot;&gt;上一页&lt;/a&gt; &lt;/span&gt; &lt;span th:each=&quot;num : ${page.navigatepageNums}&quot;&gt; &lt;a th:if=&quot;${page.pageNum==num}&quot; th:href=&quot;@{'/employee/page/'+${num}}&quot; th:text=&quot;'['+${num}+']'&quot; style=&quot;color: red;&quot;&gt;&lt;/a&gt; &lt;a th:if=&quot;${page.pageNum!=num}&quot; th:href=&quot;@{'/employee/page/'+${num}}&quot; th:text=&quot;${num} &quot;&gt;&lt;/a&gt; &lt;/span&gt; &lt;span th:if=&quot;${page.hasNextPage}&quot;&gt; &lt;a th:href=&quot;@{'/employee/page/'+${page.nextPage}}&quot;&gt;下一页&lt;/a&gt; &lt;a th:href=&quot;@{'/employee/page/'+${page.pages}}&quot;&gt;末页&lt;/a&gt; &lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 访问测试分页功能 localhost:8080/employee/page/1 ","link":"https://nanteng.github.io/post/ssm-zheng-he/"},{"title":"SpringMVC","content":"springMVC简介 什么是MVC MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 实体类Bean：专门存储业务数据的，如 Student、User 等 为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller 调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果 找到相应的View视图，渲染数据后最终响应给浏览器 什么是SpringMVC SpringMVC是Spring的一个后续产品，是Spring的一个子项目 SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、 WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目 表述层开发的首选方案。 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台 servlet SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 HelloWorld 创建maven工程 1，添加web模块 2，打包方式：war 3，引入依赖 &lt;dependencies&gt; &lt;!-- SpringMVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ServletAPI --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring5和Thymeleaf整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。 配置web.xml 注册SpringMVC的前端控制器DispatcherServlet 默认配置方式 此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt; servlet-name &gt; - servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVCservlet.xml 默认配置方式 &lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet\u0002class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 /* 处理包括.jsp的请求路径 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 扩展配置方式 可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置 SpringMVC前端控制器DispatcherServlet的初始化时间 &lt;!-- 配置异常处理 --&gt; &lt;!--&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &amp;lt;!&amp;ndash; 将异常信息共享在请求域中的键 &amp;ndash;&amp;gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt; &lt;/property&gt; &lt;/bean&gt;--&gt; &lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet\u0002class&gt; &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation为固定值 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的 src/main/resources --&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 注 标签中使用/和/*的区别: /所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请 求 因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面 /*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写 法 创建请求控制器 由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要 创建处理具体请求的类，即请求控制器 请求控制器中每一个处理请求的方法成为控制器方法 因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识 为一个控制层组件，交给Spring的IOC容器管理，此时SpringMVC才能够识别控制器的存在 @Controller public class HelloController { } 创建springMVC的配置文件 &lt;!-- 自动扫描包 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu.mvc.controller&quot;/&gt; &lt;!-- 配置Thymeleaf视图解析器 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置&lt;mvc:annotation-driven/&gt;解决问题 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 开启mvc注解驱动 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;!-- 处理响应中文内容乱码 --&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 测试HelloWorld 实现对首页的访问 在请求控制器中创建处理请求的方法 // @RequestMapping注解：处理请求和控制器方法之间的映射关系 // @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径 // localhost:8080/springMVC/ @RequestMapping(&quot;/&quot;) public String index() { //设置视图名称 return &quot;index&quot;; } 通过超链接跳转到指定页面 在主页index.html中设置超链接 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;a th:href=&quot;@{/hello}&quot;&gt;HelloWorld&lt;/a&gt;&lt;br/&gt; &lt;/body&gt; &lt;/html&gt; 在请求控制器中创建处理请求的方法 @RequestMapping(&quot;/hello&quot;) public String HelloWorld() { return &quot;target&quot;; } 总结 浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器 DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器， 将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的 控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会 被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面 @RequestMapping注解 @RequestMapping注解的功能 从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联 起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。 @RequestMapping注解的位置 @RequestMapping标识一个类：设置映射请求的请求路径的初始信息 @RequestMapping标识一个方法：设置映射请求请求路径的具体信息 @Controller @RequestMapping(&quot;/test&quot;) public class RequestMappingController { //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping @RequestMapping(&quot;/testRequestMapping&quot;) public String testRequestMapping(){ return &quot;success&quot;; } } @RequestMapping注解的value属性 @RequestMapping注解的value属性通过请求的请求地址匹配请求映射 @RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求 @RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射 &lt;a th:href=&quot;@{/testRequestMapping}&quot;&gt;测试@RequestMapping的value属性-- &gt;/testRequestMapping&lt;/a&gt;&lt;br&gt; &lt;a th:href=&quot;@{/test}&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt; @RequestMapping( value = {&quot;/testRequestMapping&quot;, &quot;/test&quot;} ) public String testRequestMapping(){ return &quot;success&quot;; } @RequestMapping注解的method属性 @RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配 多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错 405：Request method 'POST' not supported &lt;a th:href=&quot;@{/test}&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt; &lt;form th:action=&quot;@{/test}&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; @RequestMapping( value = {&quot;/testRequestMapping&quot;, &quot;/test&quot;}, method = {RequestMethod.GET, RequestMethod.POST} ) public String testRequestMapping(){ return &quot;success&quot;; } 注 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解 处理get请求的映射--&gt;@GetMapping 处理post请求的映射--&gt;@PostMapping 处理put请求的映射--&gt;@PutMapping 处理delete请求的映射--&gt;@DeleteMapping 2、常用的请求方式有get，post，put，delete 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符 串（put或delete），则按照默认的请求方式get处理 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter @RequestMapping注解的params属性 @RequestMapping注解的params属性通过请求的请求参数匹配请求映射 @RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 &quot;param&quot;：要求请求映射所匹配的请求必须携带param请求参数 &quot;!param&quot;：要求请求映射所匹配的请求必须不能携带param请求参数 &quot;param=value&quot;：要求请求映射所匹配的请求必须携带param请求参数且param=value &quot;param!=value&quot;：要求请求映射所匹配的请求必须携带param请求参数但是param!=value &lt;a th:href=&quot;@{/test(username='admin',password=123456)&quot;&gt;测试@RequestMapping的params属性--&gt;/test&lt;/a&gt;&lt;br&gt; @RequestMapping( value = {&quot;/testRequestMapping&quot;, &quot;/test&quot;} ,method = {RequestMethod.GET, RequestMethod.POST} ,params = {&quot;username&quot;,&quot;password!=123456&quot;} ) public String testRequestMapping(){ return &quot;success&quot;; } 注： 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面会报错400：Parameter conditions &quot;username, password!=123456&quot; not met for actual request parameters: username={admin}, password={123456} @RequestMapping注解的headers属性 @RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射 @RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信 息和请求映射的匹配关系 &quot;header&quot;：要求请求映射所匹配的请求必须携带header请求头信息 &quot;!header&quot;：要求请求映射所匹配的请求必须不能携带header请求头信息 &quot;header=value&quot;：要求请求映射所匹配的请求必须携带header请求头信息且header=value &quot;header!=value&quot;：要求请求映射所匹配的请求必须携带header请求头信息且header!=value 若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面 显示404错误，即资源未找到 SpringMVC支持ant风格的路径 ？：表示任意的单个字符 *：表示任意的0个或多个字符 **：表示任意的一层或多层目录 注意：在使用**时，只能使用/**/xxx的方式 SpringMVC支持路径中的占位符 原始方式：/deleteUser?id=1 rest方式：/deleteUser/1 SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服 务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在 通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参 &lt;a th:href=&quot;@{/testRest/1/admin}&quot;&gt;测试路径中的占位符--&gt;/testRest&lt;/a&gt;&lt;br&gt; @RequestMapping(&quot;/testRest/{id}/{username}&quot;) public String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) String username){ System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username); return &quot;success&quot;; } //最终输出的内容为--&gt;id:1,username:admin SpringMVC获取请求参数 通过ServletAPI获取 将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象 @RequestMapping(&quot;/testParam&quot;) public String testParam(HttpServletRequest request){ String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;; } 通过控制器方法的形参获取请求参数 在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在 DispatcherServlet中就会将请求参数赋值给相应的形参 &lt;a th:href=&quot;@{/testParam(username='admin',password=123456)}&quot;&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt; @RequestMapping(&quot;/testParam&quot;) public String testParam(String username, String password){ System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;; } 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串 数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果 @RequestParam @RequestParam是将请求参数和控制器方法的形参创建映射关系 @RequestParam注解一共有三个属性： value：指定为形参赋值的请求参数的参数名 required：设置是否必须传输此请求参数，默认值为true 若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置 defaultValue属性，则页面报错400：Required String parameter 'xxx' is not present；若设置为 false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为 null defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值 为&quot;&quot;时，则使用默认值为形参赋值 @RequestHeader @RequestHeader是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam @CookieValue @CookieValue是将cookie数据和控制器方法的形参创建映射关系 @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 通过POJO获取请求参数 可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值 &lt;form th:action=&quot;@{/testpojo}&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; @RequestMapping(&quot;/testpojo&quot;) public String testPOJO(User user){ System.out.println(user); return &quot;success&quot;; } //最终结果--&gt;User{id=null, username='张三', password='123', age=23, sex='男',email='123@qq.com'} 解决获取请求参数的乱码问题 解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是 必须在web.xml中进行注册 &lt;!--配置springMVC的编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效 域对象共享数据 使用ServletAPI向request域对象共享数据 @RequestMapping(&quot;/testServletAPI&quot;) public String testServletAPI(HttpServletRequest request){ request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;; } 使用ModelAndView向request域对象共享数据 @RequestMapping(&quot;/testModelAndView&quot;) public ModelAndView testModelAndView(){ /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据 mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;); //设置视图，实现页面跳转 mav.setViewName(&quot;success&quot;); return mav; } 使用Model向request域对象共享数据 @RequestMapping(&quot;/testModel&quot;) public String testModel(Model model){ model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;; } 使用map向request域对象共享数据 @RequestMapping(&quot;/testMap&quot;) public String testMap(Map&lt;String, Object&gt; map){ map.put(&quot;testScope&quot;, &quot;hello,Map&quot;); return &quot;success&quot;; } 使用ModelMap向request域对象共享数据 @RequestMapping(&quot;/testModelMap&quot;) public String testModelMap(ModelMap modelMap){ modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;); return &quot;success&quot;; } Model、ModelMap、Map的关系 Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的 public interface Model{} public class ModelMap extends LinkedHashMap&lt;String, Object&gt; {} public class ExtendedModelMap extends ModelMap implements Model {} public class BindingAwareModelMap extends ExtendedModelMap {} 向session域共享数据 @RequestMapping(&quot;/testSession&quot;) public String testSession(HttpSession session){ session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;; } 向application域共享数据 @RequestMapping(&quot;/testApplication&quot;) public String testApplication(HttpSession session){ ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;); return &quot;success&quot;; } SpringMVC的视图 SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为JstlView 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视 图解析器解析之后所得到的是ThymeleafView ThymeleafView 当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置 的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转 @RequestMapping(&quot;/testHello&quot;) public String testHello(){ return &quot;hello&quot;; } 转发视图 SpringMVC中默认的转发视图是InternalResourceView SpringMVC中创建转发视图的情况： 当控制器方法中所设置的视图名称以&quot;forward:&quot;为前缀时，创建InternalResourceView视图，此时的视 图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀&quot;forward:&quot;去掉，剩余部 分作为最终路径通过转发的方式实现跳转 例如&quot;forward:/&quot;，&quot;forward:/employee&quot; @RequestMapping(&quot;/testForward&quot;) public String testForward(){ return &quot;forward:/testHello&quot;; } 重定向视图 SpringMVC中默认的重定向视图是RedirectView 当控制器方法中所设置的视图名称以&quot;redirect:&quot;为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀&quot;redirect:&quot;去掉，剩余部分作为最终路径通过重定向的方式实现跳转 例如&quot;redirect:/&quot;，&quot;redirect:/employee&quot; @RequestMapping(&quot;/testRedirect&quot;) public String testRedirect(){ return &quot;redirect:/testHello&quot;; } 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径 视图控制器view-controller 当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用viewcontroller标签进行表示 &lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称 --&gt; &lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt; 注: 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需 要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签： &lt;mvc:annotation-driven /&gt; RESTful RESTful简介 REST：Representational State Transfer，表现层资源状态转移。 资源 资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个 可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、 数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端 应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个 资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴 趣的客户端应用，可以通过资源的URI与其进行交互。 资源的表述 资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交 换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格 式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 状态转移 状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资 源的表述，来间接实现操作资源的目的。 RESTful的实现 具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方 式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。 操作 传统方式 REST风格 查询操作 getUserById?id=1 user/1--&gt;get请求方式 保存操作 saveUser user--&gt;post请求方式 删除操作 deleteUser?id=1 user/1--&gt;delete请求方式 更新操作 updateUser user--&gt;put请求方式 HiddenHttpMethodFilter 由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？ SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求 HiddenHttpMethodFilter 处理put和delete请求的条件： 当前请求的请求方式必须为post 当前请求必须传输请求参数_method 满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数 _method的值，因此请求参数_method的值才是最终的请求方式 在web.xml中注册HiddenHttpMethodFilter &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filterclass&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 注： 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和 HiddenHttpMethodFilter 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter 原因： 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字 符集的 request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作： String paramValue = request.getParameter(this.methodParam); HttpMessageConverter HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文 HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，ResponseEntity @RequestBody @RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值 &lt;form th:action=&quot;@{/testRequestBody}&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; @RequestMapping(&quot;/testRequestBody&quot;) public String testRequestBody(@RequestBody String requestBody){ System.out.println(&quot;requestBody:&quot;+requestBody); return &quot;success&quot;; } 输出结果： requestBody:username=admin&amp;password=123456 RequestEntity RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的 请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息 @RequestMapping(&quot;/testRequestEntity&quot;) public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity){ System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders()); System.out.println(&quot;requestBody:&quot;+requestEntity.getBody()); return &quot;success&quot;; } @ResponseBody @ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器 @RequestMapping(&quot;/testResponseBody&quot;) @ResponseBody public String testResponseBody(){ return &quot;success&quot;; } 结果：浏览器页面显示success SpringMVC处理json @ResponseBody处理json的步骤： 导入jackson的依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; 在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消 息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格 式的字符串 &lt;mvc:annotation-driven /&gt; 在处理器方法上使用@ResponseBody注解进行标识 将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串 @RequestMapping(&quot;/testResponseUser&quot;) @ResponseBody public User testResponseUser(){ return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;); } 浏览器的页面中展示的结果： {&quot;id&quot;:1001,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;123456&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;男&quot;} SpringMVC处理ajax 请求超链接： &lt;div id=&quot;app&quot;&gt; &lt;a th:href=&quot;@{/testAjax}&quot; @click=&quot;testAjax&quot;&gt;testAjax&lt;/a&gt;&lt;br&gt; &lt;/div&gt; 通过vue和axios处理点击事件： &lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/static/js/vue.js}&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@{/static/js/axios.min.js}&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue({ el:&quot;#app&quot;, methods:{ testAjax:function (event) { axios({ method:&quot;post&quot;, url:event.target.href, params:{ username:&quot;admin&quot;, password:&quot;123456&quot; } }).then(function (response) { alert(response.data); }); event.preventDefault(); } } }); &lt;/script&gt; &gt;控制器方法： @RequestMapping(&quot;/testAjax&quot;) @ResponseBody public String testAjax(String username, String password){ System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;hello,ajax&quot;; } @RestController注解 @RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了 @Controller注解，并且为其中的每个方法添加了@ResponseBody注解 ResponseEntity ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文 文件上传和下载 文件下载 使用ResponseEntity实现下载文件的功能 @RequestMapping(&quot;/testDown&quot;) public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException { //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/img/1.jpg&quot;); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()]; //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=1.jpg&quot;); //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity; } 文件上传 文件上传要求form表单的请求方式必须为post，并且添加属性enctype=&quot;multipart/form-data&quot; SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息 上传步骤： 添加依赖： &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; 在SpringMVC的配置文件中添加配置： &lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;/bean&gt; 控制器方法： @RequestMapping(&quot;/testUp&quot;) public String testUp(MultipartFile photo, HttpSession session) throws IOException { //获取上传的文件的文件名 String fileName = photo.getOriginalFilename(); //处理文件重名问题 String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); fileName = UUID.randomUUID().toString() + hzName; //获取服务器中photo目录的路径 ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(&quot;photo&quot;); File file = new File(photoPath); if(!file.exists()){ file.mkdir(); } String finalPath = photoPath + File.separator + fileName; //实现上传功能 photo.transferTo(new File(finalPath)); return &quot;success&quot;; } 拦截器 拦截器的配置 SpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandlerInterceptor SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置： &lt;bean class=&quot;com.atguigu.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt; &lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/testRequestEntity&quot;/&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt; &lt;/mvc:interceptor&gt; &lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过 mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求 --&gt; 拦截器的三个抽象方法 SpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返 回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 postHandle：控制器方法执行之后执行postHandle() afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation() 多个拦截器的执行顺序 若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行 &gt;若某个拦截器的preHandle()返回了false preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false 的拦截器之前的拦截器的afterComplation()会执行 异常处理器 基于配置的异常处理 SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和 SimpleMappingExceptionResolver SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式： &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 基于注解的异常处理 //@ControllerAdvice将当前类标识为异常处理的组件 @ControllerAdvice public class ExceptionController { //@ExceptionHandler用于设置所标识方法处理的异常 @ExceptionHandler(ArithmeticException.class) //ex表示当前请求处理中出现的异常对象 public String handleArithmeticException(Exception ex, Model model){ model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; } } 注解配置SpringMVC 使用配置类和注解代替web.xml和SpringMVC配置文件的功能 创建初始化类，代替web.xml 在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类， 如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配 置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自 动发现它，并用它来配置Servlet上下文。 public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer { /** * 指定spring的配置类 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } /** * 指定SpringMVC的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class[]{WebConfig.class}; } /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() { return new String[]{&quot;/&quot;}; } /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() { CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(&quot;UTF-8&quot;); encodingFilter.setForceRequestEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]{encodingFilter, hiddenHttpMethodFilter}; } } 创建SpringConfig配置类，代替spring的配置文件 @Configuration public class SpringConfig { //ssm整合之后，spring的配置信息写在此类中 } 创建WebConfig配置类，代替SpringMVC的配置文件 @Configuration //扫描组件 @ComponentScan(&quot;com.atguigu.mvc.controller&quot;) //开启MVC注解驱动 @EnableWebMvc public class WebConfig implements WebMvcConfigurer { //使用默认的servlet处理静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurerconfigurer) { configurer.enable(); } //配置文件上传解析器 @Bean public CommonsMultipartResolver multipartResolver(){ return new CommonsMultipartResolver(); } //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { FirstInterceptor firstInterceptor = new FirstInterceptor(); registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;); } //配置视图控制 /*@Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); }*/ //配置异常映射 /*@Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) { SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(&quot;ex&quot;); resolvers.add(exceptionResolver); }*/ //配置生成模板解析器 @Bean public ITemplateResolver templateResolver() { WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过 WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; } //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) { SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; } //生成视图解析器并未解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) { ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; } } 测试功能 @RequestMapping(&quot;/&quot;) public String index(){ return &quot;index&quot;; } SpringMVC执行流程 SpringMVC常用组件 DispatcherServlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找Handler，即控制器方法 Handler：处理器，需要工程师开发 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过HandlerAdapter对处理器（控制器方法）进行执行 ViewResolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、 RedirectView View：视图 作用：将模型数据通过页面展示给用户 DispatcherServlet初始化过程 DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。 &gt;初始化WebApplicationContext 所在类：org.springframework.web.servlet.FrameworkServlet protected WebApplicationContext initWebApplicationContext() { WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { // A context instance was injected at construction time -&gt; use it wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { // The context has not yet been refreshed -&gt; provide services such as // setting the parent context, setting the application context id, etc if (cwac.getParent() == null) { // The context instance was injected without an explicitparent -&gt; set // the root application context (if any; may be null) as theparent cwac.setParent(rootContext); } configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { // No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id wac = findWebApplicationContext(); } if (wac == null) { // No context instance is defined for this servlet -&gt; create a local one // 创建WebApplicationContext wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here. synchronized (this.onRefreshMonitor) { // 刷新WebApplicationContext onRefresh(wac); } } if (this.publishContext) { // Publish the context as a servlet context attribute. // 将IOC容器在应用域共享 String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); } return wac; } &gt;创建WebApplicationContext 所在类：org.springframework.web.servlet.FrameworkServlet protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) { Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) { throw new ApplicationContextException( &quot;Fatal initialization error in servlet with name '&quot; + getServletName() + &quot;': custom WebApplicationContext class [&quot; + contextClass.getName() + &quot;] is not of type ConfigurableWebApplicationContext&quot;); } // 通过反射创建 IOC 容器对象 ConfigurableWebApplicationContext wac = ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); // 设置父容器 wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) { wac.setConfigLocation(configLocation); } configureAndRefreshWebApplicationContext(wac); return wac; } &gt;DispatcherServlet初始化策略 FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在 DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化 DispatcherServlet的各个组件 所在类：org.springframework.web.servlet.DispatcherServlet protected void initStrategies(ApplicationContext context) { initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); } DispatcherServlet调用组件处理请求 processRequest() FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response) 所在类：org.springframework.web.servlet.FrameworkServlet protected final void processRequest(HttpServletRequest request,HttpServletResponse response)throws ServletException, IOException { long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request,response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(),new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try { // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写 doService(request, response); } catch (ServletException | IOException ex) { failureCause = ex; throw ex; } catch (Throwable ex) { failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); } finally { resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) { requestAttributes.requestCompleted(); } logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); } } doService() 所在类：org.springframework.web.servlet.DispatcherServlet protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception { logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) { attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) { String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) { attributesSnapshot.put(attrName, request.getAttribute(attrName)); } } } // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) { FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) { request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); } request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); } RequestPath requestPath = null; if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) { requestPath = ServletRequestPathUtils.parseAndCache(request); } try { // 处理请求和响应 doDispatch(request, response); } finally { if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) { restoreAttributesAfterInclude(request, attributesSnapshot); } } if (requestPath != null) { ServletRequestPathUtils.clearParsedRequestPath(request); } } } doDispatch() 所在类：org.springframework.web.servlet.DispatcherServlet protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { ModelAndView mv = null; Exception dispatchException = null; try { processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) { noHandlerFound(processedRequest, response); return; } // Determine handler adapter for the current request. // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) { long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) { return; } } // 调用拦截器的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } // Actually invoke the handler. // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) { return; } applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); } catch (Exception ex) { dispatchException = ex; } catch (Throwable err) { // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); } // 后续处理：处理模型数据和渲染视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); } catch (Exception ex) { triggerAfterCompletion(processedRequest, response, mappedHandler, ex); } catch (Throwable err) { triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); } finally { if (asyncManager.isConcurrentHandlingStarted()) { // Instead of postHandle and afterCompletion if (mappedHandler != null) { mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); } } else { // Clean up any resources used by a multipart request. if (multipartRequestParsed) { cleanupMultipart(processedRequest); } } } } processDispatchResult() private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception { boolean errorView = false; if (exception != null) { if (exception instanceof ModelAndViewDefiningException) { logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); } else { Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); } } // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) { // 处理模型数据和渲染视图 render(mv, request, response); if (errorView) { WebUtils.clearErrorRequestAttributes(request); } } else { if (logger.isTraceEnabled()) { logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); } } if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { // Concurrent handling started during a forward return; } if (mappedHandler != null) { // Exception (if any) is already handled.. // 调用拦截器的afterCompletion() mappedHandler.triggerAfterCompletion(request, response, null); } } SpringMVC的执行流程 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射： a.不存在 再判断是否配置了mvc:default-servlet-handler 如果没配置，则控制台报映射查找不到，客户端展示404错误 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404 错误 b.存在则执行下面的流程 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及 Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： a. HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 b.数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 c.数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 d.数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。 此时将开始执行拦截器的postHandle(...)方法【逆向】 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行 HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model 和View，来渲染视图。 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。 将渲染结果返回给客户端。 ","link":"https://nanteng.github.io/post/springmvc/"},{"title":"MyBatis","content":"MyBatis简介 MyBatis历史 MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁 移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于 2013年11月迁移到Github。 iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架 包括SQL Maps和Data Access Objects（DAO）。 MyBatis特性 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架 和其它持久化层技术对比 JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低 Hibernate 和 JPA 操作简便，开发效率高 程序中的长难复杂 SQL 需要绕过框架 内部自动生产的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 反射操作太多，导致数据库性能下降 MyBatis 轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于HIbernate，但是完全能够接受 搭建MyBatis 创建Maven工程 打包方式：jar &lt;packaging&gt;jar&lt;/packaging&gt; 引入依赖 &lt;dependencies&gt; &lt;!-- Mybatis核心 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建MyBatis的核心配置文件 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring 之后，这个配置文件可以省略。 核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息 核心配置文件存放的位置是src/main/resources目录下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/MyBatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 创建mapper接口 MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要 提供实现类。 public interface UserMapper { /** * 添加用户信息 */ int insertUser(); } 创建MyBatis的映射文件 相关概念：ORM（Object Relationship Mapping）对象关系映射。 对象：Java的实体类对象 关系：关系型数据库 映射：二者之间的对应关系 Java概念 数据库概念 类 表 属性 字段/列 对象 记录/行 1、映射文件的命名规则： 表所对应的实体类的类名+Mapper.xml 例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src/main/resources/mappers目录下 2、MyBatis中可以面向接口操作数据，要保证两个一致： a&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致 b&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt; &lt;!--int insertUser();--&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,'张三','123',23,'女') &lt;/insert&gt; &lt;/mapper&gt; 通过junit测试功能 //读取MyBatis的核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务 //SqlSession sqlSession = sqlSessionFactory.openSession(); //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交 SqlSession sqlSession = sqlSessionFactory.openSession(true); //通过代理模式创建UserMapper接口的代理实现类对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配 映射文件中的SQL标签，并执行标签中的SQL语句 int result = userMapper.insertUser(); //sqlSession.commit(); System.out.println(&quot;结果：&quot;+result); SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的 会话） SqlSessionFactory：是“生产”SqlSession的“工厂”。 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的 相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。 加入log4j日志功能 加入依赖 &lt;!-- log4j日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 加入log4j的配置文件 log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt; &lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;/log4j:configuration&gt; 日志的级别 FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细 核心配置文件详解 核心配置文件中的标签必须按照固定的顺序： properties? settings? typeAliases? typeHandlers? objectFactory? objectWrapperFactory? reflectorF actory? plugins? environments? databaseIdProvider? mappers? &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//MyBatis.org//DTD Config 3.0//EN&quot; &quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--&gt; &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt; &lt;settings&gt; &lt;!--将表中字段的下划线自动转换为驼峰--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!--开启延迟加载--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小 写 若设置此属性，此时该类型的别名只能使用alias所设置的值 --&gt; &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;abc&quot;&gt; &lt;/typeAlias&gt;--&gt; &lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt; &lt;package name=&quot;com.atguigu.mybatis.bean&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --&gt; &lt;environments default=&quot;mysql_test&quot;&gt; &lt;!-- environment：设置具体的连接数据库的环境信息 属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id， 表示默认使用的环境 --&gt; &lt;environment id=&quot;mysql_test&quot;&gt; &lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot; type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理 type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot; type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从 缓存中直接获取，不需要重新创建 type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建 type=&quot;JNDI&quot;：调用上下文中的数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--设置驱动类的全类名--&gt; &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;!--设置连接数据库的连接地址--&gt; &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;!--设置连接数据库的用户名--&gt; &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;!--设置连接数据库的密码--&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下 --&gt; &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; MyBatis的增删改查 添加 &lt;!--int insertUser();--&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,'admin','123456',23,'男') &lt;/insert&gt; 删除 &lt;!--int deleteUser();--&gt; &lt;delete id=&quot;deleteUser&quot;&gt; delete from t_user where id = 7 &lt;/delete&gt; 修改 &lt;!--int updateUser();--&gt; &lt;update id=&quot;updateUser&quot;&gt; update t_user set username='ybc',password='123' where id = 6 &lt;/update&gt; 查询一个实体类对象 &lt;!--User getUserById();--&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt; select * from t_user where id = 2 &lt;/select&gt; 查询集合 &lt;!--List&lt;User&gt; getUserList();--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt; select * from t_user &lt;/select&gt; 注意： 1、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射 关系 resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况 2、当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常 TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值 MyBatis获取参数值的两种方式 MyBatis获取参数值的两种方式： ${}本质就是字符串拼接 ${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引 号 #{}本质就是占位符赋值 #{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自 动添加单引号 单个字面量类型的参数 若mapper接口中的方法参数为单个的字面量类型 此时可以使用{}和#{}以任意的名称获取参数的值，注意{}需要手动加单引号 多个字面量类型的参数 若mapper接口中的方法参数为多个时 此时MyBatis会自动将这些参数放在一个map集合中，以arg0,arg1...为键，以参数为值；以 param1,param2...为键，以参数为值；因此只需要通过{}和#{}访问map集合的键就可以获取相对应的 值，注意`{}`需要手动加单引号 map集合类型的参数 若mapper接口中的方法需要的参数为多个时 此时可以手动创建map集合，将这些数据放在map中 只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号 实体类类型的参数 若mapper接口中的方法参数为实体类对象时 此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号 使用@Param标识参数 可以通过@Param注解标识mapper接口中的方法参数 此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值；以 param1,param2...为键，以参数为值；只需要通过{}和#{}访问map集合的键就可以获取相对应的值， 注意{}需要手动加单引号 MyBatis的各种查询功能 查询一个实体类对象 /** * 根据用户id查询用户信息 * @param id * @return */ User getUserById(@Param(&quot;id&quot;) int id); &lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt; select * from t_user where id = #{id} &lt;/select&gt; 查询一个list集合 /** * 查询所有用户信息 * @return */ List&lt;User&gt; getUserList(); &lt;!--List&lt;User&gt; getUserList();--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;User&quot;&gt; select * from t_user &lt;/select&gt; 查询单个数据 /** * 查询用户的总记录数 * @return * 在MyBatis中，对于Java中常用的类型都设置了类型别名 * 例如：java.lang.Integer--&gt;int|integer * 例如：int--&gt;_int|_integer * 例如：Map--&gt;map,List--&gt;list */ int getCount(); &lt;!--int getCount();--&gt; &lt;select id=&quot;getCount&quot; resultType=&quot;_integer&quot;&gt; select count(id) from t_user &lt;/select&gt; 查询一条数据为map集合 /** * 根据用户id查询用户信息为map集合 * @param id * @return */ Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id); &lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt; &lt;select id=&quot;getUserToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user where id = #{id} &lt;/select&gt; &lt;!--结果：{password=123456, sex=男, id=1, age=23, username=admin}--&gt; 查询多条数据为map集合 方式一： /** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取 */ List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap(); &lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt; &lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user &lt;/select&gt; 方式二： /** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合 */ @MapKey(&quot;id&quot;) Map&lt;String, Object&gt; getAllUserToMap(); &lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt; &lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user &lt;/select&gt; 结果： &lt;!-- { 1={password=123456, sex=男, id=1, age=23, username=admin}, 2={password=123456, sex=男, id=2, age=23, username=张三}, 3={password=123456, sex=男, id=3, age=23, username=张三} } --&gt; 特殊SQL的执行 模糊查询 /** * 测试模糊查询 * @param mohu * @return */ List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu); &lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt; &lt;select id=&quot;testMohu&quot; resultType=&quot;User&quot;&gt; &lt;!--select * from t_user where username like '%${mohu}%'--&gt; &lt;!--select * from t_user where username like concat('%',#{mohu},'%')--&gt; select * from t_user where username like &quot;%&quot;#{mohu}&quot;%&quot; &lt;/select&gt; 批量删除 /** * 批量删除 * @param ids * @return */ int deleteMore(@Param(&quot;ids&quot;) String ids); &lt;!--int deleteMore(@Param(&quot;ids&quot;) String ids);--&gt; &lt;delete id=&quot;deleteMore&quot;&gt; delete from t_user where id in (${ids}) &lt;/delete&gt; 动态设置表名 /** * 动态设置表名，查询所有的用户信息 * @param tableName * @return */ List&lt;User&gt; getAllUser(@Param(&quot;tableName&quot;) String tableName); &lt;!--List&lt;User&gt; getAllUser(@Param(&quot;tableName&quot;) String tableName);--&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;User&quot;&gt; select * from ${tableName} &lt;/select&gt; 添加功能获取自增的主键 t_class(clazz_id,class_name) t_student(student_id,student_name,class_id) 1，添加班级信息 2，获取新添加的班级的id 3，为班级分配学生，即将某学的班级id修改为新添加的班级的id /** * 添加用户信息 * @param user * @return * useGeneratedKeys：设置使用自增的主键 * keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中 */ int insertUser(User user); &lt;!--int insertUser(User user);--&gt; &lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_user values(null,#{username},#{password},#{age},#{sex}) &lt;/insert&gt; 自定义映射resultMap resultMap处理字段和属性的映射关系 若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射 &lt;!-- resultMap：设置自定义映射 属性： id：表示自定义映射的唯一标识 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系 result：设置普通字段的映射关系 association：设置多对一的映射关系 collection：设置一对多的映射关系 属性： property：设置映射关系中实体类中的属性名 column：设置映射关系中表中的字段名 --&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;&gt;&lt;/id&gt; &lt;result property=&quot;userName&quot; column=&quot;user_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt; &lt;select id=&quot;testMohu&quot; resultMap=&quot;userMap&quot;&gt; &lt;!--select * from t_user where username like '%${mohu}%'--&gt; select id,user_name,password,age,sex from t_user where user_name like concat('%',#{mohu},'%') &lt;/select&gt; 若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性 名符合Java的规则（使用驼峰） 此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可 以在查询表中数据时，自动将_类型的字段名转换为驼峰 例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为 userName 多对一映射处理 查询员工信息以及员工所对应的部门信息 级联方式处理映射关系 &lt;resultMap id=&quot;empDeptMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;eid&quot; property=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result column=&quot;empName&quot; property=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;result column=&quot;did&quot; property=&quot;dept.did&quot;&gt;&lt;/result&gt; &lt;result column=&quot;dname&quot; property=&quot;dept.dname&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt; &lt;select id=&quot;getEmpAndDeptByEid&quot; resultMap=&quot;empDeptMap&quot;&gt; select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did = dept.did where emp.eid = #{eid} &lt;/select&gt; 使用association处理映射关系 &lt;resultMap id=&quot;empDeptMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;eid&quot; property=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result column=&quot;empName&quot; property=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt; &lt;id column=&quot;did&quot; property=&quot;did&quot;&gt;&lt;/id&gt; &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt; &lt;select id=&quot;getEmpAndDeptByEid&quot; resultMap=&quot;empDeptMap&quot;&gt; select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did = dept.did where emp.eid = #{eid} &lt;/select&gt; 分步查询 1.查询员工信息 /** * 通过分步查询查询员工信息 * @param eid * @return */ Emp getEmpByStep(@Param(&quot;eid&quot;) int eid); &lt;resultMap id=&quot;empDeptStepMap&quot; type=&quot;Emp&quot;&gt; &lt;id column=&quot;eid&quot; property=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result column=&quot;empName&quot; property=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt; &lt;!-- select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId） column：将sql以及查询结果中的某个字段设置为分步查询的条件 --&gt; &lt;association property=&quot;dept&quot; select=&quot;com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep&quot; column=&quot;did&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!--Emp getEmpByStep(@Param(&quot;eid&quot;) int eid);--&gt; &lt;select id=&quot;getEmpByStep&quot; resultMap=&quot;empDeptStepMap&quot;&gt; select * from t_emp where eid = #{eid} &lt;/select&gt; 2.根据员工所对应的部门id查询部门信息 /** * 分步查询的第二步：根据员工所对应的did查询部门信息 * @param did * @return */ Dept getEmpDeptByStep(@Param(&quot;did&quot;) int did); &lt;!--Dept getEmpDeptByStep(@Param(&quot;did&quot;) int did);--&gt; &lt;select id=&quot;getEmpDeptByStep&quot; resultType=&quot;Dept&quot;&gt; select * from t_dept where did = #{did} &lt;/select&gt; 一对多映射处理 1.collection /** * 根据部门id查新部门以及部门中的员工信息 * @param did * @return */ Dept getDeptEmpByDid(@Param(&quot;did&quot;) int did); &lt;resultMap id=&quot;deptEmpMap&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt; &lt;result property=&quot;dname&quot; column=&quot;dname&quot;&gt;&lt;/result&gt; &lt;!-- ofType：设置collection标签所处理的集合属性中存储数据的类型 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt; &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt; &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt; &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptEmpByDid(@Param(&quot;did&quot;) int did);--&gt; &lt;select id=&quot;getDeptEmpByDid&quot; resultMap=&quot;deptEmpMap&quot;&gt; select dept.*,emp.* from t_dept dept left join t_emp emp on dept.did = emp.did where dept.did = #{did} &lt;/select&gt; 分步查询 1.查询部门信息 /** * 分步查询部门和部门中的员工 * @param did * @return */ Dept getDeptByStep(@Param(&quot;did&quot;) int did); &lt;resultMap id=&quot;deptEmpStep&quot; type=&quot;Dept&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt; &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt; &lt;collection property=&quot;emps&quot; fetchType=&quot;eager&quot; select=&quot;com.atguigu.MyBatis.mapper.EmpMapper.getEmpListByDid&quot; column=&quot;did&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--Dept getDeptByStep(@Param(&quot;did&quot;) int did);--&gt; &lt;select id=&quot;getDeptByStep&quot; resultMap=&quot;deptEmpStep&quot;&gt; select * from t_dept where did = #{did} &lt;/select&gt; 2.根据部门id查询部门中的所有员工 /** * 根据部门id查询员工信息 * @param did * @return */ List&lt;Emp&gt; getEmpListByDid(@Param(&quot;did&quot;) int did); &lt;!--List&lt;Emp&gt; getEmpListByDid(@Param(&quot;did&quot;) int did);--&gt; &lt;select id=&quot;getEmpListByDid&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp where did = #{did} &lt;/select&gt; 分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息： lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载 aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个 属性会按需加载 此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和 collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=&quot;lazy(延迟加 载)|eager(立即加载)&quot; 动态SQL Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决 拼接SQL语句字符串时的痛点问题。 if if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中 的内容不会执行 &lt;!--List&lt;Emp&gt; getEmpListByMoreTJ(Emp emp);--&gt; &lt;select id=&quot;getEmpListByMoreTJ&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp where 1=1 &lt;if test=&quot;empName != '' and empName != null&quot;&gt; and emp_name = #{empName} &lt;/if&gt; &lt;if test=&quot;age != '' and age != null&quot;&gt; and age = #{age} &lt;/if&gt; &lt;if test=&quot;sex != '' and sex != null&quot;&gt; and sex = #{sex} &lt;/if&gt; &lt;/select&gt; where &lt;select id=&quot;getEmpListByMoreTJ2&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;where&gt; &lt;if test=&quot;empName != '' and empName != null&quot;&gt; emp_name = #{empName} &lt;/if&gt; &lt;if test=&quot;age != '' and age != null&quot;&gt; and age = #{age} &lt;/if&gt; &lt;if test=&quot;sex != '' and sex != null&quot;&gt; and sex = #{sex} &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; where和if一般结合使用： 若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字 若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的 and去掉 注意：where标签不能去掉条件最后多余的and trim &lt;select id=&quot;getEmpListByMoreTJ&quot; resultType=&quot;Emp&quot;&gt; select * from t_emp &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;empName != '' and empName != null&quot;&gt; emp_name = #{empName} and &lt;/if&gt; &lt;if test=&quot;age != '' and age != null&quot;&gt; age = #{age} and &lt;/if&gt; &lt;if test=&quot;sex != '' and sex != null&quot;&gt; sex = #{sex} &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; trim用于去掉或添加标签中的内容 常用属性： prefix：在trim标签中的内容的前面添加某些内容 prefixOverrides：在trim标签中的内容的前面去掉某些内容 suffix：在trim标签中的内容的后面添加某些内容 suffixOverrides：在trim标签中的内容的后面去掉某些内容 choose、when、otherwise choose、when、otherwise相当于if...else if..else &lt;!--List&lt;Emp&gt; getEmpListByChoose(Emp emp);--&gt; &lt;select id=&quot;getEmpListByChoose&quot; resultType=&quot;Emp&quot;&gt; select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;empName != '' and empName != null&quot;&gt; emp_name = #{empName} &lt;/when&gt; &lt;when test=&quot;age != '' and age != null&quot;&gt; age = #{age} &lt;/when&gt; &lt;when test=&quot;sex != '' and sex != null&quot;&gt; sex = #{sex} &lt;/when&gt; &lt;when test=&quot;email != '' and email != null&quot;&gt; email = #{email} &lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; foreach &lt;!--int insertMoreEmp(List&lt;Emp&gt; emps);--&gt; &lt;insert id=&quot;insertMoreEmp&quot;&gt; insert into t_emp values &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt; (null,#{emp.ename},#{emp.age},#{emp.sex},#{emp.email},null) &lt;/foreach&gt; &lt;/insert&gt; &lt;!--int deleteMoreByArray(int[] eids);--&gt; &lt;delete id=&quot;deleteMoreByArray&quot;&gt; delete from t_emp where &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;or&quot;&gt; eid = #{eid} &lt;/foreach&gt; &lt;/delete&gt; &lt;!--int deleteMoreByArray(int[] eids);--&gt; &lt;delete id=&quot;deleteMoreByArray&quot;&gt; delete from t_emp where eid in &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #{eid} &lt;/foreach&gt; &lt;/delete&gt; 属性： collection：设置要循环的数组或集合 item：表示集合或数组中的每一个数据 separator：设置循环体之间的分隔符 open：设置foreach标签中的内容的开始符 close：设置foreach标签中的内容的结束符 SQL片段 sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入 &lt;sql id=&quot;empColumns&quot;&gt; eid,ename,age,sex,did &lt;/sql&gt; select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp MyBatis的缓存 MyBatis的一级缓存 一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就 会从缓存中直接获取，不会从数据库重新访问 使一级缓存失效的四种情况： 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存 MyBatis的二级缓存 二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被 缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 二级缓存开启的条件： 在核心配置文件中，设置全局配置属性cacheEnabled=&quot;true&quot;，默认为true，不需要设置 在映射文件中设置标签&lt;cache/&gt; 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口 使二级缓存失效的情况： 两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效 二级缓存的相关配置 在mapper配置文件中添加的cache标签可以设置一些属性： eviction属性：缓存回收策略 LRU（Least Recently Used） 最近最少使用的：移除最长时间不被使用的对象。（默认） FIFO（First in First out） 先进先出：按对象进入缓存的顺序来移除它们。 SOFT 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 flushInterval属性：刷新间隔，单位毫秒 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 size属性：引用数目，正整数 代表缓存最多可以存储多少个对象，太大容易导致内存溢出 readOnly属性：只读，true/false true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了 很重要的性能优势。 false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。 MyBatis缓存查询的顺序 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 SqlSession关闭之后，一级缓存中的数据会写入二级缓存 整合第三方缓存EHCache 1.添加依赖 &lt;!-- Mybatis EHCache整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j日志门面的一个具体实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; 2.各jar包功能 jar包名称 作用 mybatis-ehcache Mybatis和EHCache的整合包 ehcache EHCache核心包 slf4j-api SLF4J日志门面包 logback-classic 支持SLF4J门面接口的一个具体实现 3.创建EHCache的配置文件ehcache.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path=&quot;D:\\atguigu\\ehcache&quot;/&gt; &lt;defaultCache maxElementsInMemory=&quot;1000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;true&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt; &lt;/ehcache&gt; 4.EHCache配置文件说明 属性名 是 否 必 须 作用 maxElementsInMemory 是 在内存中缓存的element的最大数目 maxElementsOnDisk 是 在磁盘上缓存的element的最大数目，若是0表示无穷大 eternal 是 设定缓存的elements是否永远不过期。 如果为 true，则缓存的数据始终有效， 如果为false那么还 要根据timeToIdleSeconds、timeToLiveSeconds 判断 overflowToDisk 是 设定当内存缓存溢出的时候是否将过期的element 缓存到磁盘上 timeToIdleSeconds 否 当缓存在EhCache中的数据前后两次访问的时间超 过timeToIdleSeconds的属性取值时， 这些数据便 会删除，默认值是0,也就是可闲置时间无穷大 timeToLiveSeconds 否 缓存element的有效生命期，默认是0,也就是 element存活时间无穷大 diskSpoolBufferSizeMB 否 DiskStore(磁盘缓存)的缓存区大小。默认是 30MB。每个Cache都应该有自己的一个缓冲区 diskPersistent 否 在VM重启的时候是否启用磁盘保存EhCache中的数 据，默认是false。 diskExpiryThreadIntervalSeconds 否 磁盘缓存的清理线程运行间隔，默认是120秒。每 个120s， 相应的线程会进行一次EhCache中数据的 清理工作 memoryStoreEvictionPolicy 否 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最 近最少使用），可选的有LFU（最不常使用）和 FIFO（先进先出） 5.设置二级缓存的类型 &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; 6.加入logback日志 存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。 创建logback的配置文件logback.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration debug=&quot;true&quot;&gt; &lt;!-- 指定日志输出的位置 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;!-- 日志输出的格式 --&gt; &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt; &lt;pattern&gt;[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt; &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;!-- 根据特殊需求指定局部日志级别 --&gt; &lt;logger name=&quot;com.atguigu.crowd.mapper&quot; level=&quot;DEBUG&quot;/&gt; &lt;/configuration&gt; MyBatis的逆向工程 正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的。 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源： Java实体类 Mapper接口 Mapper映射文件 创建逆向工程的步骤 1.添加依赖和插件 &lt;!-- 依赖MyBatis核心包 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 控制Maven在构建过程中相关配置 --&gt; &lt;build&gt; &lt;!-- 构建过程中用到的插件 --&gt; &lt;plugins&gt; &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;!-- 插件的依赖 --&gt; &lt;dependencies&gt; &lt;!-- 逆向工程的核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2.创建MyBatis的核心配置文件 文件名必须是：generatorConfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD（清新简洁版） MyBatis3: 生成带条件的CRUD（奢华尊享版） --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;!-- 数据库的连接信息 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- javaBean的生成策略--&gt; &lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.pojo&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- SQL映射文件的生成策略 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- Mapper接口的生成策略 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 逆向分析的表 --&gt; &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt; &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt; &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt; &lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 3.执行MBG插件的generate目标 效果 QBC查询 @Test public void testMBG() throws IOException { InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSession sqlSession = new SqlSessionFactoryBuilder().build(is).openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); EmpExample empExample = new EmpExample(); //创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系 empExample.createCriteria().andEnameLike(&quot;a&quot;).andAgeGreaterThan(20).andDidIsNotNull(); //将之前添加的条件通过or拼接其他条件 empExample.or().andSexEqualTo(&quot;男&quot;); List&lt;Emp&gt; list = mapper.selectByExample(empExample); for (Emp emp : list) { System.out.println(emp); } } 分页插件 分页插件使用步骤 1.添加依赖 &lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt; &lt;/dependency&gt; 2.配置分页插件 在MyBatis的核心配置文件中配置插件 &lt;plugins&gt; &lt;!--设置分页插件--&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt; &lt;/plugins&gt; 分页插件的使用 在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能 pageNum：当前页的页码 pageSize：每页显示的条数 在查询获取list集合之后，使用PageInfo pageInfo = new PageInfo&lt;&gt;(List list, int navigatePages)获取分页相关数据 list：分页之后的数据 navigatePages：导航分页的页码数 分页相关数据 PageHelper PageInfo{ pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8, list=Page{count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30, pages=8, reasonable=false, pageSizeZero=false}, prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true, hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8, navigatepageNums=[4, 5, 6, 7, 8] } 常用数据： pageNum：当前页的页码 pageSize：每页显示的条数 size：当前页显示的真实条数 total：总记录数 pages：总页数 prePage：上一页的页码 nextPage：下一页的页码 isFirstPage/isLastPage：是否为第一页/最后一页 hasPreviousPage/hasNextPage：是否存在上一页/下一页 navigatePages：导航分页的页码数 navigatepageNums：导航分页的页码，[1,2,3,4,5] ","link":"https://nanteng.github.io/post/mybatis/"},{"title":"Thymeleaf","content":"MVC 提出问题 我们对HTML的新的期待：既能够正常显示页面，又能在页面中包含动态数据部分。而动态数据单靠HTML本身是无法做到的，所以此时我们需要引入服务器端动态视图模板技术。 从三层结构到MVC MVC概念 M：Model模型 V：View视图 C：Controller控制器 MVC是在表述层开发中运用的一种设计理念。主张把封装数据的『模型』、显示用户界面的『视图』、**协调调度的『控制器』**分开。 好处: 进一步实现各个组件之间的解耦 让各个组件可以单独维护 将视图分离出来以后，我们后端工程师和前端工程师的对接更方便 MVC和三层架构之间关系 前后端工程师对接方式 服务器端渲染：前端工程师把前端页面一整套做好交给后端工程师 前后端分离：开会商量JSON格式，然后分头开发。在后端程序尚不可用时，前端工程师会使用Mock.js生成假数据使用，在后端程序可用后再连接实际后端程序获取真实数据。 Thymeleaf简介 Thymeleaf的同行 JSP、Freemarker、Velocity等等，它们有一个共同的名字：服务器端模板技术。 Thymeleaf官方文档中的介绍 https://www.thymeleaf.org/ http://heavy_code_industry.gitee.io/code_heavy_industry/pro001-javaweb/lecture/chapter08/Thymeleaf-3.0.11.pdf Thymeleaf优势 SpringBoot官方推荐使用的视图模板技术，和SpringBoot完美整合。 不经过服务器运算仍然可以直接查看原始值，对前端工程师更友好。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:text=&quot;${hello}&quot;&gt;Original Value&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 物理视图和逻辑视图 物理视图 在Servlet中，将请求转发到一个HTML页面文件时，使用的完整的转发路径就是物理视图。 /pages/user/login_success.html 如果我们把所有的HTML页面都放在某个统一的目录下，那么转发地址就会呈现出明显的规律： /pages/user/login.html /pages/user/login_success.html /pages/user/regist.html /pages/user/regist_success.html …… 路径的开头都是：/pages/user/ 路径的结尾都是：.html 所以，路径开头的部分我们称之为视图前缀，路径结尾的部分我们称之为视图后缀。 逻辑视图 物理视图=视图前缀+逻辑视图+视图后缀 上面的例子中： 视图前缀 逻辑视图 视图后缀 物理视图 /pages/user/ login .html /pages/user/login.html /pages/user/ login_success .html /pages/user/login_success.html 引入Thymeleaf环境 加入jar包 配置上下文参数 物理视图=视图前缀+逻辑视图+视图后缀 &lt;!-- 在上下文参数中配置视图前缀和视图后缀 --&gt; &lt;context-param&gt; &lt;param-name&gt;view-prefix&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/view/&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;view-suffix&lt;/param-name&gt; &lt;param-value&gt;.html&lt;/param-value&gt; &lt;/context-param&gt; 说明：param-value中设置的前缀、后缀的值不是必须叫这个名字，可以根据实际情况和需求进行修改。 为什么要放在WEB-INF目录下？ 原因：WEB-INF目录不允许浏览器直接访问，所以我们的视图模板文件放在这个目录下，是一种保护。以免外界可以随意访问视图模板文件。 访问WEB-INF目录下的页面，都必须通过Servlet转发过来，简单说就是：不经过Servlet访问不了。 这样就方便我们在Servlet中检查当前用户是否有权限访问。 那放在WEB-INF目录下之后，重定向进不去怎么办？ 重定向到Servlet，再通过Servlet转发到WEB-INF下。 创建Servlet基类 这个类直接复制粘贴即可，将来使用框架后，这些代码都将被取代。 import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.WebContext; import org.thymeleaf.templatemode.TemplateMode; import org.thymeleaf.templateresolver.ServletContextTemplateResolver; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class ViewBaseServlet extends HttpServlet { private TemplateEngine templateEngine; @Override public void init() throws ServletException { // 1.获取ServletContext对象 ServletContext servletContext = this.getServletContext(); // 2.创建Thymeleaf解析器对象 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(servletContext); // 3.给解析器对象设置参数 // ①HTML是默认模式，明确设置是为了代码更容易理解 templateResolver.setTemplateMode(TemplateMode.HTML); // ②设置前缀 String viewPrefix = servletContext.getInitParameter(&quot;view-prefix&quot;); templateResolver.setPrefix(viewPrefix); // ③设置后缀 String viewSuffix = servletContext.getInitParameter(&quot;view-suffix&quot;); templateResolver.setSuffix(viewSuffix); // ④设置缓存过期时间（毫秒） templateResolver.setCacheTTLMs(60000L); // ⑤设置是否缓存 templateResolver.setCacheable(true); // ⑥设置服务器端编码方式 templateResolver.setCharacterEncoding(&quot;utf-8&quot;); // 4.创建模板引擎对象 templateEngine = new TemplateEngine(); // 5.给模板引擎对象设置模板解析器 templateEngine.setTemplateResolver(templateResolver); } protected void processTemplate(String templateName, HttpServletRequest req, HttpServletResponse resp) throws IOException { // 1.设置响应体内容类型和字符集 resp.setContentType(&quot;text/html;charset=UTF-8&quot;); // 2.创建WebContext对象 WebContext webContext = new WebContext(req, resp, getServletContext()); // 3.处理模板数据 templateEngine.process(templateName, webContext, resp.getWriter()); } } HelloWorld 创建index.html 在index.html编写超链接 &lt;a href=&quot;/view/TestThymeleafServlet&quot;&gt;初步测试Thymeleaf&lt;/a&gt; 创建Servlet &lt;servlet&gt; &lt;servlet-name&gt;TestThymeleafServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.thymeleaf.servlet.TestThymeleafServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;TestThymeleafServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/TestThymeleafServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 修改Servlet继承的父类 在doGet()方法中跳转到Thymeleaf页面 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1.声明当前请求要前往的视图名称 String viewName = &quot;target&quot;; // 2.调用ViewBaseServlet父类中的解析视图模板的方法 super.processTemplate(viewName, request, response); } Thymeleaf页面 &lt;!DOCTYPE html&gt; &lt;!-- 在html标签内加入Thymeleaf名称空间的声明 --&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 在p标签的基础上，使用Thymeleaf的表达式，解析了一个URL地址 --&gt; &lt;p th:text=&quot;@{'/aaa/bbb/ccc'}&quot;&gt;Thymeleaf将在这里显示一个解析出来的URL地址&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 基本语法 th名称空间 表达式语法 修改标签文本值 代码实例: &lt;p th:text=&quot;标签体新值&quot;&gt;标签体原始值&lt;/p&gt; th:text作用 不经过服务器解析，直接用浏览器打开HTML文件，看到的是『标签体原始值』 经过服务器解析，Thymeleaf引擎根据th:text属性指定的『标签体新值』去替换『标签体原始值』 字面量 『字面量』是一个经常会遇到的概念，我们可以对照『变量』来理解它的含义。 // a是变量，100是字面量 int a = 100; System.out.println(&quot;a = &quot; + a); 变量：变量名字符串本身不是它的值，它指向的才是它的值 字面量：它就是字面上的含义，我们从『字面』上看到的直接就是它的值 现在我们在th:text属性中使用的就是『字面量』，它不指代任何其他值。 修改指定属性值 代码示例: &lt;input type=&quot;text&quot; name=&quot;username&quot; th:value=&quot;文本框新值&quot; value=&quot;文本框旧值&quot; /&gt; 语法：任何HTML标签原有的属性，前面加上『th:』就都可以通过Thymeleaf来设定新值。 解析URL地址 基本语法 代码示例: &lt;p th:text=&quot;@{/aaa/bbb/ccc}&quot;&gt;标签体原始值&lt;/p&gt; /view/aaa/bbb/ccc 所以@{}的作用是在字符串前附加『上下文路径』 这个语法的好处是：实际开发过程中，项目在不同环境部署时，Web应用的名字有可能发生变化。所以上下文路径不能写死。而通过@{}动态获取上下文路径后，不管怎么变都不怕啦！ 首页使用URL地址解析 如果我们直接访问index.html本身，那么index.html是不需要通过Servlet，当然也不经过模板引擎，所以index.html上的Thymeleaf的任何表达式都不会被解析。 解决办法：通过Servlet访问index.html，这样就可以让模板引擎渲染页面了： 进一步的好处： 通过上面的例子我们看到，所有和业务功能相关的请求都能够确保它们通过Servlet来处理，这样就方便我们统一对这些请求进行特定规则的限定。 给URL地址后面附加请求参数 参照官方文档说明： 直接执行表达式 Servlet代码: request.setAttribute(&quot;reqAttrName&quot;, &quot;&lt;span&gt;hello-value&lt;/span&gt;&quot;); 页面代码 &lt;p&gt;有转义效果：[[${reqAttrName}]]&lt;/p&gt; &lt;p&gt;无转义效果：[(${reqAttrName})]&lt;/p&gt; 执行效果: &lt;p&gt;有转义效果：&amp;lt;span&amp;gt;hello-value&amp;lt;/span&amp;gt;&lt;/p&gt; &lt;p&gt;无转义效果：&lt;span&gt;hello-value&lt;/span&gt;&lt;/p&gt; 访问域对象 域对象 请求域 在请求转发的场景下，我们可以借助HttpServletRequest对象内部给我们提供的存储空间，帮助我们携带数据，把数据发送给转发的目标资源。 请求域：HttpServletRequest对象内部给我们提供的存储空间 会话域 应用域 PS：在我们使用的视图是JSP的时候，域对象有4个 pageContext request：请求域 session：会话域 application：应用域 所以在JSP的使用背景下，我们可以说域对象有4个，现在使用Thymeleaf了，没有pageContext。 在Servlet中将数据存入属性域 操作请求域 Servlet中代码： String requestAttrName = &quot;helloRequestAttr&quot;; String requestAttrValue = &quot;helloRequestAttr-VALUE&quot;; request.setAttribute(requestAttrName, requestAttrValue); Thymeleaf表达式： &lt;p th:text=&quot;${helloRequestAttr}&quot;&gt;request field value&lt;/p&gt; 操作会话域 Servlet中的代码: // ①通过request对象获取session对象 HttpSession session = request.getSession(); // ②存入数据 session.setAttribute(&quot;helloSessionAttr&quot;, &quot;helloSessionAttr-VALUE&quot;); Thymeleaf表达式： &lt;p th:text=&quot;${session.helloSessionAttr}&quot;&gt;这里显示会话域数据&lt;/p&gt; 操作应用域 Servlet中代码 // ①通过调用父类的方法获取ServletContext对象 ServletContext servletContext = getServletContext(); // ②存入数据 servletContext.setAttribute(&quot;helloAppAttr&quot;, &quot;helloAppAttr-VALUE&quot;); Thymeleaf表达式： &lt;p th:text=&quot;${application.helloAppAttr}&quot;&gt;这里显示应用域数据&lt;/p&gt; 获取请求参数 具体来说，我们这里探讨的是在页面上（模板页面）获取请求参数。底层机制是： 一个名字一个值 页面代码: &lt;p th:text=&quot;${param.username}&quot;&gt;这里替换为请求参数的值&lt;/p&gt; 页面显示效果： 一个名字多个值 页面代码: &lt;p th:text=&quot;${param.team}&quot;&gt;这里替换为请求参数的值&lt;/p&gt; 页面显式效果: 如果想要精确获取某一个值,可以使用数组下标.页面代码: &lt;p th:text=&quot;${param.team[0]}&quot;&gt;这里替换为请求参数的值&lt;/p&gt; &lt;p th:text=&quot;${param.team[1]}&quot;&gt;这里替换为请求参数的值&lt;/p&gt; 页面显式效果: 内置对象 概念 所谓内置对象其实就是在表达式中可以直接使用的对象。 基本内置对象 用法举例: &lt;h3&gt;表达式的基本内置对象&lt;/h3&gt; &lt;p th:text=&quot;${#request.getClass().getName()}&quot;&gt;这里显示#request对象的全类名&lt;/p&gt; &lt;p th:text=&quot;${#request.getContextPath()}&quot;&gt;调用#request对象的getContextPath()方法&lt;/p&gt; &lt;p th:text=&quot;${#request.getAttribute('helloRequestAttr')}&quot;&gt;调用#request对象的getAttribute()方法，读取属性域&lt;/p&gt; 基本思路: 如果不清楚这个对象有哪些方法可以使用，那么就通过getClass().getName()获取全类名，再回到Java环境查看这个对象有哪些方法 内置对象的方法可以直接调用 调用方法时需要传参的也可以直接传入参数 公共内置对象 Servlet中将List集合数据存入请求域： request.setAttribute(&quot;aNotEmptyList&quot;, Arrays.asList(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;)); request.setAttribute(&quot;anEmptyList&quot;, new ArrayList&lt;&gt;()); 页面代码： &lt;p&gt;#list对象isEmpty方法判断集合整体是否为空aNotEmptyList：&lt;span th:text=&quot;${#lists.isEmpty(aNotEmptyList)}&quot;&gt;测试#lists&lt;/span&gt;&lt;/p&gt; &lt;p&gt;#list对象isEmpty方法判断集合整体是否为空anEmptyList：&lt;span th:text=&quot;${#lists.isEmpty(anEmptyList)}&quot;&gt;测试#lists&lt;/span&gt;&lt;/p&gt; 公共内置对象对应的源码位置： ${}中的表达式本质是OGNL OGNL OGNL : Object-Graph Navigation Language对象-图 导航语言 对象图 从根对象触发，通过特定的语法，逐层访问对象的各种属性。 OGNL语法 起点 在Thymeleaf环境下，${}中的表达式可以从下列元素开始： 访问属性域的起点 请求域属性名 session application param 内置对象 #request #session #lists #strings 属性访问语法 访问对象属性：使用getXxx()、setXxx()方法定义的属性 对象.属性名 访问List集合或数组 集合或数组[下标] 访问Map集合 Map集合.key Map集合['key'] 分支与迭代 分支 if和unless 让标记了th:if,th:unless的标签根据条件决定是否显式. 示例的实体类: public class Employee { private Integer empId; private String empName; private Double empSalary; 示例的Servlet代码： protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 1.创建ArrayList对象并填充 List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;(); employeeList.add(new Employee(1, &quot;tom&quot;, 500.00)); employeeList.add(new Employee(2, &quot;jerry&quot;, 600.00)); employeeList.add(new Employee(3, &quot;harry&quot;, 700.00)); // 2.将集合数据存入请求域 request.setAttribute(&quot;employeeList&quot;, employeeList); // 3.调用父类方法渲染视图 super.processTemplate(&quot;list&quot;, request, response); } 示例的HTML代码: &lt;table&gt; &lt;tr&gt; &lt;th&gt;员工编号&lt;/th&gt; &lt;th&gt;员工姓名&lt;/th&gt; &lt;th&gt;员工工资&lt;/th&gt; &lt;/tr&gt; &lt;tr th:if=&quot;${#lists.isEmpty(employeeList)}&quot;&gt; &lt;td colspan=&quot;3&quot;&gt;抱歉！没有查询到你搜索的数据！&lt;/td&gt; &lt;/tr&gt; &lt;tr th:if=&quot;${not #lists.isEmpty(employeeList)}&quot;&gt; &lt;td colspan=&quot;3&quot;&gt;有数据！&lt;/td&gt; &lt;/tr&gt; &lt;tr th:unless=&quot;${#lists.isEmpty(employeeList)}&quot;&gt; &lt;td colspan=&quot;3&quot;&gt;有数据！&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; if配合not关键词和unless配合原表达式效果是一样的，看自己的喜好。 switch &lt;h3&gt;测试switch&lt;/h3&gt; &lt;div th:switch=&quot;${user.memberLevel}&quot;&gt; &lt;p th:case=&quot;level-1&quot;&gt;银牌会员&lt;/p&gt; &lt;p th:case=&quot;level-2&quot;&gt;金牌会员&lt;/p&gt; &lt;p th:case=&quot;level-3&quot;&gt;白金会员&lt;/p&gt; &lt;p th:case=&quot;level-4&quot;&gt;钻石会员&lt;/p&gt; &lt;/div&gt; 迭代 &lt;h3&gt;测试each&lt;/h3&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;员工编号&lt;/th&gt; &lt;th&gt;员工姓名&lt;/th&gt; &lt;th&gt;员工工资&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody th:if=&quot;${#lists.isEmpty(employeeList)}&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;抱歉！没有查询到你搜索的数据！&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody th:if=&quot;${not #lists.isEmpty(employeeList)}&quot;&gt; &lt;!-- 遍历出来的每一个元素的名字 : ${要遍历的集合} --&gt; &lt;tr th:each=&quot;employee : ${employeeList}&quot;&gt; &lt;td th:text=&quot;${employee.empId}&quot;&gt;empId&lt;/td&gt; &lt;td th:text=&quot;${employee.empName}&quot;&gt;empName&lt;/td&gt; &lt;td th:text=&quot;${employee.empSalary}&quot;&gt;empSalary&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 在迭代过程中，可以参考下面的说明使用迭代状态： &lt;h3&gt;测试each&lt;/h3&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;员工编号&lt;/th&gt; &lt;th&gt;员工姓名&lt;/th&gt; &lt;th&gt;员工工资&lt;/th&gt; &lt;th&gt;迭代状态&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody th:if=&quot;${#lists.isEmpty(employeeList)}&quot;&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;抱歉！没有查询到你搜索的数据！&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tbody th:if=&quot;${not #lists.isEmpty(employeeList)}&quot;&gt; &lt;!-- 遍历出来的每一个元素的名字 : ${要遍历的集合} --&gt; &lt;tr th:each=&quot;employee,empStatus : ${employeeList}&quot;&gt; &lt;td th:text=&quot;${employee.empId}&quot;&gt;empId&lt;/td&gt; &lt;td th:text=&quot;${employee.empName}&quot;&gt;empName&lt;/td&gt; &lt;td th:text=&quot;${employee.empSalary}&quot;&gt;empSalary&lt;/td&gt; &lt;td th:text=&quot;${empStatus.count}&quot;&gt;count&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 包其他模板文件 应用场景 抽取各个页面的公共部分 创建页面的代码片段 使用th:fragment来给这个片段命名： &lt;div th:fragment=&quot;header&quot;&gt; &lt;p&gt;被抽取出来的头部内容&lt;/p&gt; &lt;/div&gt; 包含到有需要的页面 语法 效果 th:insert 把目标的代码片段整个插入到当前标签内部 th:replace 用目标的代码替换当前标签 th:include 把目标的代码片段去除最外层标签，然后再插入到当前标签内部 页面代码举例: &lt;!-- 代码片段所在页面的逻辑视图 :: 代码片段的名称 --&gt; &lt;div id=&quot;badBoy&quot; th:insert=&quot;segment :: header&quot;&gt; div标签的原始内容 &lt;/div&gt; &lt;div id=&quot;worseBoy&quot; th:replace=&quot;segment :: header&quot;&gt; div标签的原始内容 &lt;/div&gt; &lt;div id=&quot;worstBoy&quot; th:include=&quot;segment :: header&quot;&gt; div标签的原始内容 &lt;/div&gt; 代码重工 ","link":"https://nanteng.github.io/post/thymeleaf/"},{"title":"Spring5框架","content":"Spring5框架概述 Spring是轻量级的开源的JavaEE框架 Spring可以解决企业应用开发的复杂性 Spring有两个核心部分：IOC和AOP IOC：控制反转，把创建对象过程交给 Spring 进行管理 Aop：面向切面，不修改源代码进行功能增强 Spring 特点 方便解耦，简化开发 Aop 编程支持 方便程序测试 方便和其他框架进行整合 方便进行事务操作 降低 API 开发难度 IOC(概念和原理) 什么是 IOC 控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理 使用 IOC 目的：为了耦合度降低 IOC 底层原理 xml 解析、工厂模式、反射 画图讲解 IOC 底层原理 IOC（BeanFactory 接口） IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂 Spring 提供 IOC 容器实现两种方式：（两个接口） BeanFactory：IOC 容器基本实现，是 Spring 内部的使用接口，不提供开发人员进行使用 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 ApplicationContext：BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用 加载配置文件时候就会把在配置文件对象进行创建 ApplicationContext 接口有实现类 IOC 操作Bean管理（概念） 什么是 Bean 管理 Bean 管理指的是两个操作 Spring 创建对象 Spirng 注入属性 Bean 管理操作有两种方式 基于 xml 配置文件方式实现 基于注解方式实现 IOC 操作Bean管理（基于 xml 方式） 基于 xml 方式创建对象 &lt; !--配置User对象创建-- &gt; &lt;bean id=&quot;user&quot; class=&quot;com.nanteng.spring5.User&quot;&gt;&lt;/bean&gt; 在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建 在 bean 标签有很多属性，介绍常用的属性 id 属性：唯一标识 class 属性：类全路径（包类路径） 基于 xml 方式注入属性 DI：依赖注入，就是注入属性 第一种注入方式：使用 set 方法进行注入' 创建类，定义属性和对应的 set 方法 /** * 演示使用 set 方法进行注入属性 */ public class Book { //创建属性 private String bname; private String bauthor; //创建属性对应的 set 方法 public void setBname(String bname) { this.bname = bname; } public void setBauthor(String bauthor) { this.bauthor = bauthor; } } 在 spring 配置文件配置对象创建，配置属性注入 &lt; !--2 set 方法注入属性-- &gt; &lt;bean id=&quot;book&quot; class=&quot;com.nanteng.spring5.Book&quot;&gt; &lt; !--使用 property 完成属性注入 name：类里面属性名称 value：向属性注入的值 -- &gt; &lt;property name=&quot;bname&quot; value=&quot;易筋经&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;达摩老祖&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 第二种注入方式：使用有参数构造进行注入 创建类，定义属性，创建属性对应有参数构造方法 /** * 使用有参数构造注入 */ public class Orders { //属性 private String oname; private String address; //有参数构造 public Orders(String oname,String address) { this.oname = oname; this.address = address; } } 在 spring 配置文件中进行配置 &lt; !--3 有参数构造注入属性-- &gt; &lt;bean id=&quot;orders&quot; class=&quot;com.nanteng.spring5.Orders&quot;&gt; &lt;constructor-arg name=&quot;oname&quot; value=&quot;电脑&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; p名称空间注入 使用 p 名称空间注入，可以简化基于 xml 配置方式 第一步 添加 p 名称空间在配置文件中 进行属性注入，在 bean 标签里面进行操作 &lt;!--2 set 方法注入属性--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.nanteng.spring5.Book&quot; p:bname=&quot;九阳神功&quot; p:bauthor=&quot;无名氏&quot;&gt;&lt;/bean&gt; IOC操作Bean管理（xml 注入其他类型属性） 字面量 null 值 &lt;!--null 值--&gt; &lt;property name=&quot;address&quot;&gt; &lt;null/&gt; &lt;/property&gt; 属性值包含特殊符号 &lt;!--属性值包含特殊符号 1 把&lt;&gt;进行转义 &amp;lt; &amp;gt; 2 把带特殊符号内容写到 CDATA --&gt; &lt;property name=&quot;address&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;南京&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt; 注入属性-外部 bean 创建两个类 service 类和 dao 类 在 service 调用 dao 里面的方法 在 spring 配置文件中进行配置 public class UserService { //创建 UserDao 类型属性，生成 set 方法 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add() { System.out.println(&quot;service add...............&quot;); userDao.update(); } } &lt;!--1 service 和 dao 对象创建--&gt; &lt;bean id=&quot;userService&quot; class=&quot;com.nanteng.spring5.service.UserService&quot;&gt; &lt;!--注入 userDao 对象 name 属性：类里面属性名称 ref 属性：创建 userDao 对象 bean 标签 id 值 --&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDaoImpl&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;com.nanteng.spring5.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; 注入属性-内部 bean 一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门 部门是一，员工是多 在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示 //部门类 public class Dept { private String dname; public void setDname(String dname) { this.dname = dname; } } //员工类 public class Emp { private String ename; private String gender; //员工属于某一个部门，使用对象形式表示 private Dept dept; public void setDept(Dept dept) { this.dept = dept; } public void setEname(String ename) { this.ename = ename; } public void setGender(String gender) { this.gender = gender; } } 在 spring 配置文件中进行配置 &lt;!--内部 bean--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--设置对象类型属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 注入属性-级联赋值 第一种写法 &lt;!--级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 2.第二种写法 //员工属于某一部门，使用对象形式表示 private Dept dept; //生成dept的get方法 public Dept getDept(){ return dept; } public void setDept(Dept dept){ this.dept = dept; } &lt;!--级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.bean.Emp&quot;&gt; &lt;!--设置两个普通属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;lucy&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; IOC操作Bean管理（xml 注入集合属性） 注入数组类型属性 注入 List 集合类型属性 注入 Map 集合类型属性 创建类，定义数组、list、map、set 类型属性，生成对应 set 方法 public class Stu { //1 数组类型属性 private String[] courses; //2 list 集合类型属性 private List&lt;String&gt; list; //3 map 集合类型属性 private Map&lt;String,String&gt; maps; //4 set 集合类型属性 private Set&lt;String&gt; sets; public void setSets(Set&lt;String&gt; sets) { this.sets = sets; } public void setCourses(String[] courses) { this.courses = courses; } public void setList(List&lt;String&gt; list) { this.list = list; } public void setMaps(Map&lt;String, String&gt; maps) { this.maps = maps; } } 在 spring 配置文件进行配置 &lt;!--1 集合类型属性注入--&gt; &lt;bean id=&quot;stu&quot; class=&quot;com.atguigu.spring5.collectiontype.Stu&quot;&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=&quot;courses&quot;&gt; &lt;array&gt; &lt;value&gt;java 课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list 类型属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小三&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map 类型属性注入--&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;PHP&quot; value=&quot;php&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set 类型属性注入--&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 在集合里面设置对象类型值 &lt;!--创建多个 course 对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;Spring5 框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;com.atguigu.spring5.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;MyBatis 框架&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--注入 list 集合类型，值是对象--&gt; &lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 把集合注入部分提取出来 在 spring 配置文件中引入名称空间 util &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; 2.使用 util 标签完成 list 集合注入提取 &lt;!--1 提取 list 集合类型属性注入--&gt; &lt;util:list id=&quot;bookList&quot;&gt; &lt;value&gt;易筋经&lt;/value&gt; &lt;value&gt;九阴真经&lt;/value&gt; &lt;value&gt;九阳神功&lt;/value&gt; &lt;/util:list&gt; &lt;!--2 提取 list 集合类型属性注入使用--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.collectiontype.Book&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;bookList&quot;&gt;&lt;/property&gt; &lt;/bean&gt; IOC 操作 Bean 管理（FactoryBean） Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean） 普通 bean：在配置文件中定义 bean 类型就是返回类型 工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 ​ 第一步：创建类，让这个类作为工厂 bean，实现接口 FactoryBean ​ 第二布： 实现接口里面的方法，在实现的方法中定义返回的 bean 类型 public class MyBean implements FactoryBean&lt;Course&gt; { //定义返回 bean @Override public Course getObject() throws Exception { Course course = new Course(); course.setCname(&quot;abc&quot;); return course; } @Override public Class&lt;?&gt; getObjectType() { return null; } @Override public boolean isSingleton() { return false; } } &lt;bean id=&quot;myBean&quot; class=&quot;com.atguigu.spring5.factorybean.MyBean&quot;&gt; &lt;/bean&gt; @Test public void test3() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean3.xml&quot;); Course course = context.getBean(&quot;myBean&quot;, Course.class); System.out.println(course); } IOC 操作 Bean 管理（bean 作用域） 在 Spring 里面，设置创建 bean 实例是单实例还是多实例 在 Spring 里面，默认情况下，bean 是单实例对象 如何设置单实例还是多实例 在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例 scope 属性值 默认值，singleton，表示是单实例对象 prototype，表示是多实例对象 singleton 和 prototype 区别 singleton 单实例，prototype 多实例 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean 方法时候创建多实例对象 IOC 操作 Bean 管理（bean 生命周期） 生命周期 从对象创建到对象销毁的过程 bean 生命周期 通过构造器创建 bean 实例（无参数构造） 为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） 调用 bean 的初始化的方法（需要进行配置初始化的方法） bean 可以使用了（对象获取到了） 当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 演示 bean 生命周期 public class Orders { //无参数构造 public Orders() { System.out.println(&quot;第一步 执行无参数构造创建 bean 实例&quot;); } private String oname; public void setOname(String oname) { this.oname = oname; System.out.println(&quot;第二步 调用 set 方法设置属性值&quot;); } //创建执行的初始化的方法 public void initMethod() { System.out.println(&quot;第三步 执行初始化的方法&quot;); } //创建执行的销毁的方法 public void destroyMethod() { System.out.println(&quot;第五步 执行销毁的方法&quot;); } } &lt;bean id=&quot;orders&quot; class=&quot;com.atguigu.spring5.bean.Orders&quot; init\u0002method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt; &lt;property name=&quot;oname&quot; value=&quot;手机&quot;&gt;&lt;/property&gt; &lt;/bean&gt; @Test public void testBean3() { // ApplicationContext context = // new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;); Orders orders = context.getBean(&quot;orders&quot;, Orders.class); System.out.println(&quot;第四步 获取创建 bean 实例对象&quot;); System.out.println(orders); //手动让 bean 实例销毁 context.close(); } bean 的后置处理器，bean 生命周期有七步 通过构造器创建 bean 实例（无参数构造） 为 bean 的属性设置值和对其他 bean 引用（调用 set 方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization 调用 bean 的初始化的方法（需要进行配置初始化的方法） 把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization bean 可以使用了（对象获取到了） 当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 演示添加后置处理器效果 创建类，实现接口 BeanPostProcessor，创建后置处理器 public class MyBeanPost implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(&quot;在初始化之前执行的方法&quot;); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(&quot;在初始化之后执行的方法&quot;); return bean; } } &lt;!--配置后置处理器--&gt; &lt;bean id=&quot;myBeanPost&quot; class=&quot;com.atguigu.spring5.bean.MyBeanPost&quot;&gt;&lt;/bean&gt; IOC 操作 Bean 管理（xml 自动装配） 什么是自动装配 根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入 演示自动装配过程 根据属性名称自动注入 &lt;!--实现自动装配 bean 标签属性 autowire，配置自动装配 autowire 属性常用两个值： byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样 byType 根据属性类型注入 --&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean&gt; 根据属性类型自动注入 &lt;!--实现自动装配 bean 标签属性 autowire，配置自动装配 autowire 属性常用两个值： byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样 byType 根据属性类型注入 --&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.atguigu.spring5.autowire.Emp&quot; autowire=&quot;byType&quot;&gt; &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.atguigu.spring5.autowire.Dept&quot;&gt;&lt;/bean IOC 操作 Bean 管理(外部属性文件) 直接配置数据库信息 配置德鲁伊连接池 引入德鲁伊连接池依赖 jar 包 &lt;!--直接配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/userDb&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 引入外部属性文件配置数据库连接池 创建外部属性文件，properties 格式文件，写数据库信息 把外部 properties 属性文件引入到 spring 配置文件中 引入 context 名称空间 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; 在 spring 配置文件使用标签引入外部属性文件 &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${prop.driverClass}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;${prop.url}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;${prop.userName}&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;${prop.password}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; IOC操作Bean管理（基于注解方式） 什么是注解 注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..) 使用注解，注解作用在类上面，方法上面，属性上面 使用注解目的：简化 xml 配置 Spring 针对 Bean 管理中创建对象提供注解 @Component @Service @Controller @Repository 上面四个注解功能是一样的，都可以用来创建 bean 实例 基于注解方式实现对象创建 引入依赖 开启组件扫描 &lt;!--开启组件扫描 1 如果扫描多个包，多个包使用逗号隔开 2 扫描包上层目录 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; 创建类，在类上面添加创建对象注解 //在注解里面 value 属性值可以省略不写， //默认值是类名称，首字母小写 //UserService -- userService @Component(value = &quot;userService&quot;) //&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt; public class UserService { public void add() { System.out.println(&quot;service add.......&quot;); } } 开启组件扫描细节配置 &lt;!--示例 1 use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter context:include-filter ，设置扫描哪些内容 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--示例 2 下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; 基于注解方式实现属性注入 @Autowired：根据属性类型进行自动装配 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解 @Service public class UserService { //定义 dao 类型属性 //不需要添加 set 方法 //添加注入属性注解 @Autowired private UserDao userDao; public void add() { System.out.println(&quot;service add.......&quot;); userDao.add(); } } @Qualifier：根据名称进行注入（这个@Qualifier 注解的使用，和上面@Autowired 一起使用） //定义 dao 类型属性 //不需要添加 set 方法 //添加注入属性注解 @Autowired //根据类型进行注入 @Qualifier(value = &quot;userDaoImpl1&quot;) //根据名称进行注入 private UserDao userDao; @Resource：可以根据类型注入，可以根据名称注入 //@Resource //根据类型进行注入 @Resource(name = &quot;userDaoImpl1&quot;) //根据名称进行注入 private UserDao userDao; @Value：注入普通类型属性 @Value(value = &quot;abc&quot;) private String name; 完全注解开发 创建配置类，替代 xml 配置文件 @Configuration //作为配置类，替代 xml 配置文件 @ComponentScan(basePackages = {&quot;com.atguigu&quot;}) public class SpringConfig { } 2.编写测试类 @Test public void testService2() { //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); } AOP(概念) 什么是AOP 面向切面编程（方面），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 通俗描述：不通过修改源代码方式，在主干功能里面添加新功能 使用登录例子说明 AOP AOP(底层原理) AOP底层使用动态代理 有两种情况动态代理 有接口情况，使用JDK动态代理 创建接口实现类代理对象，增强类的方法 没有接口情况，使用CGKIB动态代理 创建子类的代理对象，增强类的方法 AOP(JDK动态代理) 使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象 调用 newProxyInstance 方法 方法有三个参数： 第一参数，类加载器 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分 编写 JDK 动态代理代码 创建接口，定义方法 public interface UserDao { public int add(int a,int b); public String update(String id); } 创建接口实现类，实现方法 public class UserDaoImpl implements UserDao { @Override public int add(int a, int b) { return a+b; } @Override public String update(String id) { return id; } } 使用 Proxy 类创建接口代理对象 public class JDKProxy { public static void main(String[] args) { //创建接口实现类代理对象 Class[] interfaces = {UserDao.class}; // Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() { // @Override // public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // return null; // } // }); UserDaoImpl userDao = new UserDaoImpl(); UserDao dao = (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,new UserDaoProxy(userDao)); int result = dao.add(1, 2); System.out.println(&quot;result:&quot;+result); } } //创建代理对象代码 class UserDaoProxy implements InvocationHandler { //1 把创建的是谁的代理对象，把谁传递过来 //有参数构造传递 private Object obj; public UserDaoProxy(Object obj) { this.obj = obj; } //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //方法之前 System.out.println(&quot;方法之前执行....&quot;+method.getName()+&quot; :传递的参 数...&quot;+ Arrays.toString(args)); //被增强的方法执行 Object res = method.invoke(obj, args); //方法之后 System.out.println(&quot;方法之后执行....&quot;+obj); return res; } } AOP术语 连接点：类里面可以被增强的方法 切入点：实际被增强的方法，称为切入点 通知（增强） 实际增强的逻辑部分称为通知（增强） 通知有多种类型 前置通知 后置通知 环绕通知 异常通知 最终通知 切面 把通知应用到切入点的过程 AOP操作（准备工作） Spring 框架一般都是基于 AspectJ 实现 AOP 操作 AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作 基于 AspectJ 实现 AOP 操作 基于 xml 配置文件实现 基于注解方式实现（使用） 在项目工程里面引入 AOP 相关依赖 切入点表达式 切入点表达式作用：知道对哪个类里面的哪个方法进行增强 语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) ) 例1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 ​ execution(* com.atguigu.dao.BookDao.add(..)) 例2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 ​ execution(* com.atguigu.dao.BookDao.* (..)) 例3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 execution(* com.atguigu.dao.*.* (..)) AOP操作（AspectJ 注解） 创建类，在类里面定义方法 public class User { public void add() { System.out.println(&quot;add.......&quot;); } } 创建增强类（编写增强逻辑） 在增强类里面，创建方法，让不同方法代表不同通知类型 //增强的类 public class UserProxy { public void before() {//前置通知 System.out.println(&quot;before......&quot;); } } 进行通知的配置 在 spring 配置文件中，开启注解扫描 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base\u0002package=&quot;com.atguigu.spring5.aopanno&quot;&gt;&lt;/context:component-scan&gt; 使用注解创建 User 和 UserProxy 对象 //被增强的类 @Component public class User {} //增强的类 @Component public class UserProxy {} 在增强类上面添加注解 @Aspect //增强的类 @Component @Aspent //生成代理对象 public class UserProxy {} 在 spring 配置文件中开启生成代理对象 &lt;!-- 开启 Aspect 生成代理对象--&gt; 配置不同类型的通知 在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 //增强的类 @Component @Aspect //生成代理对象 public class UserProxy { //前置通知 //@Before 注解表示作为前置通知 @Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void before() { System.out.println(&quot;before.........&quot;); } //后置通知（返回通知） @AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void afterReturning() { System.out.println(&quot;afterReturning.........&quot;); } //最终通知 @After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void after() { System.out.println(&quot;after.........&quot;); } //异常通知 @AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void afterThrowing() { System.out.println(&quot;afterThrowing.........&quot;); } //环绕通知 @Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(&quot;环绕之前.........&quot;); //被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后.........&quot;); } } 相同的切入点抽取 //相同切入点抽取 @Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;) public void pointdemo() { } //前置通知 //@Before 注解表示作为前置通知 @Before(value = &quot;pointdemo()&quot;) public void before() { System.out.println(&quot;before.........&quot;); } 有多个增强类多同一个方法进行增强，设置增强类优先级 在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 @Component @Aspect @Order(1) public class PersonProxy 完全使用注解开发 创建配置类，不需要创建 xml 配置文件 @Configuration @ComponentScan(basePackages = {&quot;com.atguigu&quot;}) @EnableAspectJAutoProxy(proxyTargetClass = true) public class ConfigAop { } AOP操作（AspectJ 配置文件） 创建两个类，增强类和被增强类，创建方法 在 spring 配置文件中创建两个类对象 &lt;!--创建对象--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.aopxml.Book&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;bookProxy&quot; class=&quot;com.atguigu.spring5.aopxml.BookProxy&quot;&gt;&lt;/bean&gt; 在 spring 配置文件中配置切入点 &lt;!--配置 aop 增强--&gt; &lt;aop:config&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* com.atguigu.spring5.aopxml.Book.buy(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=&quot;bookProxy&quot;&gt; &lt;!--增强作用在具体的方法上--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; JdbcTemplate(概念和准备) 什么是 JdbcTemplate Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 准备工作 引入相关 jar 包 在 spring 配置文件配置数据库连接池 &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///user_db&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;/bean&gt; 配置 JdbcTemplate 对象，注入 DataSource &lt;!-- JdbcTemplate 对象 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--注入 dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象 配置文件 &lt;!-- 组件扫描 --&gt; &lt;context:component-scan base-package=&quot;com.atguigu&quot;&gt;&lt;/context:component-scan&gt; Service @Service public class BookService { //注入 dao @Autowired private BookDao bookDao; } Dao @Repository public class BookDaoImpl implements BookDao { //注入 JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; } JdbcTemplate 操作数据库（添加） 对应数据库创建实体类 public class User { private String userId; private String username; private String ustatus; public void setUserId(String userId) { this.userId = userId; } public void setUsername(String username) { } public void setUstatus(String usatus) { } } 编写 service 和 dao 在 dao 进行数据库添加操作 调用 JdbcTemplate 对象里面 update 方法实现添加操作 update(String sql,Object...args) 第一个参数：sql语句 第二个参数：可变参数，设置sql语句值 @Repository public class BookDaoImpl implements BookDao { //注入 JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; //添加的方法 @Override public void add(Book book) { //1 创建 sql 语句 String sql = &quot;insert into t_book values(?,?,?)&quot;; //2 调用方法实现 Object[] args = {book.getUserId(), book.getUsername(), book.getUstatus()}; int update = jdbcTemplate.update(sql,args); System.out.println(update); } } 测试类 @Test public void testJdbcTemplate() { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); BookService bookService = context.getBean(&quot;bookService&quot;, BookService.class); Book book = new Book(); book.setUserId(&quot;1&quot;); book.setUsername(&quot;java&quot;); book.setUstatus(&quot;a&quot;); bookService.addBook(book); } 对应表中字段 user_id username ustaus 1 java a JdbcTemplate 操作数据库（修改和删除） 修改 @Override public void updateBook(Book book) { String sql = &quot;update t_book set username=?,ustatus=? where user_id=?&quot;; Object[] args = {book.getUsername(), book.getUstatus(),book.getUserId()}; int update = jdbcTemplate.update(sql, args); System.out.println(update); } 删除 @Override public void delete(String id) { String sql = &quot;delete from t_book where user_id=?&quot;; int update = jdbcTemplate.update(sql, id); System.out.println(update); } JdbcTemplate 操作数据库（查询返回某个值） 查询表里面有多少条记录，返回是某个值 使用 JdbcTemplate 实现查询返回某个值代码 queryForObject(String sql,Class&lt;T&gt; requiredType) 第一个参数：sql 语句 第二个参数：返回类型 Class //查询表记录数 @Override public int selectCount() { String sql = &quot;select count(*) from t_book&quot;; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); return count; } JdbcTemplate 操作数据库（查询返回对象） 场景：查询图书详情 JdbcTemplate 实现查询返回对象 queryForObject(String sql,RowMapper&lt;T&gt; rowMapper,Object... args) 第一个参数：sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装 第三个参数：sql 语句值 //查询返回集合 @Override public List&lt;Book&gt; findAllBook() { String sql = &quot;select * from t_book&quot;; //调用方法 List&lt;Book&gt; bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;Book&gt;(Book.class)); return bookList; } JdbcTemplate 操作数据库（批量操作） 批量操作：操作表里面多条记录 JdbcTemplate 实现批量添加操作 batchUpdate(String sql,List&lt;Object[]&gt; batchArgs) 第一个参数：sql 语句 第二个参数：List 集合，添加多条记录数据 //批量添加 @Override public void batchAddBook(List&lt;Object[]&gt; batchArgs) { String sql = &quot;insert into t_book values(?,?,?)&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints)); } //批量添加测试 List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); Object[] o1 = {&quot;3&quot;,&quot;java&quot;,&quot;a&quot;}; Object[] o2 = {&quot;4&quot;,&quot;c++&quot;,&quot;b&quot;}; Object[] o3 = {&quot;5&quot;,&quot;MySQL&quot;,&quot;c&quot;}; batchArgs.add(o1); batchArgs.add(o2); batchArgs.add(o3); //调用批量添加 bookService.batchAdd(batchArgs); JdbcTemplate 实现批量修改操作 //批量修改 @Override public void batchUpdateBook(List&lt;Object[]&gt; batchArgs) { String sql = &quot;update t_book set username=?,ustatus=? where user_id=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints)); } //批量修改 List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); Object[] o1 = {&quot;java0909&quot;,&quot;a3&quot;,&quot;3&quot;}; Object[] o2 = {&quot;c++1010&quot;,&quot;b4&quot;,&quot;4&quot;}; Object[] o3 = {&quot;MySQL1111&quot;,&quot;c5&quot;,&quot;5&quot;}; batchArgs.add(o1); batchArgs.add(o2); batchArgs.add(o3); //调用方法实现批量修改 bookService.batchUpdate(batchArgs); JdbcTemplate 实现批量删除操作 //批量删除 @Override public void batchDeleteBook(List&lt;Object[]&gt; batchArgs) { String sql = &quot;delete from t_book where user_id=?&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints)); } //批量删除 List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;(); Object[] o1 = {&quot;3&quot;}; Object[] o2 = {&quot;4&quot;}; batchArgs.add(o1); batchArgs.add(o2); //调用方法实现批量删除 bookService.batchDelete(batchArgs); 事务操作（事务概念） 什么是事务 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操 作都失败 典型场景：银行转账 lucy 转账 100 元 给 mary lucy 少 100，mary 多 100 事务四个特性（ACID） 原子性 一致性 隔离性 持久性 事务操作（搭建事务操作环境） 创建数据库表，添加记录 id username money 1 lucy 1000 2 mary 1000 创建 service，搭建 dao，完成对象创建和注入关系 service 注入 dao，在 dao 注入 JdbcTemplate，在 JdbcTemplate 注入 DataSource @Service public class UserService { //注入 dao @Autowired private UserDao userDao; } @Repository public class UserDaoImpl implements UserDao { @Autowired private JdbcTemplate jdbcTemplate; } 在 dao 创建两个方法：多钱和少钱的方法，在 service 创建方法（转账的方法） @Repository public class UserDaoImpl implements UserDao { @Autowired private JdbcTemplate jdbcTemplate; //lucy 转账 100 给 mary //少钱 @Override public void reduceMoney() { String sql = &quot;update t_account set money=money-? where username=?&quot;; jdbcTemplate.update(sql,100,&quot;lucy&quot;); } //多钱 @Override public void addMoney() { String sql = &quot;update t_account set money=money+? where username=?&quot;; jdbcTemplate.update(sql,100,&quot;mary&quot;); } } @Service public class UserService { //注入 dao @Autowired private UserDao userDao; //转账的方法 public void accountMoney() { //lucy 少 100 userDao.reduceMoney(); //mary 多 100 userDao.addMoney(); } } 上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常，有问题 //转账的方法 public void accountMoney() { //lucy少100 userDao.reduceMoney(); //模拟异常 int i = 10/0; //mary多100 userDao.addMoney(); } 使用事务解决上述问题 事务的操作过程 public void addcountMoney(){ try{ //第一步 开启事务 //第二部 进行业务操作 //lucy 少100 userDao.reduceMoney(); //模拟异常 int i = 10/0; //mary多100 userDao.addMoney(); //第三步 没有发生异常，提高事务 }catch(Exception e){ //第四步 出现异常，事务回滚 } } 事务操作（Spring 事务管理介绍） 事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 在Spring进行事务管理操作 编程式事务管理 声明式事务管理（使用） 声明事务管理 基于注解方式（使用） 基于XML配置文件方式 在Spring进行声明式事务管理，底层使用AOP原理 在Spring事务管理API 提供了一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类 事务操作（注解声明式事务管理） 在 spring 配置文件配置事务管理器 &lt;!-- 创建事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 在 spring 配置文件，开启事务注解 在 spring 配置文件引入名称空间 tx &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; 开启事务注解 &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 在 service 类上面（或者 service 类里面方法上面）添加事务注解 @Transactional，这个注解添加到类上面，也可以添加方法上面 如果把这个注解添加类上面，这个类里面所有的方法都添加事务 如果把这个注解添加方法上面，为这个方法添加事务 @Service @Transactional public class UserSerivice{ } 事务操作（声明式事务管理参数配置） 在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数 propagation：事务传播行为 当一个事务方法被另外一个事务方法调用时候，这个事务方法如何进行 REQUIRED 如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行 REQUIRED_NEW 当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，必须将它挂起。 SUPPORTS 如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中。 事务的传播行为可以有传播属性指定，Spring定义了7种类传播行为。 ioslation:事务的隔离级别 事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题 有三个读问题：脏读、不可重复读、虚（幻）读 脏读：一个未提交事务读取到另一个未提交事务的数据（致命缺陷） 不可重复读：一个未提交事务读取到另一提交事务修改数据 虚读：一个未提交事务读取到另一提交事务添加数据 解决：通过设置事务隔离级别，解决读问题 timeout：超时时间 事务需要在一定时间内进行提交，如果不提交进行回滚 默认值是 -1 ，设置时间以秒单位进行计算 readOnly：是否只读 读：查询操作，写：添加修改删除操作 readOnly 默认值 false，表示可以查询，可以添加修改删除操作 设置 readOnly 值是 true，设置成 true 之后，只能查询 rollbackFor：回滚 设置出现哪些异常进行事务回滚 noRollbackFor：不回滚 设置出现哪些异常不进行事务回滚 事务操作（XML 声明式事务管理） 在 spring 配置文件中进行配置 配置事务管理器 配置通知 配置切入点和切面 &lt;!--1 创建事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--2 配置通知--&gt; &lt;tx:advice id=&quot;txadvice&quot;&gt; &lt;!--配置事务参数--&gt; &lt;tx:attributes&gt; &lt;!--指定哪种规则的方法上面添加事务--&gt; &lt;tx:method name=&quot;accountMoney&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--3 配置切入点和切面--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.atguigu.spring5.service.UserService.*(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:config&gt; 事务操作（完全注解声明式事务管理） 创建配置类，使用配置类替代 xml 配置文件 @Configuration //配置类 @ComponentScan(basePackages = &quot;com.atguigu&quot;) //组件扫描 @EnableTransactionManagement //开启事务 public class TxConfig { //创建数据库连接池 @Bean public DruidDataSource getDruidDataSource() { DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql:///user_db&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; } //创建 JdbcTemplate 对象 @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource) { //到 ioc 容器中根据类型找到 dataSource JdbcTemplate jdbcTemplate = new JdbcTemplate(); //注入 dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; } //创建事务管理器 @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) { DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } } Spring5 框架新功能 整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方 法在代码库中删除 Spring 5.0 框架自带了通用的日志封装 Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2 Spring5 框架整合 Log4j2 第一步 引入 jar 包 第二步 创建 log4j2.xml 配置文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt; &lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置， 当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt; &lt;configuration status=&quot;INFO&quot;&gt; &lt;!--先定义所有的 appender--&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt; &lt;/console&gt; &lt;/appenders&gt; &lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt; &lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为 默认的日志输出--&gt; &lt;loggers&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; Spring5 框架核心容器支持@Nullable 注解 @Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以 为空，参数值可以为空 注解用在方法上面，方法返回值可以为空 @Nullable String getId(); 注解使用在方法参数里面，方法参数可以为空 public &lt;T&gt; void registerBean(@Nullable String beanName,... 注解使用在属性上面，属性值可以为空 @Nullable private String bookName; Spring5 核心容器支持函数式风格 GenericApplicationContext //函数式风格创建对象，交给 spring 进行管理 @Test public void testGenericApplicationContext() { //1 创建 GenericApplicationContext 对象 GenericApplicationContext context = new GenericApplicationContext(); //2 调用 context 的方法对象注册 context.refresh(); context.registerBean(&quot;user1&quot;,User.class,() -&gt; new User()); //3 获取在 spring 注册的对象 // User user =(User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;); User user = (User)context.getBean(&quot;user1&quot;); System.out.println(user); } Spring5 支持整合 JUnit5 整合 JUnit4 第一步 引入 Spring 相关针对测试依赖 第二步 创建测试类，使用注解方式完成 @RunWith(SpringJUnit4ClassRunner.class) //单元测试框架 @ContextConfiguration(&quot;classpath:bean1.xml&quot;) //加载配置文件 public class JTest4 { @Autowired private UserService userService; @Test public void test1() { userService.accountMoney(); } } Spring5 整合 JUnit5 第一步 引入 JUnit5 的 jar 包 第二步 创建测试类，使用注解完成 @ExtendWith(SpringExtension.class) @ContextConfiguration(&quot;classpath:bean1.xml&quot;) public class JTest5 { @Autowired private UserService userService; @Test public void test1() { userService.accountMoney(); } } 使用一个复合注解替代上面两个注解完成整合 @SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;) public class JTest5 { @Autowired private UserService userService; @Test public void test1() { userService.accountMoney(); } } Spring5 框架新功能（Webflux） SpringWebflux 介绍 是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的，Webflux 使用 当前一种比较流程响应式编程出现的框架。 使用传统 web 框架，比如 SpringMVC，这些基于 Servlet 容器，Webflux 是一种异步非阻 塞的框架，异步非阻塞的框架在 Servlet3.1 以后才支持，核心是基于 Reactor 的相关 API 实现 的。 什么是异步非阻塞? 异步和同步 异步和同步针对调用者，调用者发送请求，如果等着对方回应之后才去做其他事情就是同 步，如果发送请求之后不等着对方回应就去做其他事情就是异步 非阻塞和阻塞 阻塞和非阻塞针对被调用者，被调用者受到请求之后，做完请求任务之后才给出反馈就是阻 塞，受到请求之后马上给出反馈然后再去做事情就是非阻塞 针对对象不一样 Webflux 特点： 非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程 函数式编程：Spring5 框架基于 java8，Webflux 使用 Java8 函数式编程方式实现路由请求 比较 SpringMVC 两个框架都可以使用注解方式，都运行在 Tomet 等容器中 SpringMVC 采用命令式编程，Webflux 采用异步响应式编程 响应式编程（Java 实现） 什么是响应式编程 响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便 地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。 电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似&quot;=B1+C1&quot;的公 式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。 Java8 及其之前版本 提供的观察者模式两个类 Observer 和 Observable public class ObserverDemo extends Observable { public static void main(String[] args) { ObserverDemo observer = new ObserverDemo(); //添加观察者 observer.addObserver((o,arg)-&gt;{ System.out.println(&quot;发生变化&quot;); }); observer.addObserver((o,arg)-&gt;{ System.out.println(&quot;手动被观察者通知，准备改变&quot;); }); observer.setChanged(); //数据变化 observer.notifyObservers(); //通知 } } 响应式编程（Reactor 实现） 响应式编程操作中，Reactor 是满足 Reactive 规范框架 Reactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作 符。Flux 对象实现发布者，返回 N 个元素；Mono 实现发布者，返回 0 或者 1 个元素 Flux 和 Mono 都是数据流的发布者，使用 Flux 和 Mono 都可以发出三种数据信号：元素值，错误信号，完成信号，错误信号和完成信号都代表终止信号，终止信号用于告诉 订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者 代码演示 Flux 和 Mono 引入依赖 &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;version&gt;3.1.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 编程代码 public static void main(String[] args) { //just 方法直接声明 Flux.just(1,2,3,4); Mono.just(1); //其他的方法 Integer[] array = {1,2,3,4}; Flux.fromArray(array); List&lt;Integer&gt; list = Arrays.asList(array); Flux.fromIterable(list); Stream&lt;Integer&gt; stream = list.stream(); Flux.fromStream(stream); } 三种信号特点 错误信号和完成信号都是终止信号，不能共存的 如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流 如果没有错误信号，没有完成信号，表示是无限数据流 调用 just 或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触 发数据流，不订阅什么都不会发生的 //just方法直接声明 Flux.just(1,2,3,4).subscribe(System.out::print); Mono.jusr(1).subscribe(System.out::print); 操作符 对数据流进行一道道操作，成为操作符，比如工厂流水线 第一 map 元素映射为新元素 第二 flatMap 元素映射为流 把每个元素转换流，把转换之后多个流合并大的流 SpringWebflux 执行流程和核心 API SpringWebflux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO 框架，异步非阻 塞的框架 Netty BIO NIO SpringWebflux 执行过程和 SpringMVC 相似的 SpringWebflux 核心控制器 DispatchHandler，实现接口 WebHandler 接口 WebHandler 有一个方法 public interface WebHandler { Mono&lt;Void&gt; handle(ServerWebExchange var1); } SpringWebflux 里面 DispatcherHandler，负责请求的处理 HandlerMapping：请求查询到处理的方法 HandlerAdapter：真正负责请求处理 HandlerResultHandler：响应结果处理 SpringWebflux 实现函数式编程，两个接口：RouterFunction（路由处理）和 HandlerFunction（处理函数） SpringWebflux（基于注解编程模型） SpringWebflux 实现方式有两种：注解编程模型和函数式编程模型 使用注解编程模型方式，和之前 SpringMVC 使用相似的，只需要把相关依赖配置到项目中， SpringBoot 自动配置相关运行容器，默认情况下使用 Netty 服务器 第一步 创建 SpringBoot 工程，引入 Webflux 依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; 第二步 配置启动端口号 server.port=8080 第三步 创建包和相关类 实体类 //实体类 public class User { private String name; private String gender; private Integer age; public User(){ } public User(String name,String gender,Integer age){ this.name=name; this.gender=gender; this.age=age; } public void setName(String name){... } 创建接口定义操作的方法 //用户操作接口 public interface UserService { //根据 id 查询用户 Mono&lt;User&gt; getUserById(int id); //查询所有用户 Flux&lt;User&gt; getAllUser(); //添加用户 Mono&lt;Void&gt; saveUserInfo(Mono&lt;User&gt; user); } 接口实现类 public class UserServiceImpl implements UserService { //创建 map 集合存储数据 private final Map&lt;Integer,User&gt; users = new HashMap&lt;&gt;(); public UserServiceImpl() { this.users.put(1,new User(&quot;lucy&quot;,&quot;nan&quot;,20)); this.users.put(2,new User(&quot;mary&quot;,&quot;nv&quot;,30)); this.users.put(3,new User(&quot;jack&quot;,&quot;nv&quot;,50)); } //根据 id 查询 @Override public Mono&lt;User&gt; getUserById(int id) { return Mono.justOrEmpty(this.users.get(id)); } //查询多个用户 @Override public Flux&lt;User&gt; getAllUser() { return Flux.fromIterable(this.users.values()); } //添加用户 @Override public Mono&lt;Void&gt; saveUserInfo(Mono&lt;User&gt; userMono) { return userMono.doOnNext(person -&gt; { //向 map 集合里面放值 int id = users.size()+1; users.put(id,person); }).thenEmpty(Mono.empty()); } } 创建 controller @RestController public class UserController { //注入 service @Autowired private UserService userService; //id 查询 @GetMapping(&quot;/user/{id}&quot;) public Mono&lt;User&gt; geetUserId(@PathVariable int id) { return userService.getUserById(id); } //查询所有 @GetMapping(&quot;/user&quot;) public Flux&lt;User&gt; getUsers() { return userService.getAllUser(); } //添加 @PostMapping(&quot;/saveuser&quot;) public Mono&lt;Void&gt; saveUser(@RequestBody User user) { Mono&lt;User&gt; userMono = Mono.just(user); return userService.saveUserInfo(userMono); } } 说明 SpringMVC 方式实现，同步阻塞的方式，基于 SpringMVC+Servlet+Tomcat SpringWebflux 方式实现，异步非阻塞 方式，基于 SpringWebflux+Reactor+Netty 、SpringWebflux（基于函数式编程模型） 在使用函数式编程模型操作时候，需要自己初始化服务器 基于函数式编程模型时候，有两个核心接口：RouterFunction（实现路由功能，请求转发 给对应的 handler）和 HandlerFunction（处理请求生成响应的函数）。核心任务定义两个函数 式接口的实现并且启动需要的服务器。 SpringWebflux 请 求 和 响 应 不 再 是 ServletRequest 和 ServletResponse ，而是 ServerRequest 和 ServerResponse 第一步 把注解编程模型工程复制一份 ，保留 entity 和 service 内容 第二步 创建 Handler（具体实现方法） public class UserHandler { private final UserService userService; public UserHandler(UserService userService) { this.userService = userService; } //根据 id 查询 public Mono&lt;ServerResponse&gt; getUserById(ServerRequest request) { //获取 id 值 int userId = Integer.valueOf(request.pathVariable(&quot;id&quot;)); //空值处理 Mono&lt;ServerResponse&gt; notFound = ServerResponse.notFound().build(); //调用 service 方法得到数据 Mono&lt;User&gt; userMono = this.userService.getUserById(userId); //把 userMono 进行转换返回 //使用 Reactor 操作符 flatMap return userMono.flatMap(person -&gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(fromObject(person))).switchIfEmpty(notFound); } //查询所有 public Mono&lt;ServerResponse&gt; getAllUsers() { //调用 service 得到结果 Flux&lt;User&gt; users = this.userService.getAllUser(); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(users,User.cl ass); } //添加 public Mono&lt;ServerResponse&gt; saveUser(ServerRequest request) { //得到 user 对象 Mono&lt;User&gt; userMono = request.bodyToMono(User.class); return ServerResponse.ok().build(this.userService.saveUserInfo(userMono)); } } 第三步 初始化服务器，编写 Router 创建路由的方法 //1 创建 Router 路由 public RouterFunction&lt;ServerResponse&gt; routingFunction() { //创建 hanler 对象 UserService userService = new UserServiceImpl(); UserHandler handler = new UserHandler(userService); //设置路由 return RouterFunctions.route(GET(&quot;/users/{id}&quot;).and(accept(APPLICATION_JSON)),handler::getUserById).andRoute(GET(&quot;/users&quot;).and(accept(APPLICATION_JSON)),handler::get AllUsers); } 创建服务器完成适配 ```java //2 创建服务器完成适配 public void createReactorServer() { //路由和 handler 适配 RouterFunction&lt;ServerResponse&gt; route = routingFunction(); HttpHandler httpHandler = toHttpHandler(route); ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(httpHandler); //创建服务器 HttpServer httpServer = HttpServer.create(); httpServer.handle(adapter).bindNow(); } ``` 最终调用 public static void main(String[] args) throws Exception{ Server server = new Server(); server.createReactorServer(); System.out.println(&quot;enter to exit&quot;); System.in.read(); } 使用 WebClient 调用 public class Client { public static void main(String[] args) { //调用服务器地址 WebClient webClient = WebClient.create(&quot;http://127.0.0.1:5794&quot;); //根据 id 查询 String id = &quot;1&quot;; User userresult = webClient.get().uri(&quot;/users/{id}&quot;, id).accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(User.class).block(); System.out.println(userresult.getName()); //查询所有 Flux&lt;User&gt; results = webClient.get().uri(&quot;/users&quot;).accept(MediaType.APPLICATION_JSON).retrieve().bodyToFlux(User.class); results.map(stu -&gt; stu.getName()).buffer().doOnNext(System.out::println).blockFirst(); } } 总结 Spring框架概述 轻量级开源 JavaEE 框架，为了解决企业复杂性，两个核心组成：IOC 和 AOP Spring5.2.6 版本 、IOC 容器 IOC 底层原理（工厂、反射等） IOC 接口（BeanFactory） IOC 操作 Bean 管理（基于 xml） IOC 操作 Bean 管理（基于注解） AOP AOP 底层原理：动态代理，有接口（JDK 动态代理），没有接口（CGLIB 动态代理） 术语：切入点、增强（通知）、切面 基于 AspectJ 实现 AOP 操作 JdbcTemplate 使用 JdbcTemplate 实现数据库 curd 操作 使用 JdbcTemplate 实现数据库批量操作 事务管理 事务概念 重要概念（传播行为和隔离级别） 基于注解实现声明式事务管理 完全注解方式实现声明式事务管理 Spring5 新功能 整合日志框架 @Nullable 注解 函数式注册对象 整合 JUnit5 单元测试框架 SpringWebflux 使用 ","link":"https://nanteng.github.io/post/spring5-kuang-jia/"},{"title":"JDBCBasic","content":"JDBC概述 数据的持久化 持久化(persistence)把数据库保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用， 数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。 持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件，xml数据文件中。 Java中数据存储技术 在Java中，数据库存取技术可分为如下几类： JDBC直接访问数据库 JDO (JavaDate Object)技术 第三方O/R工具，如Hibernate,Mybatis等 JDBC是Java访问数据库的基石，JDO,Hibernate,MyBatis等只更好的封装了JDBC JDBC介绍 JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统，通用的SQL数据库存取和操作的公共接口(一组API),定义了用来访问数据库的标准Java类库，(java.sql,javax.sql)使用这些类库可以以一种标准的方法，方便地访问数据库资源。 DBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。 JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需 对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。 如果没有JDBC,那么Java程序访问数据库是这样的： 有了JDBC之后，Java访问数据库时是这样的： 总结： JDBC体系结构 JDBC接口（API）包括两个层次： 面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。 JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。 不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。 ————面向接口编程 JDBC程序编写步骤 ODBC(OPen Database Connectivity,开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API,由ODBC驱动程序将调用转换为对特定的数据库的调用请求。 获取数据库连接 要素一：Driver接口实现类 Driver接口介绍 java.sql.Driver接口是所有JDBC驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。 在程序中不需要直接去访问实现了Driver接口的类，而是由驱动程序管理类(java.sql.DriverManager)去调用这些Driver实现 Oracle的驱动：oracle.jdbc.driver.OracleDriver MySql的驱动：com.mysql.jdbc.Driver 加载与注册JDBC驱动 加载驱动：加载JDBC驱动需要调用Class类的静态方法forName(),向其传递要加载的JDBC驱动的类名 Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 注册驱动：DriverManager类是驱动程序管理器类，负责管理驱动程序 使用Driver.registerDriver(&quot;com.mysql.jdbc.Driver&quot;)来注册驱动 通常不用显式调用DriverManager类的registerDriver()方法来注册驱动程序类的实例，因为Driver接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用Drivermanager.registerDriver()方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码： 要素二：URL JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个URL选择正确的驱动程序，从而建立到数据库的连接。 JDBC URL的标准由三部分组成，各部分中间用冒号分隔。 JDBC:子协议:子名称 协议：JDBC URL中的协议总是jdbc 子协议：子协议用于标识一个数据库驱动程序 子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包括主机名（对应服务端的IP地址），端口号，数据库名 例如： 几种常见的数据库的JDBC URL MySQL的连接URL编写方式： jdbc:mysql://主机名称:mysql服务器端口号/数据库名称？参数=值&amp;参数=值 jdbc:mysql://localhost:3306/test jdbc:mysql://localhost:3306/test?useUnicode=true$characterEncoding=utf8(如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集) dbc:mysql://localhost:3306/test?user=root&amp;password=123456 Oracle 9i的连接URL编写方式 dbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称 dbc:oracle:thin:@localhost:1521:test SQLServer的连接URL编写方式： dbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称 jdbc:sqlserver://localhost:1433:DatabaseName=test 要素四：用户名和密码 user,password可以用&quot;属性名=属性值&quot;方式告诉数据库 可以调用DriverManager类的getConnection()方法建立到数据库的连接 数据库连接方式举例 连接方式一 //方式一: @Test public void testConnection1() throws Exception { //提供java.sql.Driver接口实现类的对象 Driver driver = new com.mysql.jdbc.Driver(); //提供url1,指明具体操作的数据 String url =&quot;jdbc:mysql://localhost:3307/test&quot;; //提供Properties的对象，指明用户名和密码/将用户名和密码封装在Properties中 Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;1234556&quot;); //调用dirver的connect(),获取连接 Connection conn = driver.connect(url, info); System.out.println(conn); } 上述代码显式出现了第三方数据库的API 连接方式二 //方式二： @Test public void testConnection2() throws Exception{ //获取Driver实现类对象：使用反射 Class aClass = Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Driver dirver =(Driver) aClass.newInstance(); //2.提供要连接的数据库 String url = &quot;jdbc:mysql://localhost:3307/test&quot;; //3.提供要连接的用户名和密码 Properties info = new Properties(); info.setProperty(&quot;user&quot;, &quot;root&quot;); info.setProperty(&quot;password&quot;, &quot;123456&quot;); //4.获取连接 Connection conn = dirver.connect(url, info); System.out.println(conn); } 对方式一的迭代:不出现第三方的API,使得程序具有更好的可移植性。体现了面向接口编程的思想。 连接方式三 //方式三：使用DriverManager替换Driver @Test public void testConnection3() throws Exception { //1.获取Driver实现类对象 Class aClass = Class.forName(&quot;com.mysql.jdbc.Driver&quot;); Driver driver = (Driver) aClass.newInstance(); //2.提供另外三个连接的基本信息 String url = &quot;jdbc:mysql://localhost:3307/test&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; //注册驱动registerDriver DriverManager.registerDriver(driver); //获取连接 Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); } 使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。 连接方式四 //方式四：可以只是加载驱动，不用显式的注册驱动了 @Test public void testConnection4() throws Exception { //1.提供另外三个连接的基本信息 String url = &quot;jdbc:mysql://localhost:3307/test&quot;; String user = &quot;root&quot;; String password = &quot;123456&quot;; //1.获取Driver实现类对象 Class aClass = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//连接MySQL驱动这一步也可以省，但是建议不要省 //相较于方式三：可以省略如下步骤： /*Driver driver = (Driver) aClass.newInstance(); //注册驱动registerDriver DriverManager.registerDriver(driver);*/ //为什么可以省略以上步骤？ /* * 在mySql的Driver实现类中声明了如下操作 static { try{ java.sql.DriverManager.registerDriver(new Driver()); }catch (SQLException E){ throw new RuntimeException(&quot;Can't register driver!&quot;); } } */ //获取连接 Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); } 不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册 连接方式五(最终方案) //方式五： @Test public void testConnection5() throws Exception{ //加载配置文件 InputStream is = ConnectionTest.Class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); //读取配置信息 String url = pros.getProperty(&quot;url&quot;); String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); //加载驱动 Class.forName(driverClass); //获取连接 Connection conn = DriverManager.getConnection(url,user,password); System.out.println(conn); } 其中配置文件声明在工程的src目录下：[jdbc.properties] url=jdbc:mysql://localhost:3307/test user=root password=123456 driverClass=com.mysql.jdbc.Driver 说明：使用配置文件的方式保存配置信息，在代码中加载配置文件 使用配置文件的好处： ​ ①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码 ​ ②如果修改了 配置信息，省去重新编译的过程。 使用PreparedStatement实现CRUD操作 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和SQL语句，并接受数据库连接就是一个Socket连接 在Java.sql包中有3个接口分别定义了对数据库的调用的不同方式： Statement：用于执行动态SQL语句并返回它所生成结果的对象。 PrepatedStatement：SQL语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。 CallableStatement：用于执行SQL存储过程 使用Statement操作数据库的弊端 通过调用Connection对象的createStatement()方法创建该对象。该对象用于执行静态的SQL语句，并且返回执行结果。 Statemet接口中定义了下列方法用于执行SQL语句： int excuteUpdate(String sql)：执行更新操作INSERT、UPDATE、DELETE ResultSet executeQuery(String sql)：执行查询操作SELECT 但是使用Statement操作数据表存在弊端： 问题一：存在拼串操作，繁琐 问题二：存在SQL注入问题 SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段 或命令(如：SELECT user, password FROM user_table WHERE user='a' OR 1 = ' AND password = ' OR '1' = '1') ，从而利用系统的 SQL 引擎完成恶意行为的做法。 对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可 以了。 代码演示： public class StatementTest { // 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题 @Test public void testLogin() { Scanner scan = new Scanner(System.in); System.out.print(&quot;用户名：&quot;); String userName = scan.nextLine(); System.out.print(&quot;密 码：&quot;); String password = scan.nextLine(); // SELECT user,password FROM user_table WHERE USER = '1' or ' AND PASSWORD = ' // ='1' or '1' = '1'; String sql = &quot;SELECT user,password FROM user_table WHERE USER = '&quot; + userName + &quot;' AND PASSWORD = '&quot; + password + &quot;'&quot;; User user = get(sql, User.class); if (user != null) { System.out.println(&quot;登陆成功!&quot;); } else { System.out.println(&quot;用户名或密码错误！&quot;); } } // 使用Statement实现对数据表的查询操作 public &lt;T&gt; T get(String sql, Class&lt;T&gt; clazz) { T t = null; Connection conn = null; Statement st = null; ResultSet rs = null; try { // 1.加载配置文件 InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); Properties pros = new Properties(); pros.load(is); // 2.读取配置信息 String user = pros.getProperty(&quot;user&quot;); String password = pros.getProperty(&quot;password&quot;); String url = pros.getProperty(&quot;url&quot;); String driverClass = pros.getProperty(&quot;driverClass&quot;); // 3.加载驱动 Class.forName(driverClass); // 4.获取连接 conn = DriverManager.getConnection(url, user, password); st = conn.createStatement(); rs = st.executeQuery(sql); // 获取结果集的元数据 ResultSetMetaData rsmd = rs.getMetaData(); // 获取结果集的列数 int columnCount = rsmd.getColumnCount(); if (rs.next()) { t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) { // //1. 获取列的名称 // String columnName = rsmd.getColumnName(i+1); // 1. 获取列的别名 String columnName = rsmd.getColumnLabel(i + 1); // 2. 根据列名获取对应数据表中的数据 Object columnVal = rs.getObject(columnName); // 3. 将数据表中得到的数据，封装进对象 Field field = clazz.getDeclaredField(columnName); field.setAccessible(true); field.set(t, columnVal); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { // 关闭资源 if (rs != null) { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); } } if (st != null) { try { st.close(); } catch (SQLException e) { e.printStackTrace(); } } if (conn != null) { try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } return null; } } 综上： PreparedStatement的使用 PreparedStatement介绍 可以通过调用 Connection 对象的 preparedStatement(String sql) 方法获取 PreparedStatement 对象 PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句 PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值 PreparedStatement vs Statement 代码的可读性和可维护性 PreparedStatement 能最大可能提高性能： DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的 编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。 在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意 义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。 (语法检查，语义检查，翻译成二进制命令，缓存) PreparedStatement 可以防止SQL 注入 Java与SQL对应数据类型转换表 Java类型 SQL类型 boolean BIT byte TINYINT short SMALLINT int INTEGER long BIGINT String CHAR,VARCHAR,LONGVARCHAR byte array BINARY,VAR BINARY java.sql.Date DATE java.sql.Time TIME java.sql.Timestamp TIMESTAMP 使用PreparedStatement实现增、删、改操作 //通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表） public void update(String sql,Object ... args){ Connection conn = null; PreparedStatement ps = null; try { //1.获取数据库的连接 conn = JDBCUtils.getConnection(); //2.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); //3.填充占位符 for(int i = 0;i &lt; args.length;i++){ ps.setObject(i + 1, args[i]); } //4.执行sql语句 ps.execute(); } catch (Exception e) { e.printStackTrace(); }finally{ //5.关闭资源 JDBCUtils.closeResource(conn, ps); } } 使用PreparedStatement实现查询操作 // 通用的针对于不同表的查询:返回一个对象 (version 1.0) public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.预编译sql语句，得到PreparedStatement对象 ps = conn.prepareStatement(sql); // 3.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 4.执行executeQuery(),得到结果集：ResultSet rs = ps.executeQuery(); // 5.得到结果集的元数据：ResultSetMetaData ResultSetMetaData rsmd = rs.getMetaData(); // 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值 int columnCount = rsmd.getColumnCount(); if (rs.next()) { T t = clazz.newInstance(); for (int i = 0; i &lt; columnCount; i++) {// 遍历每一个列 // 获取列值 Object columnVal = rs.getObject(i + 1); // 获取列的别名:列的别名，使用类的属性名充当 String columnLabel = rsmd.getColumnLabel(i + 1); // 6.2使用反射，给对象的相应属性赋值 Field field = clazz.getDeclaredField(columnLabel); field.setAccessible(true); field.set(t, columnVal); } return t; } } catch (Exception e) { e.printStackTrace(); } finally { // 7.关闭资源 JDBCUtils.closeResource(conn, ps, rs); } return null; } 说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和 SQL注入问题。 ResultSet与ResultSetMetaData ResultSet 查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象 ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现 ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。 ResultSet 对象维护了一个指向当前数据行的游标，初始的时候，游标在第一行之前，可以通过 ResultSet 对象 的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。 相当于Iterator对象的 hasNext() 和 next() 方法的结合体。 当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。 例如: getInt(1), getString(&quot;name&quot;) 注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。 ResultSet 接口的常用方法： boolean next() getString() ResultSetMetaData 可用于获取关于 ResultSet 对象中列的类型和属性信息的对象 ResultSetMetaData meta = rs.getMetaData(); getColumnName(int column)：获取指定列的名称 getColumnLabel(int column)：获取指定列的别名 getColumnCount()：返回当前 ResultSet 对象中的列数。 getColumnTypeName(int column)：检索指定列的数据库特定的类型名称 getColumnCount()：返回当前 ResultSet 对象中的列数。 etColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 sNullable(int column)：指示指定列中的值是否可以为 null。 isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？ 需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData 问题2：关于ResultSetMetaData 如何获取 ResultSetMetaData： 调用 ResultSet 的 getMetaData() 方法 获取 ResultSet 中有多少列： 调用 ResultSetMetaData 的 getColumnCount() 方法 获取 ResultSet 每一列的列的别名是什么： 调用 ResultSetMetaData 的getColumnLabel() 方法 针对于表的字段名与类的属性名称不相同情况 必须声明sql时，使用类的属性名来命名字段的别名 使用ResuktSetMetaData时，需要使用getColumnLabel()来替换getColumnName(),获取列的别名 说明：如果sql中没有给字段起别名,getColumnLabel()获取的就是列名 资源的释放 释放ResultSet, Statement,Connection。 数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将 导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。 3.6JDBC API小结 两种思想 面向接口编程的思想 ORM思想(object relational mapping) 一个数据表对应一个java类 表中的一条记录对应java类的一个对象 表中的一个字段对应java类的一个属性 sql是需要结合列名和表的属性名来写。注意起别名。 两种技术 JDBC结果集的元数据：ResultSetMetaData 获取列数：getColumnCount() 获取列的别名：getColumnLabel() 通过反射，创建指定类的对象，获取指定的属性并赋值 操作BLOB类型字段 MySQL BLOB类型 MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。 插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。 MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的) 实际使用中根据需要存入的数据大小定义不同的BLOB类型。 需要注意的是：如果存储的文件过大，数据库的性能会下降 如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如 下的配置参数： max_allowed_packet=16M。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。 向数据表中插入大数据类型 //获取连接 Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into customers(name,email,birth,photo)values(?,?,?,?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); // 填充占位符 ps.setString(1, &quot;张国荣&quot;); ps.setString(2, &quot;zgr@126.com&quot;); ps.setDate(3, new Date(new java.util.Date().getTime())); // 操作Blob类型的变量 FileInputStream fis = new FileInputStream(&quot;zgr.png&quot;); ps.setBlob(4, fis); //执行 ps.execute(); fis.close(); JDBCUtils.closeResource(conn, ps); 修改数据表中国Blob类型字段 Connection conn = JDBCUtils.getConnection(); String sql = &quot;update customers set photo = ? where id = ?&quot;; PreparedStatement ps = conn.prepareStatement(sql); // 填充占位符 // 操作Blob类型的变量 FileInputStream fis = new FileInputStream(&quot;coffee.png&quot;); ps.setBlob(1, fis); ps.setInt(2, 25); ps.execute(); fis.close(); JDBCUtils.closeResource(conn, ps); 从数据表中读取大数据类型 String sql = &quot;SELECT id, name, email, birth, photo FROM customer WHERE id = ?&quot;; conn = getConnection(); ps = conn.prepareStatement(sql); ps.setInt(1, 8); rs = ps.executeQuery(); if(rs.next()){ Integer id = rs.getInt(1); String name = rs.getString(2); String email = rs.getString(3); Date birth = rs.getDate(4); Customer cust = new Customer(id, name, email, birth); System.out.println(cust); //读取Blob类型的字段 Blob photo = rs.getBlob(5); InputStream is = photo.getBinaryStream(); OutputStream os = new FileOutputStream(&quot;c.jpg&quot;); byte [] buffer = new byte[1024]; int len = 0; while((len = is.read(buffer)) != -1){ os.write(buffer, 0, len); } JDBCUtils.closeResource(conn, ps, rs); if(is != null){ is.close(); } if(os != null){ os.close(); } } 批量插入 批量执行SQL语句 当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处 理。通常情况下比单独提交处理更有效率 JDBC的批量处理语句包括下面三个方法 addBatch(String)：添加需要批量处理的SQL语句或是参数； executeBatch()：执行批量处理语句 clearBatch()：清空缓存的数据 通常会遇到两种批量执行SQL语句的情况： 多条SQL语句的批量处理； 一个SQL语句的批量传参； 高效的批量插入 举例：向数据表中插入20000条数据 数据库中提供一个goods表。创建如下： CREATE TABLE goods( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); 实现层次一：使用Statement Connection conn = JDBCUtils.getConnection(); Statement st = conn.createStatement(); for(int i = 1;i &lt;= 20000;i++){ String sql = &quot;insert into goods(name) values('name_' + &quot;+ i +&quot;)&quot;; st.executeUpdate(sql); } 实现层次二：使用PreparedStatement long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into goods(name)values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 20000;i++){ ps.setString(1, &quot;name_&quot; + i); ps.executeUpdate(); } long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));//82340 JDBCUtils.closeResource(conn, ps); 实现层次三 /* * 修改1： 使用 addBatch() / executeBatch() / clearBatch() * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。 * ?rewriteBatchedStatements=true 写在配置文件的url后面 * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar * */ @Test public void testInsert1() throws Exception{ long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); String sql = &quot;insert into goods(name)values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++){ ps.setString(1, &quot;name_&quot; + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0){ //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); } } long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));//20000条：625 //1000000条:14733 JDBCUtils.closeResource(conn, ps); } 实现层次4 /* * 层次四：在层次三的基础上操作 * 使用Connection 的 setAutoCommit(false) / commit() */ @Test public void testInsert2() throws Exception{ long start = System.currentTimeMillis(); Connection conn = JDBCUtils.getConnection(); //1.设置为不自动提交数据 conn.setAutoCommit(false); String sql = &quot;insert into goods(name)values(?)&quot;; PreparedStatement ps = conn.prepareStatement(sql); for(int i = 1;i &lt;= 1000000;i++){ ps.setString(1, &quot;name_&quot; + i); //1.“攒”sql ps.addBatch(); if(i % 500 == 0){ //2.执行 ps.executeBatch(); //3.清空 ps.clearBatch(); } } //2.提交数据 conn.commit(); long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为：&quot; + (end - start));//1000000条:4978 JDBCUtils.closeResource(conn, ps); } 数据库事务 数据库事务介绍 事务：一组逻辑操作单元，使数据从一种状态转换到另一种状态。 事务处理（事务操作）：保证所有事务都作为一个工作单元来执行，即使出了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(commit)，那么这些修改就永久地保存下来； 要么数据库管理系统将放弃所作的所有修改，整个事务回滚(rollback)到最初状态。 为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可 以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退 到开始状态。 JDBC事务处理 数据一旦提交，就不可回滚。 数据什么时候意味着提交？ 当一个连接对象被创建时，默认情况下是自动提交事务：每次执行一个 SQL 语句时，如果执行成功，就会 向数据库自动提交，而不能回滚。 关闭数据库连接，数据就会自动的提交。如果多个操作，每个操作使用的是自己单独的连接，则无法保证 事务。即同一个事务的多个操作必须在同一个连接下。 JDBC程序中为了让多个SQL语句作为一个事务执行： 调用 Connection 对象的 setAutoCommit(false); 以取消自动提交事务 在所有的 SQL 语句都成功执行后，调用 commit(); 方法提交事务 在出现异常时，调用 rollback(); 方法回滚事务 若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。 转账举例： public void testJDBCTransaction() { Connection conn = null; try { // 1.获取数据库连接 conn = JDBCUtils.getConnection(); // 2.开启事务 conn.setAutoCommit(false); // 3.进行数据库操作 String sql1 = &quot;update user_table set balance = balance - 100 where user = ?&quot;; update(conn, sql1, &quot;AA&quot;); // 模拟网络异常 //System.out.println(10 / 0); String sql2 = &quot;update user_table set balance = balance + 100 where user = ?&quot;; update(conn, sql2, &quot;BB&quot;); // 4.若没有异常，则提交事务 conn.commit(); } catch (Exception e) { e.printStackTrace(); // 5.若有异常，则回滚事务 try { conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } } finally { try { //6.恢复每次DML操作的自动提交功能 conn.setAutoCommit(true); } catch (SQLException e) { e.printStackTrace(); } //7.关闭连接 JDBCUtils.closeResource(conn, null, null); } } 其中，对数据库操作的方法为： //使用事务以后的通用的增删改操作（version 2.0） public void update(Connection conn ,String sql, Object... args) { PreparedStatement ps = null; try { // 1.获取PreparedStatement的实例 (或：预编译sql语句) ps = conn.prepareStatement(sql); // 2.填充占位符 for (int i = 0; i &lt; args.length; i++) { ps.setObject(i + 1, args[i]); } // 3.执行sql语句 ps.execute(); } catch (Exception e) { e.printStackTrace(); } finally { // 4.关闭资源 JDBCUtils.closeResource(null, ps); } } 事务的ACID属性 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态 隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的 数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其 他操作和数据库故障不应该对其有任何影响。 数据库并发问题 对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种 并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的 内容就是临时且无效的。 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字 段, 值就不同了。 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如 果 T1 再次读取同一个表, 就会多出几行。 数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。 一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰 程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。 四种隔离级别 数据库提供的4种事务隔离级别： Oracle支持的2种事务隔离级别：READ COMMITED,SERIALIZABLE。Oracle默认的事务隔离级别为：READ COMMITED. Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: REPEATABLE READ。 在MySql中设置隔离级别 每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。 查看当前的隔离级别: SELECT @@tx_isolation; 设置当前 mySQL 连接的隔离级别: set transaction isolation level read committed; 设置数据库系统的全局的隔离级别: set global transaction isolation level read committed; 补充操作： 创建mysql数据库用户： create user tom identified by 'abc123'; 授予权限 #授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123. grant all privileges on *.* to tom@'%' identified by 'abc123'; #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。 grant select,insert,delete,update on atguigudb.* to tom@localhost identified by 'abc123'; DAO及相关实现类 DAO：（Data Access Object）访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、 Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO 作用：为了实现功能的模块化，更有利于代码的维护和升级。 下面是JavaWeb阶段书城项目中DAO使用的体现： 层次结构 【BaseDAO.java】 package com.atguigu.bookstore.dao; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.sql.Connection; import java.sql.SQLException; import java.util.List; import org.apache.commons.dbutils.QueryRunner; import org.apache.commons.dbutils.handlers.BeanHandler; import org.apache.commons.dbutils.handlers.BeanListHandler; import org.apache.commons.dbutils.handlers.ScalarHandler; /** * 定义一个用来被继承的对数据库进行基本操作的Dao * * @author HanYanBing * * @param &lt;T&gt; */ public abstract class BaseDao&lt;T&gt; { private QueryRunner queryRunner = new QueryRunner(); // 定义一个变量来接收泛型的类型 private Class&lt;T&gt; type; // 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定 public BaseDao() { // 获取子类的类型 Class clazz = this.getClass(); // 获取父类的类型 // getGenericSuperclass()用来获取当前类的父类的类型 // ParameterizedType表示的是带泛型的类型 ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass(); // 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型 // 这个方法会返回一个Type的数组 Type[] types = parameterizedType.getActualTypeArguments(); // 获取具体的泛型的类型· this.type = (Class&lt;T&gt;) types[0]; } /** * 通用的增删改操作 * * @param sql * @param params * @return */ public int update(Connection conn,String sql, Object... params) { int count = 0; try { count = queryRunner.update(conn, sql, params); } catch (SQLException e) { e.printStackTrace(); } return count; } /** * 获取一个对象 * * @param sql * @param params * @return */ public T getBean(Connection conn,String sql, Object... params) { T t = null; try { t = queryRunner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); } catch (SQLException e) { e.printStackTrace(); } return t; } /** * 获取所有对象 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList(Connection conn,String sql, Object... params) { List&lt;T&gt; list = null; try { list = queryRunner.query(conn, sql, new BeanListHandler&lt;T&gt;(type), params); } catch (SQLException e) { e.printStackTrace(); } return list; } /** * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句 * * @param sql * @param params * @return */ public Object getValue(Connection conn,String sql, Object... params) { Object count = null; try { // 调用queryRunner的query方法获取一个单一的值 count = queryRunner.query(conn, sql, new ScalarHandler&lt;&gt;(), params); } catch (SQLException e) { e.printStackTrace(); } return count; } } 【BookDAO.java】 package com.atguigu.bookstore.dao; import java.sql.Connection; import java.util.List; import com.atguigu.bookstore.beans.Book; import com.atguigu.bookstore.beans.Page; public interface BookDao { /** * 从数据库中查询出所有的记录 * * @return */ List&lt;Book&gt; getBooks(Connection conn); /** * 向数据库中插入一条记录 * * @param book */ void saveBook(Connection conn,Book book); /** * 从数据库中根据图书的id删除一条记录 * * @param bookId */ void deleteBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中查询出一条记录 * * @param bookId * @return */ Book getBookById(Connection conn,String bookId); /** * 根据图书的id从数据库中更新一条记录 * * @param book */ void updateBook(Connection conn,Book book); /** * 获取带分页的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page); /** * 获取带分页和价格范围的图书信息 * * @param page：是只包含了用户输入的pageNo属性的page对象 * @return 返回的Page对象是包含了所有属性的Page对象 */ Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice); } 【UserDAO.java】 package com.atguigu.bookstore.dao; import java.sql.Connection; import com.atguigu.bookstore.beans.User; public interface UserDao { /** * 根据User对象中的用户名和密码从数据库中获取一条记录 * * @param user * @return User 数据库中有记录 null 数据库中无此记录 */ User getUser(Connection conn,User user); /** * 根据User对象中的用户名从数据库中获取一条记录 * * @param user * @return true 数据库中有记录 false 数据库中无此记录 */ boolean checkUsername(Connection conn,User user); /** * 向数据库中插入User对象 * * @param user */ void saveUser(Connection conn,User user); } 【BookDaoImpl.java】 package com.atguigu.bookstore.dao.impl; import java.sql.Connection; import java.util.List; import com.atguigu.bookstore.beans.Book; import com.atguigu.bookstore.beans.Page; import com.atguigu.bookstore.dao.BaseDao; import com.atguigu.bookstore.dao.BookDao; public class BookDaoImpl extends BaseDao&lt;Book&gt; implements BookDao { @Override public List&lt;Book&gt; getBooks(Connection conn) { // 调用BaseDao中得到一个List的方法 List&lt;Book&gt; beanList = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books&quot;; beanList = getBeanList(conn,sql); return beanList; } @Override public void saveBook(Connection conn,Book book) { // 写sql语句 String sql = &quot;insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath()); } @Override public void deleteBookById(Connection conn,String bookId) { // 写sql语句 String sql = &quot;DELETE FROM books WHERE id = ?&quot;; // 调用BaseDao中通用增删改的方法 update(conn,sql, bookId); } @Override public Book getBookById(Connection conn,String bookId) { // 调用BaseDao中获取一个对象的方法 Book book = null; // 写sql语句 String sql = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where id = ?&quot;; book = getBean(conn,sql, bookId); return book; } @Override public void updateBook(Connection conn,Book book) { // 写sql语句 String sql = &quot;update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?&quot;; // 调用BaseDao中通用的增删改的方法 update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId()); } @Override public Page&lt;Book&gt; getPageBooks(Connection conn,Page&lt;Book&gt; page) { // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; } @Override public Page&lt;Book&gt; getPageBooksByPrice(Connection conn,Page&lt;Book&gt; page, double minPrice, double maxPrice) { // 获取数据库中图书的总记录数 String sql = &quot;select count(*) from books where price between ? and ?&quot;; // 调用BaseDao中获取一个单一值的方法 long totalRecord = (long) getValue(conn,sql,minPrice,maxPrice); // 将总记录数设置都page对象中 page.setTotalRecord((int) totalRecord); // 获取当前页中的记录存放的List String sql2 = &quot;select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?&quot;; // 调用BaseDao中获取一个集合的方法 List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - 1) * Page.PAGE_SIZE, Page.PAGE_SIZE); // 将这个List设置到page对象中 page.setList(beanList); return page; } } 【UserDaoImpl.java】 package com.atguigu.bookstore.dao.impl; import java.sql.Connection; import com.atguigu.bookstore.beans.User; import com.atguigu.bookstore.dao.BaseDao; import com.atguigu.bookstore.dao.UserDao; public class UserDaoImpl extends BaseDao&lt;User&gt; implements UserDao { @Override public User getUser(Connection conn,User user) { // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ? and password = ?&quot;; bean = getBean(conn,sql, user.getUsername(), user.getPassword()); return bean; } @Override public boolean checkUsername(Connection conn,User user) { // 调用BaseDao中获取一个对象的方法 User bean = null; // 写sql语句 String sql = &quot;select id,username,password,email from users where username = ?&quot;; bean = getBean(conn,sql, user.getUsername()); return bean != null; } @Override public void saveUser(Connection conn,User user) { //写sql语句 String sql = &quot;insert into users(username,password,email) values(?,?,?)&quot;; //调用BaseDao中通用的增删改的方法 update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail()); } } [Book.java] package com.atguigu.bookstore.beans; /** * 图书类 * @author songhongkang * */ public class Book { private Integer id; private String title; // 书名 private String author; // 作者 private double price; // 价格 private Integer sales; // 销量 private Integer stock; // 库存 private String imgPath = &quot;static/img/default.jpg&quot;; // 封面图片的路径 //构造器，get()，set()，toString()方法略 } [Page.java] package com.atguigu.bookstore.beans; import java.util.List; /** * 页码类 * @author songhongkang * */ public class Page&lt;T&gt; { private List&lt;T&gt; list; // 每页查到的记录存放的集合 public static final int PAGE_SIZE = 4; // 每页显示的记录数 private int pageNo; // 当前页 // private int totalPageNo; // 总页数，通过计算得到 private int totalRecord; // 总记录数，通过查询数据库得到 [User.java] package com.atguigu.bookstore.beans; /** * 用户类 * @author songhongkang * */ public class User { private Integer id; private String username; private String password; private String email; 数据库连接池 JDBC数据库连接池的必要性 在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤： 在主程序（如servlet、beans）中建立数据库连接 进行sql操作 断开数据库连接 这种模式开发，存在的问题: 普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求 一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。数据库的连接资源并没有得到很 好的重复利用。若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严 重的甚至会造成服务器的崩溃。 对于每一次数据库连接，使用完后都得断开。否则，如果程序出现异常而未能关闭，将会导致数据库系统 中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？） 这种开发不能控制被创建的连接对象数，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内 存泄漏，服务器崩溃。 数据库连接池技术 为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。 数据库连接池的基本思想：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要 建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重 新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库 连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池 的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连 接数量时，这些请求将被加入到等待队列中。 工作原理： 数据库连接池技术的优点 资源重用 由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一 方面也增加了系统运行环境的平稳性。 更快的系统反应速度 数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均 已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销， 从而减少了系统的响应时间 新的资源分配手段 对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库 连接数的限制，避免某一应用独占所有的数据库资源 统一的连接管理，避免数据库连接泄漏 在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据 库连接操作中可能出现的资源泄露 多种开源的数据库连接池 JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器 (Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现： DBCP 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。速度相对c3p0较快，但因 自身存在BUG，Hibernate3已不再提供支持。 C3P0 是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。hibernate官方推荐使用 Proxool 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一 点 BoneCP 是一个开源组织提供的数据库连接池，速度快 Druid 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是 速度不确定是否有BoneCP快 DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池 DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。 特别注意： 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数 据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 C3P0数据库连接池 获取连接方式一 //使用C3P0数据库连接池的方式，获取数据库的连接：不推荐 public static Connection getConnection1() throws Exception{ ComboPooledDataSource cpds = new ComboPooledDataSource(); cpds.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); cpds.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;); cpds.setUser(&quot;root&quot;); cpds.setPassword(&quot;abc123&quot;); // cpds.setMaxPoolSize(100); Connection conn = cpds.getConnection(); return conn; } 获取连接方式二 //使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐 private static DataSource cpds = new ComboPooledDataSource(&quot;helloc3p0&quot;); public static Connection getConnection2() throws SQLException{ Connection conn = cpds.getConnection(); return conn; } 其中，src下的配置文件为：【c3p0-config.xml】 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;c3p0-config&gt; &lt;named-config name=&quot;helloc3p0&quot;&gt; &lt;!-- 获取连接的4个基本信息 --&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;abc123&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql:///test&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt; &lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt;5&lt;/property&gt; &lt;!-- 初始化数据库连接池时连接的数量 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最小的数据库连接数 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt;5&lt;/property&gt; &lt;!-- 数据库连接池中的最大的数据库连接数 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt;10&lt;/property&gt; &lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt; &lt;property name=&quot;maxStatements&quot;&gt;20&lt;/property&gt; &lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt; &lt;property name=&quot;maxStatementsPerConnection&quot;&gt;5&lt;/property&gt; &lt;/named-config&gt; &lt;/c3p0-config&gt; DBCP数据库连接池 DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Commonpool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。 数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。 当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的 物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。 配置属性说明 属性 默认值 说明 initialSize 0 连接池启动时创建的初始化连接数量 maxActive 8 连接池中可同时连接的最大连接数 maxIdle 8 连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果 设置为负数表示不限制 minIdle 0 连接池中最小的空闲的连接数，低于这个数量会被创建新的连 接。该参数越接近maxIdle，性能越好，因为连接的创建和销 毁，都是需要消耗资源的；但是不能太大。 maxWait 无限制 最大等待时间，当没有可用连接时，连接池等待连接释放的最大 时间，超过该时间限制会抛出异常，如果设置-1表示无限等待 poolPreparedStatements false 开启池的Statement是否prepared maxOpenPreparedStatements 无限制 开启池的prepared 后的同时最大连接数 minEvictableIdleTimeMillis 连接池中连接，在时间段内一直空闲， 被逐出连接池的时间 removeAbandonedTimeout 300 超过时间限制，回收没有用(废弃)的连接 removeAbandoned false 超过removeAbandonedTimeout时间后，是否进 行没用连接 （废弃）的回收 获取连接方式一： public static Connection getConnection3() throws Exception { BasicDataSource source = new BasicDataSource(); source.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;); source.setUrl(&quot;jdbc:mysql:///test&quot;); source.setUsername(&quot;root&quot;); source.setPassword(&quot;abc123&quot;); // source.setInitialSize(10); Connection conn = source.getConnection(); return conn; } 获取连接方式二： //使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐 private static DataSource source = null; static{ try { Properties pros = new Properties(); InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(&quot;dbcp.properties&quot;); pros.load(is); //根据提供的BasicDataSourceFactory创建对应的DataSource对象 source = BasicDataSourceFactory.createDataSource(pros); } catch (Exception e) { e.printStackTrace(); } } public static Connection getConnection4() throws Exception { Connection conn = source.getConnection(); return conn; } 其中，src下的配置文件为：【dbcp.properties】 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/test? rewriteBatchedStatements=true&amp;useServerPrepStmts=false username=root password=abc123 initialSize=10 #... Druid（德鲁伊）数据库连接池 Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了 日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，可以说是目前最好的连接池之一。 package com.atguigu.druid; import java.sql.Connection; import java.util.Properties; import javax.sql.DataSource; import com.alibaba.druid.pool.DruidDataSourceFactory; public class TestDruid { public static void main(String[] args) throws Exception { Properties pro = new Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;)); DataSource ds = DruidDataSourceFactory.createDataSource(pro); Connection conn = ds.getConnection(); System.out.println(conn); } } 其中，src下的配置文件为：【druid.properties】 url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true username=root password=123456 driverClassName=com.mysql.jdbc.Driver initialSize=10 maxActive=20 maxWait=1000 filters=wall 详细配置参数： 配置 缺省 说明 name 配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过 名字来区分开来。 如果没有配置，将会生成一个名字，格式 是：”DataSource-” + System.identityHashCode(this) url 连接数据库的url，不同数据库不一样。例如：mysql : jdbc:mysql://10.20.153.104:3306/druid2 oracle : jdbc:oracle:thin:@10.20.149.85:1521:ocnauto username 连接数据库的用户名 password 连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用 ConfigFilter。详细看这里：https://github.com/alibaba/druid/wiki/% E4%BD%BF%E7%94%A8ConfigFilter driverClassName 根据url自动识别 这一项可配可不配，如果不配置druid会根据url自动 识别dbType，然后选择相应的driverClassName(建议配置下) initialSize 0 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者 第一次getConnection时 maxActive 8 最大连接池数量 maxIdle 8 已经不再使用，配置了也没效果 minIdle 最小连接池数量 maxWait 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启 用公平锁，并发效率会有所下降，如果需要可以通过配置 useUnfairLock属性为true使用非公平锁。 poolPreparedStatements false 是否缓存preparedStatement，也就是PSCache。PSCache对支持游 标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。 maxOpenPreparedStatements -1 要启用PSCache，必须配置大于0，当大于0时， poolPreparedStatements自动触发修改为true。在Druid中，不会存 在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一 些，比如说100 validationQuery 用来检测连接是否有效的sql，要求是一个查询语句。如果 validationQuery为null，testOnBorrow、testOnReturn、 testWhileIdle都不会其作用。 testOnBorrow true 申请连接时执行validationQuery检测连接是否有效，做了这个配置会 降低性能。 testOnReturn false 归还连接时执行validationQuery检测连接是否有效，做了这个配置会 降低性能 testWhileIdle false 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检 测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行 validationQuery检测连接是否有效。 timeBetweenEvictionRunsMillis 有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的 判断依据，详细看testWhileIdle属性的说明 numTestsPerEvictionRun 不再使用，一个DruidDataSource只支持一个EvictionRun minEvictableIdleTimeMillis connectionInitSqls 物理连接初始化的时候执行的sql exceptionSorter 根据dbType自动识别 当数据库抛出一些不可恢复的异常时，抛弃连接 filters 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有： 监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall proxyFilters 类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非 替换关系 Apache-DBUtils实现CRUD操作 Apache-DBUtils简介 commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低， 并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。 API介绍： org.apache.commons.dbutils.QueryRunner org.apache.commons.dbutils.ResultSetHandler 工具类：org.apache.commons.dbutils.DbUtils API包说明： 主要API的使用 DbUtils DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法 如下： public static void close(…) throws java.sql.SQLException： DbUtils类提供了三个重载的关闭方 法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和 ResultSet。 public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情 况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。 public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务， 然后关闭连接 public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在 关闭连接时不抛出SQL异常。 public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断 public static void rollbackAndClose(Connection conn)throws SQLException rollbackAndCloseQuietly(Connection) public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程 序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。 QueryRunner类 该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。 QueryRunner类提供了两个构造器： 默认的构造器 需要一个 javax.sql.DataSource 来作参数的构造器 QueryRunner类的主要方法： 更新 public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行 一个更新（插入、更新或删除）操作。 插入 public T insert(Connection conn,String sql,ResultSetHandler rsh, Object... params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的键值 批处理 public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句 public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句 查询 public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句 的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。 测试 // 测试添加 @Test public void testInsert() throws Exception { QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;insert into customers(name,email,birth)values(?,?,?)&quot;; int count = runner.update(conn, sql, &quot;何成飞&quot;, &quot;he@qq.com&quot;, &quot;1992-09-08&quot;); System.out.println(&quot;添加了&quot; + count + &quot;条记录&quot;); JDBCUtils.closeResource(conn, null); } // 测试删除 @Test public void testDelete() throws Exception { QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;delete from customers where id &lt; ?&quot;; int count = runner.update(conn, sql,3); System.out.println(&quot;删除了&quot; + count + &quot;条记录&quot;); JDBCUtils.closeResource(conn, null); } ResultSetHandler接口及实现类 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。 ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。 接口的主要实现类： ArrayHandler：把结果集中的第一行数据转成对象数组。 ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。 BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。 BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。 ColumnListHandler：将结果集中某一列的数据存放到List中。 KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map 里，其key为指定的key。 MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。 MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List ScalarHandler：查询单个值对象 测试 /* * 测试查询:查询一条记录 * * 使用ResultSetHandler的实现类：BeanHandler */ @Test public void testQueryInstance() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; // BeanHandler&lt;Customer&gt; handler = new BeanHandler&lt;&gt;(Customer.class); Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null); } /* * 测试查询:查询多条记录构成的集合 * * 使用ResultSetHandler的实现类：BeanListHandler */ @Test public void testQueryList() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;; // BeanListHandler&lt;Customer&gt; handler = new BeanListHandler&lt;&gt;(Customer.class); List&lt;Customer&gt; list = runner.query(conn, sql, handler, 23); list.forEach(System.out::println); JDBCUtils.closeResource(conn, null); } /* * 自定义ResultSetHandler的实现类 */ @Test public void testQueryInstance1() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); String sql = &quot;select id,name,email,birth from customers where id = ?&quot;; ResultSetHandler&lt;Customer&gt; handler = new ResultSetHandler&lt;Customer&gt;() { @Override public Customer handle(ResultSet rs) throws SQLException { System.out.println(&quot;handle&quot;); // return new Customer(1,&quot;Tom&quot;,&quot;tom@126.com&quot;,new Date(123323432L)); if(rs.next()){ int id = rs.getInt(&quot;id&quot;); String name = rs.getString(&quot;name&quot;); String email = rs.getString(&quot;email&quot;); Date birth = rs.getDate(&quot;birth&quot;); return new Customer(id, name, email, birth); } return null; } }; Customer customer = runner.query(conn, sql, handler, 23); System.out.println(customer); JDBCUtils.closeResource(conn, null); } /* * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据， * 使用ScalarHandler * */ @Test public void testQueryValue() throws Exception{ QueryRunner runner = new QueryRunner(); Connection conn = JDBCUtils.getConnection3(); //测试一： // String sql = &quot;select count(*) from customers where id &lt; ?&quot;; // ScalarHandler handler = new ScalarHandler(); // long count = (long) runner.query(conn, sql, handler, 20); // System.out.println(count); //测试二： String sql = &quot;select max(birth) from customers&quot;; ScalarHandler handler = new ScalarHandler(); Date birth = (Date) runner.query(conn, sql, handler); System.out.println(birth); JDBCUtils.closeResource(conn, null); } JDBC总结 @Test public void testUpdateWithTx() { Connection conn = null; try { //1.获取连接的操作（ //① 手写的连接：JDBCUtils.getConnection(); //② 使用数据库连接池：C3P0;DBCP;Druid //2.对数据表进行一系列CRUD操作 //① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \\ version 2.0) //version2.0的增删改public void update(Connection conn,String sql,Object ... args){} //version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,Stringsql,Object ... args){} //② 使用dbutils提供的jar包中提供的QueryRunner类 //提交数据 conn.commit(); } catch (Exception e) { e.printStackTrace(); try { //回滚数据 conn.rollback(); } catch (SQLException e1) { e1.printStackTrace(); } }finally{ //3.关闭连接等操作 //① JDBCUtils.closeResource(); //② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作 } } ","link":"https://nanteng.github.io/post/JDBCBasic-jdbcbasic/"},{"title":"童谣","content":"耳畔又响起那首童谣， 悦耳的旋律，动听的节奏。 孩童们轻声吟唱着。 悠扬的歌声徐徐回荡， 青雉的歌者， 沉醉的听众。 恍惚间的美好叫人痴迷。 但我记得。 我记得歌词中潜藏的不堪回首的过往。 我记得被熊熊烈火吞没的房屋。 我记得被滚滚浓烟扬起的浮尘。 我记得那龟裂的泥土， 脚下的土地早已分崩离析。 我怒吼着！ 我乞求着。 我哀嚎着。 我的喉咙已然沙哑。 我的泪水已然干涸。 我不肯抹去脸颊凝固的血迹－那是我仁慈的印记。 我还记得。 我记得那艘破旧不堪的帆船上。 他们孤苦伶仃，举目无亲。 他们缺衣少食，饥寒交迫。 我怜悯他们。 我给予他们御寒的被褥，果脯的食物。 他们不感激我。 他们， 欺骗我。 抹黑我。 诋毁我。 排斥我。 他们， 侵占我的土地。 掠夺我的财富。 屠杀我的子孙。 迫使我们迁移。 万万同胞与世长眠。 他们抹杀我的语言，同化我的孩童。 他们用我的血泪谱写成传世的歌谣。 他们满口仁义道德，却尽是些虚伪刻薄。 我逃跑过－腿折了。 我挣扎过－手断了。 我呐喊过－嘴巴渗出的只有腥甜的鲜血。 我死了。 但我还活着。 我破损的残肢深埋在这片故土的每一个角落。 倘若某天，路旁又生出来朵不知名的野花。 不要惊慌， 不必诧异， 那一定是我的血肉。 ","link":"https://nanteng.github.io/post/童谣-tong-yao/"},{"title":"自语","content":"黄药师说人最大的烦恼就是记性太好， 可悲的是世界没有他口中的醉生梦死。 就我而言，盘根错节的人际关系是束缚自己的羁绊。 维系一段关系，需要全身心的投入的时间，经历，金钱。 以至于陷入对于前尘执念的沼泽。 人本身就渺小仿若微尘。 大概我这颗微尘恰巧落在了牛角尖上吧。 少时口无遮拦的誓言，早已变成晨间的雾霭 而后的自己总是逃避现实，逃避生活，逃避自己。 这些虽为不实之举，但着实有效。 信徒都渴望着自己的救赎， 我的救赎就是逃避倒也说的过去。 闲暇之余写些难登大雅之堂的文字，不失为一种慰籍。 而后再美其名曰‘文学‘ 令人耻笑 现实的自己向来对舞文弄墨一窍不通， 却时常妄想用稚白的言辞，装裱我空白的画布。 莫不是最大的讥讽。 在患得患失间踌躇， 再希望失望间徘徊。 终于暴露了潜藏在深处的受虐倾向 表现在浅显易懂得道理中横冲直撞， 固执的像头牛。 2022.3.9 ","link":"https://nanteng.github.io/post/自语-zi-yu/"},{"title":"独孤","content":"沉重的光影中， 它伫立在湖岸，在污秽中流淌。 我凝视它。 它深邃的眸子使我战栗。 它贪婪，狂妄，盛放于虚无，隐在黑暗的角落肆意生长。 我尝试将它禁锢在我铸造的牢笼中， 以防无援时侵蚀我漆黑的心脏。 可它依旧于欢笑间闪烁，直至至暗时消散，宛若诡异的磷火，灼烧着我残破不堪的躯壳。 我忌惮~ 我挣扎。 我反抗！ 它百毒不侵！ 它坚如磐石！ 它如影随形！ 眼看着浮尘混入我的呼吸， 眼看着浓烟融入我的血液。 眼看着它渗透于我血肉中每个阴暗的角落。 眼看着我在夜空下驰骋，精疲力竭。 眼看着我在射灯下酣饮，神志不清。 挫败，无力，沙哑的嘶吼。 任由它咆哮着一点点吞噬我。 卑怯包裹着我。 我沉溺在污秽的汪洋中， 我下沉着。 黑暗撕咬我的血肉。 污水侵蚀我的骨骼。 愈光明，愈黑暗。 我醒了——在一片漆黑中。 我于虚无中涅槃， 我在废墟中重生。 我百毒不侵！ 我坚如磐石！ 我，如影随形！ 我伫立在湖岸，在污秽中流淌。 它，凝视着我。 ","link":"https://nanteng.github.io/post/独孤-du-gu/"},{"title":"关于年","content":"随着年龄的增长，对于年的仪式感便越发淡漠，阵阵空虚落寞之感涌上心头，对此自己深感无力。每当此时此刻，总会遥想彼时彼刻，幼时的年是质朴的，纵是腊月寒冬，恶寒席卷全身，也总能被长辈言辞间的暖意倾散。寒舍灶房飘来的阵阵饭香，或是裹着希望和憧憬的幸运饺子，或是象征团员和睦的糯米汤圆，承载着温暖的玉盘装着香甜的饭菜，亲人齐聚一堂，其乐融融。那时的白炽灯是黄色的，灯光下人们的脸上洋溢着的是幸福的笑容，憨厚，朴实，可爱，辈分最高的长辈坐在上位，审视着众人，接着便是小辈们喜闻乐见的环节，压岁钱！小辈们轮番作揖，献上自己不太理解却又至臻至诚的祝愿，长辈们嬉笑颜开，依次派发红封。小辈们幸福的开场而后便是晚辈们的噩梦，长辈们开始了语重心长的轮番输出，我们家比较特殊，没有国际惯例的逼问和催婚环节，长辈言辞间满是对晚辈的关切。随着除夕第一挂爆竹的响起，温馨的年夜饭环节开始了。晚辈们推杯换盏，长辈们叫苦不逊，欢声笑语，好不热闹。小辈们一项不喜欢这个环节，枯燥，乏味，无趣，他们更热衷的是“小霸王学习机”上插着的200合一的游戏卡，趁着长辈还在吃饭，趁着春晚还没有开始，趁着父辈买的属于他们烟花爆竹还没有开封，此刻是属于他们的时间，至亲玩伴相聚于此，或沉迷于冒险岛，或止步魂斗罗，或沦陷超级玛丽，恶魔岛。纯粹的快乐也不过如此吧。无暇的时刻惧怕听到长辈唤自己的小名，那代表着长辈们吃完饭了，幸福时光到头了，小辈们纷纷耷拉着脑袋，愤愤惜别电视剧，但转念想到还有炮仗完，便一扫内心的隐喻，争抢着玩起了炮仗，“彭，啪”炸开的可能眼前的瓶瓶罐罐，可能是裹着爆竹的雪球，可能是爬满水草的池塘，哦对,还有可能是远处落单的牛粪。不一会，成堆的爆竹便寥寥无几了，小辈们好不过瘾，回去悻悻的拽着长辈的衣角，指了指角落的大烟花，长辈们咧嘴一笑，抱着小辈和烟花一起走向楼顶，月色下，众人仰望夜空，伴着晚辈的惊呼，烟花于夜空暂放，黎明前转瞬即逝的花朵，霎那间的美，不可方物。小辈们飞快的跑到落下，向错过烟花的人咿咿呀呀的描述着它的美，青稚的语气，坚定的语气，依旧沉醉于烟花炸开的瞬间，引得众人啼笑皆非。长辈们拉着小辈们试穿年前新做的棉袄，棉裤，棉鞋，转个身，嗯，刚刚好，说罢笑着望着小辈，一脸自豪。穿了新棉袄的小辈们好似被下了咒般，安静的围坐在长辈身边，看着自己并不感兴趣的春晚摇摇欲睡，长辈笑着打趣道，别睡，今晚守棉袄。看着双眼皮打架的小辈哄堂大笑。回忆纵然千般美好，最后落得只有回味，实属无可奈何，但转念一想，留存在记忆中的过往不应该是生命中最美好的时刻吗？点点滴滴汇集于思绪的海洋，使得自己孑然一身于大海中航行时不至于迷失。长大后的自己愈发的患得患失，长辈额前的头发越发花白，时光一遍一遍撩拨着脸颊上的皱纹，每每看见总会黯然神伤，好不是滋味。我想，这个时候最应该做的事情就是陪伴吧！好了，就此搁笔。最后，祝大家新年快乐！万事顺意。在这里给大家拜个年。 二零二二年二月一日初一小雨三级风南海区 ","link":"https://nanteng.github.io/post/关于年-guan-yu-nian/"},{"title":"对岸","content":"对岸高楼林立，黑暗包裹着星光，像镶嵌在夜空的钻石，璀璨迷人。 错落的路灯插在殷红的橡胶跑道上，犹如被禁锢的闪着黄光的萤火虫，风不时扬起门前高挂的灯笼，灯笼随着树叶摇曳，一场属于它们探戈。 灯下，孩童嬉戏着，追逐着谁家的橘猫，少年齐聚岸边石椅，思绪交汇在虚拟的世界中群雄逐鹿，壮年们张罗着门前的对联。暮年围坐树下的石桌旁，笑逐颜开的谈论着成对的青年，一片欢声笑语。青年们坐在江岸，踌躇满志，高谈阔论着对未来的憧憬。谈笑风生间荡起阵阵涟漪，扭曲了江面的倒影。目光齐齐涌向对岸，寂静无声，漆黑一片，自由的大陆，无尽的深渊。 对岸乱石林立，杂草丛生，没在水中的石阶爬满了青苔，江涛混着油污拍打着江岸，江面漂浮着污秽，年久失修的路基上镌刻着不知名的印记，破旧的木屋藏匿着遗忘的梦想。远处废弃的灯塔，不失为神圣的图腾，庇护着迷惘的灵魂。鱼儿探出头向树上叶儿吐露着爱意。叶儿羞答答的飘摇着。风牵着芭蕉树的手，轻吟着失传的歌谣，年迈的芦苇弯着腰摇着头附和着。 芦苇丛中，立着一把三条腿的木椅，岁月的摧残着它那颗古朴典雅的心，常有无家的游子光顾椅子，或小憩，或深思，或沉吟，或轻唱，但都不约而同的注视着对岸，眸中充斥着希冀。 ","link":"https://nanteng.github.io/post/对岸-dui-an/"},{"title":"不为谁而作的诗","content":"希望是什么？ 为什么我眼中只有暗淡的光。 勇敢是什么？ 为什么我面前全是浓稠的雾。 冬日的暖阳化不开我阴霾的内心， 林立的高楼盖住了我的理想。 血红的墙砖？不！那是肆意生长的欲望。 凛冽的寒风挑逗着我僵硬的脸颊。 迷茫遮蔽了双眼。 舒展着生硬的四肢， 蹒跚在无人的街道。 噢~看呐！——那是光。 黯淡无光。 ","link":"https://nanteng.github.io/post/不为谁而作的诗-bu-wei-shui-er-zuo-de-shi/"},{"title":"Aria2配合rclone实现伪离线下载","content":"Aria2是一款非常强大的下载工具，支持多种下载协议，各种好处多不胜数。具体和参考P3TERX大神的博客，以及他的Github开源代码。 本文的服务器操作系统为CentOS7 首先更新系统内核 yum update #CentOS apt-get update #Debian 下载安装Docker yum install -y yum-utils device-mapper-persistent-data lvm2 //安装必要工具 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo //设置yum源 yum install -y docker-ce //下载docker systemctl start docker //启动docker curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun #Debian为 安装Rclone（可选） 官方安装脚本 curl https://rclone.org/install.sh | bash #CentOS wget https://www.moerats.com/usr/shell/rclone_debian.sh &amp;&amp; bash rclone_debian.sh #Debian yum -y install unzip 安装fuse管理挂载目录 apt-get update &amp;&amp; apt-get install -y fuse # Debian yum install -y fuse # CentOS 复制rclone.conf文件 1.用本地的Windows下载rclone 并解压到你记得的文件夹（参考） 2.键盘按Win+X键再按A 进入Windows PowerShell 3.先获取到Token（参考） 保存{&quot;access_token&quot;:&quot;xxxxxxxx&quot;}中的内容 4.（参考） PS C:\\Windows\\system32&gt; D: PS D:\\&gt; CD D:\\rclone-v1.56.2-windows-amd64 PS D:\\rclone-v1.56.2-windows-amd64&gt; rclone authorize &quot;onedrive&quot; 2021/12/20 15:03:04 NOTICE: If your browser doesn't open automatically go to the following link: http://127.0.0.1:53682/auth?state=jZ1Gb3silUw2FQLcx448bA 2021/12/20 15:03:04 NOTICE: Log in and authorize rclone for access 2021/12/20 15:03:04 NOTICE: Waiting for code... 2021/12/20 15:04:14 NOTICE: Got code Paste the following into your remote machine ---&gt; {&quot;access_token&quot;:&quot;xxxxxxx&quot;} &lt;---End paste PS D:\\rclone-v1.56.2-windows-amd64&gt; rclone config Current remotes: Name Type ==== ==== googledrive drive onedrive onedrive ye1 onedrive e) Edit existing remote n) New remote d) Delete remote r) Rename remote c) Copy remote s) Set configuration password q) Quit config e/n/d/r/c/s/q&gt; n #输入n name&gt; ye2 #自定义 Type of storage to configure. Enter a string value. Press Enter for the default (&quot;&quot;). Choose a number from below, or type in your own value 1 / 1Fichier \\ &quot;fichier&quot; 2 / Alias for an existing remote \\ &quot;alias&quot; 3 / Amazon Drive \\ &quot;amazon cloud drive&quot; 4 / Amazon S3 Compliant Storage Providers including AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, SeaweedFS, and Tencent COS \\ &quot;s3&quot; 5 / Backblaze B2 \\ &quot;b2&quot; 6 / Box \\ &quot;box&quot; 7 / Cache a remote \\ &quot;cache&quot; 8 / Citrix Sharefile \\ &quot;sharefile&quot; 9 / Compress a remote \\ &quot;compress&quot; 10 / Dropbox \\ &quot;dropbox&quot; 11 / Encrypt/Decrypt a remote \\ &quot;crypt&quot; 12 / Enterprise File Fabric \\ &quot;filefabric&quot; 13 / FTP Connection \\ &quot;ftp&quot; 14 / Google Cloud Storage (this is not Google Drive) \\ &quot;google cloud storage&quot; 15 / Google Drive \\ &quot;drive&quot; 16 / Google Photos \\ &quot;google photos&quot; 17 / Hadoop distributed file system \\ &quot;hdfs&quot; 18 / Hubic \\ &quot;hubic&quot; 19 / In memory object storage system. \\ &quot;memory&quot; 20 / Jottacloud \\ &quot;jottacloud&quot; 21 / Koofr \\ &quot;koofr&quot; 22 / Local Disk \\ &quot;local&quot; 23 / Mail.ru Cloud \\ &quot;mailru&quot; 24 / Mega \\ &quot;mega&quot; 25 / Microsoft Azure Blob Storage \\ &quot;azureblob&quot; 26 / Microsoft OneDrive \\ &quot;onedrive&quot; 27 / OpenDrive \\ &quot;opendrive&quot; 28 / OpenStack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \\ &quot;swift&quot; 29 / Pcloud \\ &quot;pcloud&quot; 30 / Put.io \\ &quot;putio&quot; 31 / QingCloud Object Storage \\ &quot;qingstor&quot; 32 / SSH/SFTP Connection \\ &quot;sftp&quot; 33 / Sugarsync \\ &quot;sugarsync&quot; 34 / Tardigrade Decentralized Cloud Storage \\ &quot;tardigrade&quot; 35 / Transparently chunk/split large files \\ &quot;chunker&quot; 36 / Union merges the contents of several upstream fs \\ &quot;union&quot; 37 / Uptobox \\ &quot;uptobox&quot; 38 / Webdav \\ &quot;webdav&quot; 39 / Yandex Disk \\ &quot;yandex&quot; 40 / Zoho \\ &quot;zoho&quot; 41 / http Connection \\ &quot;http&quot; 42 / premiumize.me \\ &quot;premiumizeme&quot; 43 / seafile \\ &quot;seafile&quot; Storage&gt; 26 #选择26Microsoft onedrive 编号会变不固定，看准了填 OAuth Client Id Leave blank normally. Enter a string value. Press Enter for the default (&quot;&quot;). client_id&gt; #回车 OAuth Client Secret Leave blank normally. Enter a string value. Press Enter for the default (&quot;&quot;). client_secret&gt; #回车 Choose national cloud region for OneDrive. Enter a string value. Press Enter for the default (&quot;global&quot;). Choose a number from below, or type in your own value 1 / Microsoft Cloud Global \\ &quot;global&quot; 2 / Microsoft Cloud for US Government \\ &quot;us&quot; 3 / Microsoft Cloud Germany \\ &quot;de&quot; 4 / Azure and Office 365 operated by 21Vianet in China \\ &quot;cn&quot; region&gt; 1 #按实际情况填写 Edit advanced config? y) Yes n) No (default) y/n&gt; n #不需要 Use auto config? * Say Y if not sure * Say N if you are working on a remote or headless machine y) Yes (default) n) No y/n&gt; n #不用 For this to work, you will need rclone available on a machine that has a web browser available. For more help and alternate methods see: https://rclone.org/remote_setup/ Execute the following on the machine with the web browser (same rclone version recommended): rclone authorize &quot;onedrive&quot; Then paste the result. Enter a string value. Press Enter for the default (&quot;&quot;). config_token&gt; {&quot;access_token&quot;:&quot;XXXXXX&quot;} #这里输入保存的内容 Type of connection Enter a string value. Press Enter for the default (&quot;onedrive&quot;). Choose a number from below, or type in an existing value 1 / OneDrive Personal or Business \\ &quot;onedrive&quot; 2 / Root Sharepoint site \\ &quot;sharepoint&quot; 3 / Sharepoint site name or URL (e.g. mysite or https://contoso.sharepoint.com/sites/mysite) \\ &quot;url&quot; 4 / Search for a Sharepoint site \\ &quot;search&quot; 5 / Type in driveID (advanced) \\ &quot;driveid&quot; 6 / Type in SiteID (advanced) \\ &quot;siteid&quot; 7 / Sharepoint server-relative path (advanced, e.g. /teams/hr) \\ &quot;path&quot; config_type&gt; 1 #选类型1 Drive OK? Found drive &quot;root&quot; of type &quot;business&quot; URL: https://dearkai-my.sharepoint.com/personal/ye2_dearkai_onmicrosoft_com/Documents y) Yes (default) n) No y/n&gt; y #选y -------------------- [ye2] type = onedrive token = {&quot;access_token&quot;:&quot;xxxxxx&quot;} drive_id = xxxxx drive_type = xxxxx -------------------- y) Yes this is OK (default) e) Edit this remote d) Delete this remote y/e/d&gt; y #y Current remotes: Name Type ==== ==== googledrive drive onedrive onedrive ye1 onedrive ye2 onedrive e) Edit existing remote n) New remote d) Delete remote r) Rename remote c) Copy remote s) Set configuration password q) Quit config e/n/d/r/c/s/q&gt; 5.完成后C:\\Users\\User\\AppData\\Roaming\\rclone 目录下 复制rclone.conf文件到服务器/root/.config/rclone目录下，没有请自己创建 6.服务器输入rclone config确认 挂载网盘（可选） 回到你想创建挂载Onedrive的目录创建文件夹 cd .. #我选择在根目录创建 mkdir OneDrove2 手动挂载 #挂载 rclone mount &lt;网盘名称:网盘路径&gt; &lt;本地路径&gt; [参数] --daemon #取消挂载 fusermount -qzu &lt;本地路径&gt; #例： rclone mount ye2:/ /OneDrive2 --copy-links --allow-other --allow-non-empty --umask 000 --daemon #取消挂载 fusermount -qzu /Onedrive2 输入df -h查看挂载状态 自动挂载 下载脚本编辑 wget -N git.io/rcloned &amp;&amp; nano rcloned 修改内容： NAME=&quot;ye2&quot; #Rclone配置时填写的name REMOTE='' #远程文件夹，网盘里的挂载的一个文件夹，留空为整个网盘 LOCAL='/OneDrive2' #挂载地址，VPS本地挂载目录 设置开机自启 mv rcloned /etc/init.d/rcloned chmod +x /etc/init.d/rcloned update-rc.d -f rcloned defaults # Debian chkconfig rcloned on # CentOS bash /etc/init.d/rcloned start 看到 [信息] rclone 启动成功 ! 即可。 管理 开始挂载 bash /etc/init.d/rcloned start 停止挂载 bash /etc/init.d/rcloned stop 重新挂载 bash /etc/init.d/rcloned restart 查看日志 tail -f /$HOME/.rclone/rcloned.log 卸载自启挂载 bash /etc/init.d/rcloned stop update-rc.d -f rcloned remove # Debian/Ubuntu chkconfig rcloned off # CentOS rm -f /etc/init.d/rcloned 安装Aria2-Pro(P3TERX大佬的) Docker容器部署（可选）开放本机的6888,6800端口，TCP，UDP都要打开 docker run -d \\ --name aria2-pro \\ --restart unless-stopped \\ --log-opt max-size=1m \\ --network host \\ -e PUID=$UID \\ -e PGID=$GID \\ -e RPC_SECRET=xxxx \\ #这里的TOKEY更改为你想设置的，有用 -e RPC_PORT=6800 \\ -e LISTEN_PORT=6888 \\ -v ~/aria2-config:/config \\ -v ~/rclone-downloads:/downloads \\ -e SPECIAL_MODE=rclone \\ #👈 p3terx/aria2-pro 启动命令加入e SPECIAL_MODE=rclone参数设定特殊模式环境变量后开启 RCLONE 自动上传功能，容器初次启动会安装 RCLONE ，且每次重启会自动更新 RCLONE。 设置Aira2-Pro vim /root/aria2-config/script.conf 编辑script.conf 修改 dirve-name=xxx 和 drive-dir=/xxx （请自己去除注释符）更改完记得重启Aria2-Pro 安装前端面板AriaNG 这里我们依旧用DocKer安装 # bridge 网络模式 docker run -d \\ --name ariang \\ --restart unless-stopped \\ --log-opt max-size=1m \\ -p 6880:6880 \\ p3terx/ariang # host 网络模式（如果你需要使用 IPv6 网络访问，这是最简单的方式） docker run -d \\ --name ariang \\ --log-opt max-size=1m \\ --restart unless-stopped \\ --network host \\ p3terx/ariang --port 6880 --ipv6 安装完成后我们通过http://ip:6880 访问 AriaNG 在步骤 3 填写你 Aria2-Pro 的 ToKen 补充：如果连接不上请再次确认你端口已经开放 如果不想使用DoCker可以使用Aria2的脚本安装 ","link":"https://nanteng.github.io/post/Aria2配合rclone实现伪离线下载-aria2-pei-he-rclone-shi-xian-wei-li-xian-xia-zai/"},{"title":"系红领巾的少年","content":"阿藤是青年志愿者协会的会员。 第一次出活动是和会员一起去敬老院 活动结束已经中午11点了，阿藤该回学校了。 由于阿藤第一次出活动，加上没有熟识的朋友，阿藤早早的物色了回学校的路线 ‘嗯~先坐21路公交车到义务商贸城转60路回学校’ 阿藤嘴巴叼着棒棒糖，心中默念规划好的路线，用手机导航到了21公交车所在的站牌。 不一会，21路公交车缓缓驶来，阿藤瞄了眼车上的号码，确认无误后便走了上去 与往常无异，阿藤打开微信公交卡准备扫码。 ’嗯~扫不上‘阿藤皱了皱眉头，刚准备开口。 “这车机器坏了，现在只能投币”公交车师傅似乎看穿了阿藤的心思 阿腾愣住了，他早已没有带现金的习惯了。 阿藤很苦恼，眼珠一转小声问道“那刷卡可以的吧？”阿藤寄希望机器刷卡的功能没坏，这样就能拯救手足无措的他了。 “不行，机器坏了”师傅没看他。继续开着车 希望破灭了，阿藤也泄了气，就呆呆的站在公交车前投币处，陷入了进退两难的境地。 ‘那咋办？要不......逃个票？’阿藤心底响起一个声音，阿藤四下张望，生怕有人听见了他的想法‘你傻啊！这么多人，众目睽睽之下？你要不要脸？’又响起一个声音，阿藤有些烦躁。 此时一位系红领巾的小胖墩走了过来，那胖墩的小肉脸圆鼓鼓的，双颊红红的，像刚出炉的豆沙馅包子，他身着校服，背着带有学校标志的书包，走到了阿藤的前面，只见他取下书包，翻出来两张一元纸币，随即缓缓放进了投币口。 小胖墩冲阿藤笑了笑 “哥哥~我给你投了”小胖墩憨厚可鞠，脸上挂满了天真。 阿藤有些诧异，随即身体开始发抖，只见他涨红了脸，眼睛盯着地板，满脸的羞愧。 直到小胖墩回到座位上 阿藤心里五味杂陈，百般滋味。 阿藤连忙追了过去，“谢谢你，小朋...小...小兄弟“ 阿藤停顿了一下，蹲下来朝小胖墩说 ”没事~举手之劳“小胖墩又冲阿藤笑了笑，挥了挥手。 ”嘿嘿，再次感谢，那个，让我把钱转给你吧！“阿藤微笑着回应，并摇了摇手里的手机 ”我没有手机，学校不让带。“小胖墩睁着大眼看着阿藤。 “额。”阿藤有些尴尬‘早该想到的’。 阿藤想起此行的目的，考虑到敬老院或许有小朋友，便提前准备4个棒棒糖，本应还剩2个 路上阿藤吃了1个。 从口袋里拿出仅存的1根棒棒糖递给小胖墩“那我这里有1根棒棒糖，请你吃吧！” 小胖墩看了看阿藤手里的棒棒糖，又看了看阿藤嘴巴里叼着的棒棒糖，迟疑了一会摇了摇头“不用了，谢谢哥哥”。 阿藤有些不好意思，挠了挠头。 ‘呼’ 阿藤呼出一口气，眼神坚定了下来了！认真的朝小胖墩说“收下吧~这颗棒棒糖是哥哥对你的承诺，承诺以后我会和你一样，更努力的帮助需要帮助的人！” “嗯~那好吧。”小胖墩转转了眼珠，并接过我手中的棒棒糖。 车停住了。 小胖墩看了一眼阿藤，意味深长。“我到家了，再见哥哥”小胖墩朝南藤鞠了个躬。 现在阿藤想起这件事情还是很羞愧。 写于二零二一年十二月二日星期四晴 阿藤还欠小胖墩三个棒棒糖。 @21路公交车 是啊！ 世间蝇营狗苟，众生逐利，遇事则不关己高高挂起，又怎会有人体恤你的窘迫呢？ 诚然！ 但即便最污秽的地方，也终会有一束光照进来，而那束光，将承载着温暖与希望！ 南藤 ","link":"https://nanteng.github.io/post/系红领巾的少年-xi-hong-ling-jin-de-shao-nian/"},{"title":"江","content":"傍晚 深蓝的天空 绯红的夕阳灼烧着云 云一团一团的 霞光勾勒出云的轮廓 粉红色 像裹着糖衣的棉花糖 偶有几缕调皮的光束 透过厚厚的云层 犹如穹顶投下的射灯 落入荡漾的江面 霎时间 水面波光粼粼 仿佛万千铺在江水中破碎的镜片 随着江水摆动着 夕阳盖在江面 如绸缎 似水蛇 金色的波光 若天竺的舞女 扭动着纤细的腰身 亦如沉入水底的宝藏 闪闪发光 三两只飞鸟在江面盘旋 不时的掠过水面 渴望邂逅迷途的鱼儿 天渐沉了 深蓝的天空挣扎着被暗幕吞噬 夕阳，反而更红了 宛如少女的羞涩的脸蛋 江边路灯接连亮起 远处的缓缓驶过的货轮低吼着 发出”呜呜“声 江岸停泊的渔船陆续闪烁微黄的渔灯 星星点点的渔灯伴随着江水 摇曳着 仿佛随风飞舞的萤火虫 ","link":"https://nanteng.github.io/post/江-江/"},{"title":"服务器集群探针","content":"为了高效的管理服务器，实时监测服务器的数据是必要的。 这里我们使用哪吒面板来检测服务器的运行状态。 使用了美化主题后的哪吒面板 项目地址：https://github.com/naiba/nezha 准备两个子域名 一个解析服务端面板，可接入CDN安全加速访问 一个解析到服务端面板的域名，不可接入CDN（非必要，但非常建议，后期备份迁移方便） 登录GitHub账号(如果没有先注册) 创建一个OAuth Apps应用程式 Register application创建 安装服务端(监控机) 安装前需要先放行8008和5555默认端口，如果修改为了其他端口请先放行 这里使用脚本安装 #国外服务 curl -L https://raw.githubusercontent.com/naiba/nezha/master/script/install.sh -o nezha.sh &amp;&amp; chmod +x nezha.sh sudo ./nezha.sh 国内服务器 curl -L https://cdn.jsdelivr.net/gh/naiba/nezha@master/script/install.sh -o nezha.sh &amp;&amp; chmod +x nezha.sh CN=true sudo ./nezha.sh 输入 1 安装面板端 依次填入 GitHub用户名 Client ID Client secret 按提示填写即可 访问http://你的IP/域名:8008 就可以访问面板了 管理后台使用GitHub账号登录 配置反向代理+域名证书 这里我用Nginx location / { proxy_pass http://127.0.0.1:8008; proxy_set_header Host $host; } location /ws { proxy_pass http://127.0.0.1:8008; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host $host; } location /terminal { proxy_pass http://127.0.0.1:8008; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header Host $host; } Http同理 去掉 ssl段 监听80端口去掉 最后一个server 配置完成成功访问域名后回到GitHub修改OAuth Apps 将Http修改为https 以及去掉8008端口 Update application更新 安装客户端(被监控) 登录你的面板后台 GitHub账号登录 在后台主机选项点击添加主机填写对应表单后点击添加 按钮 复制密钥 到客户端服务器（被监控端）执行脚本命令 A #国外服务器 curl -L https://raw.githubusercontent.com/naiba/nezha/master/script/install.sh -o nezha.sh &amp;&amp; chmod +x nezha.sh ./nezha.sh #国内服务器 curl -L https://raw.sevencdn.com/naiba/nezha/master/script/install.sh -o nezha.sh &amp;&amp; chmod +x nezha.sh CN=true ./nezha.sh 输入 8 安装客户端监控 依次输入 解析到面板域名的域名 (域名可以不填直接填IP也可以，不建议) 端口 密钥 B 也可以在面板后台主机管理中复制一键安装脚本 如果没报错基本就完成了 常见问题 国内服务器出现curl: (7) Failed to connect to raw.githubusercontent.com echo 199.232.68.133 raw.githubusercontent.com &gt;&gt; /etc/hosts 修改服务器备注后变成&quot;离线&quot;久不恢复 在安装客户端(被监控)的服务器上执行systemctl restart nezha-agent重启程序 启动nezha-agent还是一直显示离线 检查配置有没有写对cat /etc/systemd/system/nezha-agent.service | grep ExecStart 美化主题 可以在设置中修改主题 可以在后台设置中自定义css script 哪吒监控透明主题: https://ii.do/43.html ","link":"https://nanteng.github.io/post/服务器集群探针-fu-wu-qi-ji-qun-tan-zhen/"},{"title":"南藤的音乐屋","content":"事情的起因是这样的，我偶然在gitHub看见一个qier222大神开源的音乐项目YesPlayMusic 界面，UI，真心好看，我又爱折腾，想着，部署一个属于自己的播放器 遗憾的是网页版的YesPlayMusic不支持UnblockNeteaseMusic！不支持UnblockNeteMusic是什么意思呢？当然是听不了我周董的歌啦！不过问题不大（才怪！！！我折腾了九天！！！！😭），详见orzllee大神的博客，要有国内服务器。！！注意是国内的服务器！ 以下是操作步骤：先安装Nginx Nginx安装（Docker下的nginx请忽略） 查看gcc版本 gcc -v 如果没有就 yum -y install gcc pcre、pcre-devel安装 yum install -y pcre pcre-devel zlib安装 yum install -y zlib zlib-devel 安装openssl yum install -y openssl openssl-devel 安装nginx 下载nginx压缩包 wget http://nginx.org/download/nginx-1.9.9.tar.gz 把压缩包解压到usr/local/nginx 没有nginx文件夹记得创建 tar -zxvf nginx-1.9.9.tar.gz 切换到cd /usr/local/nginx/nginx-1.9.9/下面,依次执行 ./configure make make install 扩展：ngin配置，如果提示不支持http2 记得使用然后执行上面步骤2和3 ./configure --prefix=/usr/local/nginx --with-openssl=/root/openssl-1.1.1g --with-http_addition_module --with-http_flv_module --with-http_gzip_static_module --with-http_realip_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_dav_module --with-http_v2_module 安装node.js curl -sL https://rpm.nodesource.com/setup_10.x | bash - yum -y install nodejs 使用node -v命令查看是否安装成功。 安装NeteaseCloudMusicApi 没有git的话可以执行此命令yum install git安装 git clone git://github.com/Binaryify/NeteaseCloudMusicApi.git cd NeteaseCloudMusicApi npm install 安装UnblockNeteaseMusic git clone git://github.com/nondanee/UnblockNeteaseMusic.git cd UnblockNeteaseMusic // node app.js //运行 不过暂时不用，下文配置supervisor守护进程 安装Supervisor用来守护进程 yum -y install epel-release yum -y install supervisor 使用nano编辑器更改Supervisor默认配置 没有nano先安装：yum -y install nano nano /etc/supervisord.conf // 最后一行files = supervisord.d/*.ini // 改为: 👇 files = supervisord.d/*.conf 使用nano写入以下代码 ！！注意要开放端口 3000 3001 3002 nano /etc/supervisord.d/music-api.conf [program:music-api] command=/bin/bash -c 'PORT=3000 HOST=127.0.0.1 /usr/bin/node /usr/local/vue/NeteaseCloudMusicApi/app.js' autostart=true autorestart=true user=root numprocs=1 [program:music-unblock] command=/usr/bin/node /usr/lcoal/vue/UnblockNeteaseMusic/app.js -p 3001:3002 -s -f xxx.xxx.xxx -a 127.0.0.1 -e https://xxx.xxx.com autostart=true autorestart=true user=root numprocs=1 ‼️xxx.xxx.xxx是用你的服务器ping muisc.163.com后得到的ip地址填写就进去就好了，https://xxx.xxx.xxx是你为UnblockNeteMusic配置的域名，填写进去就好了 这里我提一嘴，我是Docker容器中部署的nginx,真的是害惨我了！~！！，Docker中nginx默认配置读取不到宿主机的127.0.0.1IP段，要修改nginx启动配置文件指定网络类型，，!—net=host 🤮 Docker有四种网络模式： // host模式 –net=host // 容器和宿主机共享Network namespace。 // container模式 –net=container:NAME_or_ID // 容器和另外一个容器共享Network namespace。 kubernetes中的pod就是多个容器共享一个Network namespace。 // none模式 –net=none // 容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。 // bridge模式 –net=bridge //（默认为该模式） 运行supervisor supervisorctl reread //读取配置文件 supervisorctl update //重新更新配置文件 supervisorctl start music-api:* // 显示运行 supervisorctl start music-unblock:* error: &lt;class 'socket.error'&gt;, [Errno 2] No such file or directory: file: /usr/lib64/python2.7/socket.py line: 224 //提示这个👆错误用这个代码 /usr/bin/python2 /usr/bin/supervisord -c /etc/supervisor/supervisord.conf //补充Supercvisor命令 supervisorctl status //查看进程运行状态 supervisorctl start //进程名 启动进程 supervisorctl start laravel-worker:* //批量启动进程 supervisorctl stop //进程名 关闭进程 supervisorctl restart //进程名 重启进程 supervisorctl shutdown //关闭supervisord supervisorctl clear //进程名 清空进程日志 supervisorctl //进入到交互模式下。使用help查看所有命令 supervisorctl reread 开放端口 一般买的腾讯/阿里的VPS，在你的控制台-服务器-防火墙/安全组里面 以下操作仅限纯净版Liunx 1、开放端口 firewall-cmd --zone=public --add-port=3000/tcp --permanent # 开放3000端口 firewall-cmd --zone=public --add-port=3000/tcp --permanent # 开放3001端口 firewall-cmd --zone=public --add-port=3000/tcp --permanent # 开放3002端口 **firewall-cmd --zone=public --remove-port=3000/tcp --permanent** #关闭3000端口 firewall-cmd --reload # 配置立即生效 2、查看防火墙所有开放的端口 firewall-cmd --zone=public --list-ports 3.、关闭防火墙 如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估 **systemctl stop firewalld.service** 4、查看防火墙状态 firewall-cmd --state 5、查看监听的端口 netstat -lnpt 提示未找到命令可以用yum -y install net-tools 6、检查端口被哪个进程占用 netstat -lnpt |grep 5672 7、查看进程的详细信息 ps 6832 8、中止进程 kill -9 6832 （如果提示vim未安装）执行👇 rpm -qa |grep vim //查看少了那些 //正常应该有以上👆四个文件 yum -y install vim-minimal yum -y vim-common yum -y install vim-enhanced 如果都没有可以全部安装 yum -y install vim* YesPlayMusic 下载YesPlaymusic可以取作者GitHub页获取源码并修改编译链接👉YesPlayMusic 下载到本地使用Idea打开 yarn install 作者的文档有写复制env.example为env 并替换搭建好的api VUE_APP_NETEASE_API_URL=https://NeteaseCloudMusicApi域名 // 修改此处 VUE_APP_ELECTRON_API_URL=/api VUE_APP_ELECTRON_API_URL_DEV=https://xxx.xxx.com //以及此处 VUE_APP_ENABLE_SENTRY=false DEV_SERVER_PORT=20201 NODE_ENV=production VUE_APP_LASTFM_API_KEY=09c55292403d961aa517ff7f5e8a3d9c VUE_APP_LASTFM_API_SHARED_SECRET=307c9fda32b3904e53654baff215cb67 vue.config.js文件可以修改网页标题版权信息。 src/mian.js可以修改google analytics追踪代码ID。 src/Utils/Player.js 44行 document.title = ${track.name} · ${track.ar[0].name} - YesPlayMusic;这里YesPlayMusic是播放音乐的时候标题尾。 其他 YesPlayMusic 关键词要修改全局代码搜索 修改代码以使用UnblockNeteaseMusic文件路径为YesPlayMusic/src/utils/player.js _getAudioSourceFromNetease(track) { if (isAccountLoggedIn()) { return getMP3(track.id).then(result =&gt; { if (!result.data[0]) return null; if (!result.data[0].url) return null; if (result.data[0].freeTrialInfo !== null) return null; // 跳过只能试听的歌曲 const source = result.data[0].url.replace(/^http:/, 'https:'); if (store.state.settings.automaticallyCacheSongs) { cacheTrackSource(track, source, result.data[0].br); } return source; }); } else { //替换如下部分 let url = `https://music.163.com/song/media/outer/url?id=${track.id}`; return getMP3(track.id).then(result =&gt; { if (!result.data[0] &amp;&amp; !result.data[0].url &amp;&amp; result.data[0].freeTrialInfo !== null) { return url; } const source = result.data[0].url.replace(/^http:/, 'https:'); // const source = result.data[0].url; if (store.state.settings.automaticallyCacheSongs) { cacheTrackSource(track, source, result.data[0].br); } return source; }); } } 编译 yarn run build 配置nginx.conf server { listen 80; server_name 你的NeteaseCloudMusicApi域名; index index.php; location / { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://0.0.0.0:3000; client_max_body_size 100m; client_body_buffer_size 128k; proxy_connect_timeout 5; proxy_read_timeout 60; proxy_send_timeout 5; proxy_buffer_size 4K; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; proxy_ignore_client_abort on; } access_log off; } server { listen 443 ssl; #填写绑定证书的域名 server_name 你的NeteaseCloudMusicApi域名; #证书文件名称 ssl_certificate /usr/local/nginx/cert/你的NeteaseCloudMusicApi域名证书; #私钥文件名称 ssl_certificate_key /usr/local/nginx/cert/你的NeteaseCloudMusicApi域名证书密钥; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://0.0.0.0:3000; client_max_body_size 100m; client_body_buffer_size 128k; proxy_connect_timeout 5; proxy_read_timeout 60; proxy_send_timeout 5; proxy_buffer_size 4K; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; proxy_temp_file_write_size 64k; proxy_ignore_client_abort on; } } server { listen 80; # 监听80端口 server_name 你的NeteaseCloudMusicApi域名; # 绑定证书的域名 #把http的域名请求转成https return 301 https://$host$request_uri; } server { listen 80; server_name 你的YesPlayMusic域名; ### 记得替换 location / { root /usr/local/vue/music; #你的YesPlayMusic编译上传后的路径 index index.html index.htm; } } server { listen 443 ssl; server_name 你的YesPlayMusic域名; ssl_certificate /usr/local/nginx/cert/1_music.dearkai.cn_bundle.crt; ssl_certificate_key /usr/local/nginx/cert/2_music.dearkai.cn.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { root /usr/local/vue/music; #你的YesPlayMusic编译上传后的路径 index index.html index.htm; } } server { listen 80; server_name 你的YesPlayMusic域名; return 301 https://$host$request_uri; } server { listen 80; server_name music.163.com *.music.163.com; #此处为网易云音乐的域名，不用替换 location / { proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:3001; } } server { listen 443 ssl; server_name music.163.com *.music.163.com; ssl_certificate /usr/local/vue/UnblockNeteaseMusic/server.crt;#域名证书，默认在UnblockNeteaseMusic文件目录下 ssl_certificate_key /usr/local/vue/UnblockNeteaseMusic/server.key;#域名证书密钥，默认在UnblockNeteaseMusic文件目录下 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; location / { proxy_set_header Host $http_host; proxy_pass https://127.0.0.1:3002; } } ##nginx反向代理歌曲Url server { listen 443; server_name 你的UnblockNeteaseMusic域名; ssl on; ssl_certificate /usr/local/nginx/cert/1_unblock.dearkai.cn_bundle.crt; ssl_certificate_key /usr/local/nginx/cert/2_unblock.dearkai.cn.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { proxy_pass http://localhost:3001; } } } 修改Hosts文件路径为/etc/hosts 末尾添加,把域名劫持到本机，NeteaseCloudMusicApi请求API就会通过nginx到UnblockNeteaseMusic，让UnblockNeteaseMusic通过其他音乐平台获取相关资源： 127.0.0.1 music.163.com 127.0.0.1 interface.music.163.com 127.0.0.1 music.126.net 127.0.0.1 interface3.music.163.com nginx -t看看有错误没有,没错误nginx -s reload,然后打开网站看看。 Docker的同学请使用 docker restart nginx 特别感谢orzlee 大神，我都给人家问烦了，哈哈！没办法谁让我爱折腾呢！，这次确实学习到了不少的东西，同时也意识到自己有很多的不足之处。更让我有学习下去的动力了！喜欢才回去探索，才会努力去寻找问题的答案！这是一件好事。 好啦！这次的成品南藤的音乐屋欢迎大家访问。 —END ","link":"https://nanteng.github.io/post/南藤的音乐屋-nan-teng-de-yin-le-wu/"},{"title":"Notion使用体验·壹","content":"在这个信息获取及其简单的时代，每天海量的信息一同进入思海，有无用的知识斑驳交错，因此，合理的规划，内容的整理，目的性的筛选，可以更好的让自己获取有价值的信息。 而Notion是一款提供笔记、任务、数据库、看板、维基、日历和提醒等组件的应用程序。用户可以将这些组件连接起来，来创建自己的系统，用于知识管理、笔记记录、数据管理、项目管理等。这些组件和系统可以单独使用，也可以与他人进行跨平台协作。 Notion的CEO说过：“Notion是让大家思考怎么用，而不是非要用成什么样子。”简单理解Notion的使用其实是没有规范的，个人用途不同，涉及到的使用功能也不同。 Notion作为一款2016年创立2017年发布的软件，基本已经很完善了，相应的网络上Notion的使用方法已经很多了。所以多翻查资料总是会有意想不到的收获。 简而言之Notion是一款非常强大的文本编辑器，它的优点很多 美观 简洁 功能强大 兼容Md 不可避免的它也有很多缺点 没中文 国内用户体验差 饱受诟病的多端同步 Md导出不完美 很多事物总是充满争议的，但不置可否，Notion一个好的工具 个人需求决定你使用Notion的实际用途 页面(Page) 不同于普通的笔记软件 Notion的页面是可以互相层层嵌套的，相较于传统的笔记软件，可以更好的梳理清楚记录内容的结构，关系顺序，直观，并且一目了然。 也可以用Copy link/Link to page把页面放到你想放置的任何位置，实现多页面的相互连通,在配合Create linked database 可以在Notion中连接你想连接的一切，真正的做到“万物互联” 页面中所有的块都可以任意移动位置,用鼠标拖拽，可以随意排列，组合，把相同属性，类目的内容归纳整合到一起，利用这一点设计出一个属于自己的干净整洁的排版 控制块(Block) 在Notion中所以的内容都是一个个块组成的，文字是一个块，页面(Page)是一个块，To-do列表是一个块，一个数据库，等，甚至图像，音频，视频都是一个块。 输入‘/’可以调出基本块控制面板(Basic blocks),基本块面板中涵盖了当前版本中Notion所有的块。 操作及其简单，你可以随意的拖拽，排列，更像是，自己用一砖一瓦构建自己的宫殿，充满了无限的可能性，使用拖拽的时按住'Tab'键可以让其子内容自动缩进，计算机同学的福音，结构逻辑清晰，关系归属一目了然。完全可以胜任大部分总结任务。 数据库(Database) 以下以我的个人的数据库作为讲解展示内容这个是我的一些需求，并通过数据库连通各个类目。仅为个人需求，可供参考！ 如果说页面是Notion的外表，块是Notion的骨骼，那，数据库就是Notion的灵魂，数据库有六种不同的视图，不同视图之间可以相互切换，可以加上自己需要的标签属性，方便添加筛选，归纳整理出自己需要的分类目 表格视图(Table) 用于记录常用表格数据，可以照搬Excel的操作逻辑，也可以直接导入本地的Excel的文件上传，表格里面也是一个页面（page）这里我用的表格数据库举例 在首页图设置好细分的种类之后，用一个数据库方便浏览全局数据，我首先用的一个同步块(Synced block)同步块可以复制粘贴到Notion的任意角落，调整内容，所有块中的内容都会改变，也可以用于制作导航栏。这个表格数据库连通着我的主页中所有大大小小的项目，方便整理。 看板视图(Board) 个人用于待办事项分类，规划管理，细分规划的事物，看板视图也能添加需要的属性，进行筛选，内容也是以页面(page)呈现出来的 画廊视图（Gallery） 画廊视图是以略缩图的方式展示的，可以作为，记录观影体验，游戏指南，阅读系统，是本人最喜欢的视图 我的摄影作品类目用的就是画廊模式，设置显示的卡片为页面(page)的背景图以略缩图展示,可以方便管理浏览内容以便整改。使用All数据库创建的画廊视图，通过筛选过滤不需要的分类，显示需要的内容。 列表视图(list) 列表视图可以直观的展示出主要的内容，简洁，简约，给你耳目一新，一目了然的感觉 我把抄录的网页，和主要的纪念日，用列表视图显示，直观，简单，抄录的网页同时也连通All主数据库的，方便回看。 日历视图(Calendar) 日历视图按详细的日期排序展示主要信息，也可以按日期索引，找到指定日期的内容事件。 时间轴（Timeline） 时间轴数据库作为Notion刚出的数据库，和日历视图相似，不同的是，时间轴是按时间线划分，内容的，通过滑动视图下面的滚动条来查阅内容 补充 1.Notion提醒 只需要输入 空格 @ Remind 10/10 1500 回车 这样客户端就会在10月10日下午三点定时发送提醒 如果只是想标记日期 可以不输入前面的Remind 因为Notion在国内的网络状况堪忧，基本上不科学的情况下完全收不到推送通知，这个时候可以打开邮箱通知，此时Notion通知的是注册的邮箱，用教育优惠白嫖的朋友们，记得用该邮箱写一个转发，直接转发到微信绑定的邮箱 微信推送效果 2.Notion纪念日函数： 倒数日函数 format(dateBetween(prop(&quot;截至日期&quot;), now(), &quot;days&quot;)) &quot;剩余&quot; + format(dateBetween(prop(&quot;截至日期&quot;), now(), &quot;days&quot;)) + &quot;天&quot; 对调prop(&quot;截至日期&quot;）和now()的位置可以做纪念日的效果 &quot;已经过去&quot; + format(dateBetween(now(), prop(&quot;截至日期&quot;), &quot;days&quot;)) + &quot;天&quot; 3.Notion抄录网页 安装官方扩展 启用扩展 保存页面 --END ","link":"https://nanteng.github.io/post/Notion使用体验·壹-notion-shi-yong-ti-yan--yi/"},{"title":"阿藤的童年·贰","content":"秋收的季节，日头依旧毒辣 阿藤戴着藤爷爷退役的草帽，叼着狗尾巴草，躺在田埂上，看着天上的云朵。 年迈的黑子在阿藤的身边小憩 田间藤奶奶和藤爷爷弯着腰，挥舞着镰刀，割着金黄的麦子。 藤奶奶觉得阿藤是可怜的孩子，不让阿藤干这种力气活 藤奶奶真的很宠溺阿藤 藤奶奶告诉阿藤自己有一个妈妈 阿丽 藤奶奶说阿丽的妈妈嫌阿藤家穷，不让阿丽和阿辉在一起 阿辉是阿藤的‘爸爸’ 阿藤对这个一直缺席的‘爸爸’没有太多感情 阿辉和阿丽是没有结过婚的 怀上阿藤的时候阿辉和阿丽十二来岁 阿辉给藤奶奶讲 阿藤是在南粤的郁水镇出生的 阿藤刚出生的时候很小 四两零七钱，阿辉一只手掌大 阿藤很安静，不会哭，可把阿辉急坏了 在凌晨五点的郁水市跑了好几家医院阿藤才哭出来 阿藤对阿丽的印象是模糊的 阿藤记得阿丽对他说的最后一句话是“小藤乖～妈妈去下面给你买好吃的，待会就回来哈” 是在夜晚十点的义阳市，天还下着小雨，阿藤脸贴在宾馆的窗户上 看着阿丽的背影，阿藤问阿辉“爸爸～妈妈一会就回来了是嘛～” 阿辉沉默着 阿藤的脸就一直贴着窗户，阿藤看着玻璃外的水滴，期待着窗外小丽的身影 过了很久 阿藤阿问小辉&quot;爸爸～妈妈怎么还不回来呀！你怎么不去接妈妈呀！&quot; 阿辉沉默着 阿藤的眼睛通红，鼻子一酸，哇的一声哭了出来。 ~ 阿藤呜咽着，阿藤的眼泪哭干了，嗓子哭哑了，阿藤的鼻涕滴的满身都是。 那个时候阿藤什么都不懂 阿藤知道，妈妈不会再回来了 ～ 回到藤奶奶家 阿藤把阿辉和阿丽的合照都翻了出来 阿藤拿剪刀剪掉了所有有阿丽的照片，丢到了灶锅里烧了 藤奶奶问阿藤恨不恨阿丽 阿藤不说话 藤奶奶又问阿藤恨不恨阿辉 阿藤也不说话 那时候阿藤五岁 自那之后 阿藤格外厌恶夜晚 阿藤更喜欢发呆了 藤奶奶看在眼里 每每逢人提起阿藤 藤奶奶总是带着眼泪 阿藤变得格外的敏感和叛逆 常常忤逆藤奶奶 阿藤一受到委屈，就跑出了家 阿藤喜欢躲在阴暗的地方 湖畔的草垛，无人的旧宅，枯死的树洞 喜欢环抱着双膝，膝盖顶着额头 藤爷爷藤奶奶绕着村子 一遍遍扯着嗓子喊着阿藤的名字 阿藤被揪出来的时候身上总是脏兮兮的 藤奶奶骂着阿藤，哭着擦着阿藤身上的灰尘 藤爷爷藤奶奶一人一边拉着阿藤的手 路上的村民窃窃私语，指指点点，“这孩~挨里轻” 阿藤刚到家 黑子就低吟着，发出“呜呜”的叫声 阿藤特别喜欢黑子 阿藤不喜欢吃肉 藤奶奶给阿腾夹的肉 大部分都偷偷进了黑子的肚子 ","link":"https://nanteng.github.io/post/阿藤的童年·贰-a-teng-de-tong-nian--er/"},{"title":"关于不能安装Office问题","content":"今天在班级群里看见小伙伴说不能安装64位的office 提示已经安装了32位，同时也反应了好多朋友不会善用注册表，借这个机会带大家认识一下注册表。 一，先尝试卸载电脑中的office 可以使用Uninstall Tool 软件工具卸载 也可以点windows图标-设置-应用-程序和功能找到office程序点击卸载 二，删除office文件目录 在以下目录删除Office文件 C:\\\\Users\\\\小阿楷呀(你的文件夹)\\\\AppData\\\\Roaming\\\\Microsoft 三，清除注册表 1.win+R打开运行窗口 2.输入regedit 运行打开注册表 regedit 如图 找到Installerwen文件目录下的Products 右击删除 四，然后重新安装基本就可以啦！ -End- August 24, 2021 12:58 AM ","link":"https://nanteng.github.io/post/关于不能安装Office问题-guan-yu-bu-neng-an-zhuang-office-wen-ti/"},{"title":"阿藤的童年·壹","content":"阿藤是个男孩子，生活在蔡州，从小跟着爷爷奶奶长大 第一次见阿藤是在十七年前 阿藤躲在藤奶奶的身后揪着奶奶的衣角探出个头怯生生的看着这个陌生的村庄 阿藤很“认生” 阿藤寄居在奶奶家。藤奶奶房子前面有一个凹坡旁边有四个小猪棚 房子的门是木头的，门檐早已被岁月磨平了菱角。 进门是“过道”左右各有一个房间。右边的叫“灶屋” 左边是阿藤一家子睡觉的房间 往里走有一个“当院”当院右边有一个杂物间 里面停着藤爷爷的宝贝坐骑“手扶” 在往里有个红砖瓦房叫“堂屋” 堂屋的左右两边又各有一个房间“东房”和“西房” 藤奶奶说东房是留给自己的爸爸妈妈的 阿藤最开心的事情就是每天晚上和爷爷奶奶一起看“大屁股电视” 阿藤和奶奶一起睡觉 奶奶家还有只狗叫“黑子” 黑子是藤奶奶在阿藤来家的前一天找邻居要的 藤奶奶想让黑子陪阿藤一起长大 阿藤很乖，不吵，不闹。 每到晚上阿藤总是会睁着他圆鼓鼓的大眼睛打转，阿藤讨厌家里的挂表滴答滴答的声音还有藤爷爷的呼噜声。 奶奶家后面连着西房的地方有一个“茅房” “阿藤一家”都在这里方便 茅房旁边有一个菜园 藤奶奶叫它“后园” 后院里有一棵树，奶奶叫它苹果树，虽然阿藤从来没有见过那棵树上结过苹果 苹果树旁边有颗梨树，这个梨树阿藤是吃到了的 藤奶奶喜欢花，所以后园的周围都被藤奶奶种上了花。 后院在往后有一条河叫汝河，奶奶说这条河黄河汇流的。虽然阿藤没见过黄河。 阿藤很喜欢在河边看着附近的人钓鱼，一边看一边问“鱼是不是都很傻呀！为什么放个线它就上来了呀！” 阿藤喜欢发呆。特别是秋收的时候，爷爷开着手扶“打场”阿藤就躺在附近的草地上望着天空发呆。 阿藤喜欢“探险” 阿藤会躲在旮旯角落。找稀奇古怪的东西 然后拿到爷爷奶奶面前用奶生奶气的声音问“奶～这啥诶～” 阿藤很害羞，和爷爷奶奶一起看电视剧的时候，每每到电视剧里有亲热的镜头的时候奶奶就说“看，小藤你看，亲上了。”阿藤的小脸都会红。 阿藤很臭美，阿藤指着床上奶奶叠起来的衣服问奶奶“这啥诶～我能穿嘛”，奶奶笑着说“这是裙子，你穿个试试” 那天阿藤穿着裙子在村里跑了一天。看见的大人都忍俊不禁“这孩” 阿藤很善良，阿藤看见蚂蚁搬家的时候都会蹲下，托着腮帮子看着蚂蚁成群结队的搬运着货物。然后会找藤奶奶要一些“馍渣”看着蚂蚁用双颚夹起他丢的馍渣阿藤才会心满意足 阿藤一点都不懂事，阿藤总是会把藤奶奶气哭。然后阿藤看见藤奶奶哭，阿藤也会哭。这时候藤爷爷就摸着头看着“奶孙”俩哭焦头烂额。替爷爷解围的总是黑子 听到阿藤的哭声，黑子就过来了，这个时候爷爷好像看见了救星了般去出去捻黑子去了 阿藤一家很穷，但阿藤真的很开心 ","link":"https://nanteng.github.io/post/阿藤的童年·壹-a-teng-de-tong-nian--yi/"},{"title":"给月亮的一封信","content":"月亮 你好！ 大抵是在你言辞间读出些许温柔吧 所以请原谅我冒昧的称呼你“月亮” 我是土生土长的中国人 我崇敬你的教师职业 '师者，所以传道受业解惑也' 这是一份崇高的职业 可助莘莘学子树立正确的三观 凭此一点心中敬仰之意不觉油然而生 大概是我还没有彻底的迈步职场的原因 我喜欢安静 极度憎恶喧嚣 嘈杂的声音使我烦躁，使我丧失独立思考的能力 因此我便热衷于读书 只有在在一篇篇生动的故事中 我的世界，才真正的属于我 遨游在故事的海洋里，可以让我忘记一切的烦恼 仿佛我可以做任何事 我可以肆意编织我的梦 我可以自如的挥洒着天马行空的灵感 诚然 一系列的负面情绪都会是插在心中最为锐利的剑 无力的感觉如决堤的洪水般，在不堪一击的心理防线上肆意妄为 这是非常糟糕的 在一个崩坏的世界，异乡的游子又该何去何从呢？ 是迁移到另一方土地，去适应新的生活呢？ 亦或者是忘不了那热爱的土地，重筑新的城墙，许许修缮自己分崩离析的世界呢？ 又或者是享受着属于自己的支离破碎呢？ 不敢相信 放弃自己热衷的事情，是有多痛苦。 我喜欢自由，不喜欢束缚，喜欢做一切我去愿意做的事， 我想，这大抵就是真实的自己吧！ 不会去迎合他人的想法和观点而改变作品的本身 这些年唯一没变的就是喜欢发呆 曾经我也是一个很颓废的人 坐在顶楼的护栏上，沉醉于渐沉的夕阳 缓缓吐出的烟雾，双指夹着将燃尽的烟 看着夕阳，橘红的天，橙黄的云，犹如虬龙的鳞甲，鳞次栉比，橘黄相间，点缀着暗红的天幕。 脚下，车笛声点点消失在我的耳畔。 我就那样看着天，阵阵微风拂过耳边，像极了长辈的轻语。 然而心早就堕进了苦地 直至天色渐暗，夜幕笼罩大地 微黄的路灯有序两起，霓虹的路牌开始闪烁 ，脚下的人潮开始攒动的时候 我也就知道我该离开了 我是个极度悲观的人 篇幅有限，在这我就不在赘述了 如果月亮有兴趣 我会单独给你讲 我也是喜欢活在回忆中的人 人终是要向前看的 与其纠结于过往，在回忆的痛苦中苦苦挣扎，倒不如展望未来，迎着初生的晨阳，沐浴着阳光的洗礼 我很开心你已经步入新的开始了。也能感觉到你许许放下过往的执念和羁绊 看到你有了这么了多的兴趣 想到你的业余时间有这么充实得爱好，我倍感欣慰 还希望你不要再舍弃自己的爱好咯 很奇怪，虽说素昧平生，我已被你言语之间的温柔融为山涧的水雾 倘若青雉的我有幸在你的课堂上学习，我的观点会否有些许不同呢？ 最后，由衷的感谢你的来信 望不要嫌弃我拙劣的文笔，如有用词不当的地方忘海涵，如果能指点一二，感激不尽。 也非常感谢你愿意自己的过往经历分享给我。 如果不嫌弃，我也很乐于分享给你我的近况 那我们，常联系～ 以上 温柔的月亮🌙 期待你的回信 August 18, 2021 1:20 AM 祝身体健康 南藤 ","link":"https://nanteng.github.io/post/给月亮的一封信-gei-yue-liang-de-yi-feng-xin/"},{"title":"Docker安装环境部署","content":"一.安装配置JAVA环境 1.从JDK官方下载相应的版本：JDK下载 2.在/usr/lib目录下创建一个java-1.8.0的目录，然后将下载好的JDK压缩包复制到这个目录。 可以使用代码创建 cd /usr/lib mkdir java-1.8.0 复制命令： cp [-adfilprsu] 源文件(source) 目标文件夹(destination) 例如： cp /home/AISMALL/公共/jdk-8u291-linux-x64.tar.gz /usr/lib/java-1.8.0/ 3.然后解压该压缩包，输入如下指令： cd /usr/lib/java-1.8.0 tar zxvf jdk-8u281-linux-x64.tar.gz 4.配置环境变量，输入以下指令进行配置： vi /etc/profile 注意：按i开始编辑，编辑好先按Esc退出编辑，再按冒号，然后输入wq回车保存退出 5.在文件尾部添加如下信息： JAVA_HOME=/usr/lib/java-1.8.0/jdk1.8.0_281 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JAVA_HOME export PATH export CLASSPATH 注意：JAVA_HOME=/usr/lib/java-1.8.0/jdk1.8.0_291此处等号右边的是自己的jdk实际解压目录。如果不是该目录则需要改成自己的实际目录，其他不变。 6.保存完之后，我们还需要让这个环境变量配置信息立即生效 source /etc/profile 7.安装完成之后可以通过以下命令查看是否安装成功 java -version 使用yun updata更新依赖包 注意！会关闭部分应用 yum update //升级所有包同时也升级软件和系统内核 yum upgade //只升级所有包，不升级软件和系统内核 二.安装Dcoker yum install -y yum-utils device-mapper-persistent-data lvm2 //安装必要工具 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo //设置yum源 yum install -y docker-ce //下载docker systemctl start docker //启动docker 三.安装MySQL docker pull mysql //拉起MySQL镜像 docker run --name mysql --restart=always --net=host -p 3306:3306 -e MYSQL_ROOT_PASSWORD=YourPassword -d mysql //启动MySQL 四.安装Redis docker pull redis //下载安装redis docker run --name redis --restart=always -p 6379:6379 -d redis --requirepass &quot;YourPassword&quot; 五.安装nginx docker pull nginx //download nginx image docker run --name nginx --restart=always --privileged=true -p 80:80 -p 443:443 -d -v /usr/local/nginx/nginx.conf:/etc/nginx/nginx.conf -v /usr/local/vue:/usr/local/vue -v /usr/local/nginx/cert:/usr/local/nginx/cert nginx //启动nginx，映射本地配置文件 docker run --name nginx --restart=always --privileged=true --net=host -p 80:80 -p 443:443 -d -v /usr/local/nginx/nginx.conf:/etc/nginx/nginx.conf -v /usr/local/vue:/usr/local/vue -v /usr/local/nginx/cert:/usr/local/nginx/cert nginx 六.安装elasticsearch docker pull elasticsearch:7.9.2 //下载elasticsearch镜像 docker network create esnet//创建一个网络 使得es可以和Kibana通信 docker run -d --restart=always -p 9200:9200 -p 9300:9300 --name elasticsearch elasticsearch:7.9.2 //启动elasticsearch docker run -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx576m&quot; --name elasticsearch -p 9200:9200 -p 9300:9300 --network esnet -e &quot;discovery.type=single-node&quot; elasticsearch:7.9.2//限制内存启动用这个 docker exec -it elasticsearch /bin/bash //进入elasticsearch容器 ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.9.2/elasticsearch-analysis-ik-7.9.2.zip// 安装il分词器 exit //退出容器 docker pull mobz/elasticsearch-head:5//安装head5 docker run -d --name elasticsearch-head --net esnet -p 9100:9100 mobz/elasticsearch-head:5 七.跨域配置 为了实现通信首先进入elasticsearch容器中 docker exec -it elasticsearch /bin/bash //进入elasticsearch容器 直接在修改/config/elasticsearch.yml文件 首先安装vim，有点耗存储（60MB） yum install vim 安装完添加跨域配置，方便各服务之间的调用 在vim config/elasticsearch.yml 文件中添加如下内容 http.cors.enabled: true http.cors.allow-origin: &quot;*&quot; 然后重启容器 exit docker restart elasticsearch 八.安装Rabbit docker pull rabbitmq:management //下载RabbitMQ镜像 docker run --name rabbit --restart=always -p 15672:15672 -p 5672:5672 -d rabbitmq:management //启动RabbitMQ,默认guest用户，密码也是guest。 九.安装MaxWell docker pull zendesk/maxwell //下载MaxWell镜像 docker run --name maxwell --restart=always -d zendesk/maxwell bin/maxwell --user='root' --password='YourPassword' --host='Your IP' --producer=rabbitmq --rabbitmq_user='guest' --rabbitmq_pass='guest' --rabbitmq_host='Your IP' --rabbitmq_port='5672' --rabbitmq_exchange='maxwell' --rabbitmq_exchange_type='fanout' --rabbitmq_exchange_durable='true' --filter='exclude: *.*, include: blog.tb_article.article_title = *, include: blog.tb_article.article_content = *, include: blog.tb_article.is_delete = *' //运行MaxWell Docker常用命令 docker images //列出镜像 docker ps //列出所有容器 docker restart //重新启动一个或多个容器 docker rm //删除一个或多个容器 docker rmi //删除一个或多个镜像 docker logs //取得容器的日志 docker stop //停止一个或多个正在运行的容器 docker restart //重新启动一个或多个容器 docker build -t blog.//根据 Dockerfile 构建一个blog镜像 感谢 @风丶宇 提供的技术指导 感谢小葵哥 August 10, 2021 4:32 PM ","link":"https://nanteng.github.io/post/Docker安装环境部署-docker-an-zhuang-huan-jing-bu-shu/"},{"title":"清风梨巷","content":"青柳垂池岸， 清风碧叶摆。 蝉吟花飘摇， 残亭过客稀。 ","link":"https://nanteng.github.io/post/清风梨巷-qing-feng-li-xiang/"},{"title":"霞","content":"黄昏走了 落霞应着暗红的天幕 夜快来了 微黄的路灯 霓虹的广告牌 杂乱的小摊 嘈杂的车声 散落的宣传单 撒欢的小狗 还有一群沉醉在着暮色下的人 ","link":"https://nanteng.github.io/post/霞-xia/"},{"title":"轻轨","content":"我是一阵风 你我相逢于一片葱郁 轻抚你微翘的睫毛 你不必惊喜 也无需诧异 在重峦叠嶂间灭了踪影 我是一棵树 你我重逢在一片漆黑 划过你修长的指尖 你有你的归宿 我有我的方向 你记得也好 最好都忘掉 那黑夜中迸溅的光 ","link":"https://nanteng.github.io/post/轻轨-qing-gui/"}]}